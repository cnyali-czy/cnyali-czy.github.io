{"pages":[{"title":"关于QAQ","text":"众所周知很菜的一个Oier。 我的邮箱是yms-chenziyang@outlook.com 我的QQ?16830053325","link":"/about/index.html"}],"posts":[{"title":"Todo List","text":"咕咕咕咕咕 emm我觉得我回来了。然后吗，计划什么重新搞一搞吧。下面暂时维(gu)持(gu)不(gu)变(gu)吧。 今天看了一下黑板，好像只有$22$天的逍遥日子过了。菜死了菜死了。好慌啊，于是定个计划算了。 先是还要学的（一部分）数据结构 平衡树 动态树 主席树 珂朵莉树 可持久化 AC自动机 回文自动机 后缀自动机 李超线段树 ZKW数据结构 吉司机线段树 线段树树套线段树 线段树树套平衡树 算法 分块 莫队 点分治 边分治 插头dp CDQ分治 模拟退火 整体二分 康托展开 manacher 粒子群优化 高级网络流 优化 单调队列 斜率优化 四边形不等式 数学 FFT NTT MTT FWT polya 博弈论 杜教筛 单纯型 微积分 斯特林数 计算几何基础 莫比乌斯反演 再是还要做的靠这怎么做得完啊啊啊啊啊啊啊。 51nod「$1/1$」 1514 美妙的序列 Atcoder「$3/7$」 ARC 080 F [Prime Flip] ARC 093 F [Dark Horse] ARC 096 E [Everything on It] ARC 101 E [Ribbons on Tree] ARC 102 E [Stop. Otherwise…] AGC 016 D [XOR Replace] AGC 018 F [Two Trees] BZOJ「$10/15$」 1951 [SDOI2010 古代猪文] 2005 [NOI2010 能量采集] 2331 [SCOI2011 地板] 2461 [BEIJING2011 符环] 2818 Gcd 2982 combination 3122 [SDOI2013 随机数生成器] 3513 [MUTC2013 idots] 3771 Triple 3994 约数个数和 4054 [CERC2013 Escape] 4137 [FJOI2015 火星商店问题] 4522 [CQOI2016 密钥破解] 4555 [TJOI &amp; HEOI 2016 求和] 5336 [TJOI2018 party] HDU「$1/1$」 6583 Typewriter LOJ「$4/9$」 111 后缀排序 2001 [SDOI2017 树点涂色] 2006 [SCOI2015 小凸玩矩阵] 2057 [TJOI2016 &amp; HEOI2016 游戏] 2059 [TJOI2016 &amp; HEOI2016 字符串] 2434 [ZJOI2018 历史] 2548 [JSOI2018 绝地反击] 3058 [HNOI2019 白兔之舞] 3120 [CTS2019 珍珠] Luogu「$5/8$」 1357 花园 2657 [SCOI2009 windy数] 3157 [CQOI2011 动态逆序对] 3515 [POI2011 Lightning Conductor] 3978 [TJOI2015 概率论] 4074 [WC2016 糖果公园] 4238 多项式求逆 5075 [JSOI2012 分零食] UOJ「$3/3$」 35 后缀排序 131 品酒大会 219 优秀的拆分","link":"/6667/12/03/Todo-List/"},{"title":"口胡 BZOJ4522 [CQOI2016 密钥破解]","text":"传送门 题目大意自己去看。 解析一个数论大板子。 分解之质因数的话用泼辣肉，然后$exgcd$求一下逆元。 细节有点多（好像还要快速乘，问题不大）","link":"/2019/08/21/口胡-BZOJ4522-CQOI2016-密钥破解/"},{"title":"LOJ2006 [SCOI2015 小凸玩矩阵]","text":"传送门 题目大意给你一个$n\\le250$行$m\\le250$列的矩阵，你需要选出$N$个两两不再同一行或同一列的数，最小化这$N$个数的第$K$大。 解析这个范围就很像网络流。 考虑二分答案，然后我们把所有小于等于当前二分值的数记作$0$，大于的记作$1$。 那么现在问题就变成了选符合条件的$0$，能选出$N-K+1$个即可。 行列拆点就可以了。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#define DREP(i, s, e) for(int i = s; i &gt;= e ;i--)#define REP(i, s, e) for(int i = s; i &lt;= e ;i++)#define DEBUG fprintf(stderr, \"Passing [%s] in Line %d\\n\", __FUNCTION__, __LINE__)#define chkmax(a, b) a = max(a, b)#define chkmin(a, b) a = min(a, b)#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;const int maxn = 250 + 5, maxm = 250 + 5, maxN = maxn + maxm, maxE = maxn * maxm;int bg[maxN], ne[maxE &lt;&lt; 1], to[maxE &lt;&lt; 1], w[maxE &lt;&lt; 1], e = 1;inline void add(int x, int y, int z){ e++; to[e] = y; ne[e] = bg[x]; bg[x] = e; w[e] = z;}#define link(x, y) add((x), (y), 1), add((y), (x), 0)static char buf[100000], *p1(buf), *p2(buf);#define Getchar() (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++)template &lt;typename T&gt; inline T read(){ T ans(0); char c = Getchar(); while (!isdigit(c)) c = Getchar(); while (isdigit(c)) { ans = ans * 10 + c - 48; c = Getchar(); } return ans;}int n, m, k, N, S, T;#define clear()\\{\\ REP(i, 1, N) bg[i] = 0;\\ e = 1;\\}int a[maxn][maxm];int q[maxN], head, tail, dis[maxN];inline bool bfs(){ REP(i, 1, N) dis[i] = -1; dis[q[head = tail = 1] = T] = 0; while (head &lt;= tail) { int x = q[head++]; for (int i = bg[x]; i ; i = ne[i]) if (w[i ^ 1] &gt; 0 &amp;&amp; dis[to[i]] == -1) dis[q[++tail] = to[i]] = dis[x] + 1; } return dis[S] != -1;}int cur[maxN];int dfs(int x = S, int y = 1e9){ if (x == T || !y) return y; int res(0), temp; for (int &amp;i = cur[x]; i ; i = ne[i]) if (w[i] &gt; 0 &amp;&amp; dis[to[i]] == dis[x] - 1 &amp;&amp; (temp = dfs(to[i], min(y, w[i]))) &gt; 0) { res += temp; w[i] -= temp; w[i ^ 1] += temp; if (!(y -= temp)) goto end; }end: return res;}inline bool judge(int mid){ clear(); REP(i, 1, n) REP(j, 1, m) if (a[i][j] &lt;= mid) link(i, j + n); REP(i, 1, n) link(S, i); REP(i, 1, m) link(i + n, T); int res(0); while (bfs()) { copy(bg + 1, bg + 1 + N, cur + 1); if ((res += dfs()) &gt;= n - k + 1) return 1; } return 0;}#define mid (l + r &gt;&gt; 1)int main(){#ifdef CraZYali freopen(\"2006.in\", \"r\", stdin); freopen(\"2006.out\", \"w\", stdout);#endif n = read&lt;int&gt;();m = read&lt;int&gt;();k = read&lt;int&gt;(); int l(1e9), r(1); REP(i, 1, n) REP(j, 1, m) { a[i][j] = read&lt;int&gt;(); chkmax(r, a[i][j]); chkmin(l, a[i][j]); } S = n + m + 1; N = T = S + 1; while (l &lt;= r) if (judge(mid)) r = mid - 1; else l = mid + 1; cout &lt;&lt; r + 1 &lt;&lt; endl; return 0;}","link":"/2019/08/20/LOJ2006-SCOI2015-小凸玩矩阵/"},{"title":"LOJ2057 [TJOI2016 & HEOI2016 游戏]","text":"传送门 题目大意给定一个$n\\le50$行$m\\le50$列的网格图，每个格子可能是空地*、软石x或者硬石#。 你可以且仅可以在空地上放炸弹，炸弹会以十字形方向爆炸。 炸弹可以炸穿软石，但是不能炸穿硬石。 询问最多能放几个炸弹。 解析一开始看到$n,m\\le50$的范围我以为是一个状压然后玄学的题。 后来发现其实就是个二分图。 我们考虑把每个空地能炸穿的范围全部弄出来，它的表现就是横竖方向的两个区间，我们把这里那个区间连边。 什么时候一个炸弹不会炸到另一个炸弹呢？就是一个横区间恰好对应一个纵区间的时候！（单身的没人权） 那这就是一个二分图匹配了。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#define DREP(i, s, e) for(int i = s; i &gt;= e ;i--)#define REP(i, s, e) for(int i = s; i &lt;= e ;i++)#define DEBUG fprintf(stderr, \"Passing [%s] in Line %d\\n\", __FUNCTION__, __LINE__)#define chkmax(a, b) a = max(a, b)#define chkmin(a, b) a = min(a, b)#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;const int maxn = 50 + 5, maxm = 50 + 5, maxN = maxn * maxm &lt;&lt; 1, maxE = maxn * maxm, inf = 1e9;int bg[maxN], to[maxE &lt;&lt; 1], ne[maxE &lt;&lt; 1], w[maxE &lt;&lt; 1], e = 1;inline void add(int x, int y, int z){ e++; to[e] = y; ne[e] = bg[x]; bg[x] = e; w[e] = z;}inline void link(int x, int y) {add(x, y, 1);add(y, x, 0);}template &lt;typename T&gt; inline T read(){ T ans(0), p(1); char c = getchar(); while (!isdigit(c)) { if (c == '-') p = -1; c = getchar(); } while (isdigit(c)) { ans = ans * 10 + c - 48; c = getchar(); } return ans * p;}char s[maxn][maxm];int belongx[maxn][maxm], belongy[maxn][maxm];int n, m, N, S, T, curx, cury, ans;int cur[maxN], dis[maxN], q[maxN], head, tail;inline bool bfs(){ REP(i, 1, N) dis[i] = -1; dis[q[head = tail = 1] = T] = 0; while (head &lt;= tail) { int x = q[head++]; for (int i = bg[x]; i ; i = ne[i]) if (w[i ^ 1] &gt; 0 &amp;&amp; dis[to[i]] == -1) dis[q[++tail] = to[i]] = dis[x] + 1; } return dis[S] != -1;}int dfs(int x = S, int y = inf){ if (x == T || !y) return y; int res(0); for (int &amp;i = cur[x]; i ; i = ne[i]) if (w[i] &gt; 0 &amp;&amp; dis[to[i]] == dis[x] - 1) { int temp = dfs(to[i], min(y, w[i])); if (temp &gt; 0) { res += temp; w[i] -= temp; w[i ^ 1] += temp; y -= temp; if (!y) goto End; } }End: return res;}inline void dinic(){ while (bfs()) { copy(bg + 1, bg + 1 + N, cur + 1); ans += dfs(); }}int main(){#ifdef CraZYali freopen(\"2057.in\", \"r\", stdin); freopen(\"2057.out\", \"w\", stdout);#endif cin &gt;&gt; n &gt;&gt; m; REP(i, 1, n) scanf(\"%s\", s[i] + 1); REP(i, 1, n) REP(j, 1, m) if (s[i][j] != '#') belongx[i][j] = belongx[i][j-1] ? belongx[i][j-1] : ++curx; REP(j, 1, m) REP(i, 1, n) if (s[i][j] != '#') belongy[i][j] = belongy[i-1][j] ? belongy[i-1][j] : ++cury; REP(i, 1, n) REP(j, 1, m) if (s[i][j] == '*') link(belongx[i][j], curx + belongy[i][j]); S = curx + cury + 1; N = T = curx + cury + 2; REP(i, 1, curx) link(S, i); REP(i, 1, cury) link(i + curx, T); dinic(); cout &lt;&lt; ans &lt;&lt; endl; return 0;}","link":"/2019/08/19/LOJ2057-TJOI2016-HEOI2016-游戏/"},{"title":"口胡 Luogu3157 [CQOI2011 动态逆序对]","text":"传送门 题目大意给定一个$1$到$n\\le10^5$的排列。 有$m$次删除操作，每次删去一个数，问删去前序列的逆序对是多少。 解析K-D Tree想练习一下K-D Tree，结果做法不太对，被卡常了。 小问题，我口胡一下K-D Tree的正解。 一个数产生的贡献是：$$\\sum_{k&lt;i} [a_k&gt;a_i]+\\sum_{i&lt;k}[a_i&gt;a_k]$$考虑把每个数$a_i$记作二维平面上的一个点$(i,a_i)$，那么一个数产生的贡献就变成了它左上角和右下角的点数之和。 这个就可以K-D Tree了。 主席树再上一个树状数组，随便做。 Code咕咕咕 K-D Tree($80pts$)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118// luogu-judger-enable-o2#pragma GCC optimize (\"O3\")#define DREP(i, s, e) for(int i = s; i &gt;= e ;i--)#define REP(i, s, e) for(int i = s; i &lt;= e ;i++)#define DEBUG fprintf(stderr, \"Passing [%s] in Line %d\\n\", __FUNCTION__, __LINE__)#define chkmax(a, b) a = max(a, b)#define chkmin(a, b) a = min(a, b)#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;const int maxn = 100000 + 10, maxm = 50000 + 10, inf = 1e9;template &lt;typename T&gt; inline T read(){ T ans(0), p(1); char c = getchar(); while (!isdigit(c)) { if (c == '-') p = -1; c = getchar(); } while (isdigit(c)) { ans = ans * 10 + c - 48; c = getchar(); } return ans * p;}int n, m, a[maxn], t[maxn], del[maxn], id[maxn], notin[maxn];int cnt[maxn &lt;&lt; 1], Min[maxn &lt;&lt; 1], Max[maxn &lt;&lt; 1], lp[maxn &lt;&lt; 1], rp[maxn &lt;&lt; 1];#define mid (l + r &gt;&gt; 1)#define ls p &lt;&lt; 1#define rs p &lt;&lt; 1 | 1#define lson ls, l, mid - 1#define rson rs, mid + 1, rinline bool cmp1(int a, int b) {return a &lt; b;}inline bool cmp2(int a, int b) {return id[a] &lt; id[b];}inline int Cmp1(const void *a, const void *b) {return (*(int*)a) - (*(int*)b);}inline int Cmp2(const void *a, const void *b) {return id[(*(int*)a)] - id[(*(int*)b)];}int pos[maxn];#define pushup(p, l, r)\\{\\ cnt[p] = (!notin[t[mid]]) + cnt[ls] + cnt[rs];\\ Min[p] = min(notin[t[mid]] ? inf : t[mid], min(Min[ls], Min[rs]));\\ Max[p] = max(notin[t[mid]] ? -inf : t[mid], max(Max[ls], Max[rs]));\\}void build(int p, int l, int r, bool flag = 0){ if (l &gt; r) return; qsort(t + l, r - l + 1, 4, flag ? Cmp1 : Cmp2); pos[t[mid]] = mid; lp[p] = rp[p] = id[t[mid]]; build(lson, flag ^ 1); build(rson, flag ^ 1); cnt[p] = !notin[t[mid]]; Min[p] = notin[t[mid]] ? inf : t[mid]; Max[p] = notin[t[mid]] ? -inf : t[mid]; if (l &lt; r) { pushup(p, l, r); chkmin(lp[p], min(lp[ls], lp[rs])); chkmax(rp[p], max(rp[ls], rp[rs])); }}int queryA(int p, int l, int r, int L, int R, int val){ if (l &gt; r || L &gt; rp[p] || R &lt; lp[p] || Max[p] &lt; val || !cnt[p]) return 0; bool flag(!notin[t[mid]] &amp;&amp; L &lt;= id[t[mid]] &amp;&amp; id[t[mid]] &lt;= R &amp;&amp; t[mid] &gt; val); if (L &lt;= lp[p] &amp;&amp; rp[p] &lt;= R &amp;&amp; Min[p] &gt; val) return cnt[p]; else return queryA(lson, L, R, val) + queryA(rson, L, R, val) + flag;}int queryB(int p, int l, int r, int L, int R, int val){ if (l &gt; r || L &gt; rp[p] || R &lt; lp[p] || Min[p] &gt; val || !cnt[p]) return 0; bool flag(!notin[t[mid]] &amp;&amp; L &lt;= id[t[mid]] &amp;&amp; id[t[mid]] &lt;= R &amp;&amp; t[mid] &lt; val); if (L &lt;= lp[p] &amp;&amp; rp[p] &lt;= R &amp;&amp; Max[p] &lt; val) return cnt[p]; else return queryB(lson, L, R, val) + queryB(rson, L, R, val) + flag;}void insert(int p, int l, int r, int pos){ cnt[p]++; chkmin(Min[p], t[pos]); chkmax(Max[p], t[pos]); if (mid == pos) return; else if (pos &lt; mid) insert(lson, pos); else insert(rson, pos);}long long ans[maxm];int main(){#ifdef CraZYali freopen(\"3157-new.in\", \"r\", stdin); freopen(\"3157-new.out\", \"w\", stdout);#endif cin &gt;&gt; n &gt;&gt; m; REP(i, 0, 200000) Max[i] = rp[i] = -inf, Min[i] = lp[i] = inf; REP(i, 1, n) id[a[i] = read&lt;int&gt;()] = i; REP(i, 1, m) notin[del[i] = read&lt;int&gt;()] = 1; copy(a + 1, a + 1 + n, t + 1); build(1, 1, n); REP(i, 1, n) if (!notin[a[i]]) ans[m+1] += queryB(1, 1, n, i+1, n, a[i]); DREP(i, m, 1) { ans[i] = ans[i+1] + queryA(1, 1, n, 1, id[del[i]] - 1, del[i]) + queryB(1, 1, n, id[del[i]] + 1, n, del[i]); notin[del[i]] = 0; insert(1, 1, n, pos[del[i]]); } REP(i, 1, m) printf(\"%lld\\n\", ans[i]); return 0;} 主席树(AC)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#define REP(i, s, e) for (int i = s; i &lt;= e; i++)#define DREP(i, s, e) for (int i = s; i &gt;= e; i--)#define DEBUG fprintf(stderr, \"Passing [%s] in Line %d\\n\", __FUNCTION__, __LINE__)#define chkmax(a, b) a = max(a, b)#define chkmin(a, b) a = min(a, b)#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;const int maxn = 100000 + 10;template &lt;typename T&gt; T read(){ T ans = 0, p = 1; char c = getchar(); while (!isdigit(c)) { if (c == '-') p = -1; c = getchar(); } while (isdigit(c)) { ans = ans * 10 + c - 48; c = getchar(); } return ans * p;}struct node *null;const int maxnode = 28000000;int rt[maxnode], ls[maxnode], rs[maxnode], sum[maxnode], cur, LL[30], RR[30];#define mid (l + r &gt;&gt; 1)#define lson ls[p], l, mid#define rson rs[p], mid + 1, rvoid update(int &amp;p, int l, int r, int pos, int num){ if (!p) p = ++cur; sum[p] += num; if (l == r) return; else if (pos &lt;= mid) update(lson, pos, num); else update(rson, pos, num);}int n, m, a[maxn], pos[maxn];long long ans;int query(int l, int r, int val, bool mode){ int lsz(0), rsz(0), s(0); for (int i = l-1; i &gt; 0; i -= i &amp; -i) LL[++lsz] = rt[i]; for (int i = r ; i &gt; 0; i -= i &amp; -i) RR[++rsz] = rt[i]; l = 1, r = n; while (l &lt; r) if (val &gt; mid) { if (mode) { REP(i, 1, lsz) s -= sum[ls[LL[i]]]; REP(i, 1, rsz) s += sum[ls[RR[i]]]; } REP(i, 1, lsz) LL[i] = rs[LL[i]]; REP(i, 1, rsz) RR[i] = rs[RR[i]]; l = mid + 1; } else { if (!mode) { REP(i, 1, lsz) s -= sum[rs[LL[i]]]; REP(i, 1, rsz) s += sum[rs[RR[i]]]; } REP(i, 1, lsz) LL[i] = ls[LL[i]]; REP(i, 1, rsz) RR[i] = ls[RR[i]]; r = mid ; } return s;}int main(){#ifdef CraZYali freopen(\"3157.in\", \"r\", stdin); freopen(\"3157.out\", \"w\", stdout);#endif cin &gt;&gt; n &gt;&gt; m; REP(i, 1, n) { pos[a[i] = read&lt;int&gt;()] = i; ans += 1ll * query(1, i-1, a[i], 0); for (int j = i; j &lt;= n; j += j &amp; -j) update(rt[j], 1, n, a[i], 1); } while (m --&gt; 0) { printf(\"%lld\\n\", ans); int x = read&lt;int&gt;(), p = pos[x]; ans -= query(1, p - 1, x, 0); ans -= query(p + 1, n, x, 1); for (int i = p; i &lt;= n; i += i &amp; -i) update(rt[i], 1, n, x, -1); } return 0;} CDQ咕咕咕。 12345678#include &lt;...&gt;using namespace std;void input(){...}void output(){...}#define mid (l+r&gt;&gt;1)void work(int l,int r){...}inline void CDQ(int l, int r) {CDQ(l,mid);CDQ(mid+1,r);work(l,r);}int main(){return input(),CDQ(1,n),output(),0;} 后记其实这个题好像还可以CDQ。 本来就是一个类似二维数点的东西，那CDQ不是随便做？ 有时间再写吧。","link":"/2019/08/18/口胡-Luogu3157-CQOI2011-动态逆序对/"},{"title":"胡闹 方差","text":"题目大意维护一颗$n\\le10^5$个点的树，每个点有颜色$c_i\\le10^5$。 初始时只有$1$号节点。 三种操作： 加入一个点，给定它的编号、颜色和父亲。 询问路径$(x,y)$上的所有点。 询问点$x$的子树内的所有点（以$1$为根）。 询问的意思是说，把所有的点的颜色去重求方差。 解析我们可以离线，那么完全可以把两个操作分开来处理。 操作$2$直接树上莫队。 操作$3$直接带修莫队。 完了。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208#define DREP(i, s, e) for(int i = s; i &gt;= e ;i--)#define REP(i, s, e) for(int i = s; i &lt;= e ;i++)#define DEBUG fprintf(stderr, \"Passing [%s] in Line %d\\n\", __FUNCTION__, __LINE__)#define chkmax(a, b) a = max(a, b)#define chkmin(a, b) a = min(a, b)#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;using namespace std;const int maxn = 1e5 + 10, maxm = maxn;int bg[maxn], ne[maxm &lt;&lt; 1], to[maxm &lt;&lt; 1], e;inline void add(int x, int y){ e++; to[e] = y; ne[e] = bg[x]; bg[x] = e;}template &lt;typename T&gt; inline T read(){ T ans(0), p(1); char c = getchar(); while (!isdigit(c)) { if (c == '-') p = -1; c = getchar(); } while (isdigit(c)) { ans = ans * 10 + c - 48; c = getchar(); } return ans * p;}int n = 1, m;int val[maxm];struct opt{ int type, a, b;}o[maxm];int st[maxn], ed[maxn], back[maxn&lt;&lt;1], dfn[maxn], dfs_clock, ww[maxn], fa[maxn], top[maxn], siz[maxn], hvy[maxn], depth[maxn];void dfs1(int x){ back[st[x] = ++dfs_clock] = x; siz[x] = 1; for (int i = bg[x]; i ; i = ne[i]) { depth[to[i]] = depth[x] + 1; dfs1(to[i]); siz[x] += siz[to[i]]; if (siz[to[i]] &gt; siz[hvy[x]]) hvy[x] = to[i]; } back[ed[x] = ++dfs_clock] = x;}void dfs2(int x, int y){ ww[dfn[x] = ++dfs_clock] = val[x]; top[x] = y; if (hvy[x]) dfs2(hvy[x], y); for (int i = bg[x]; i ; i = ne[i]) if (to[i] ^ hvy[x]) dfs2(to[i], to[i]);}inline int lca(int x, int y){ while (top[x] ^ top[y]) { if (depth[top[x]] &lt; depth[top[y]]) swap(x, y); x = fa[top[x]]; } return depth[x] &lt; depth[y] ? x : y;}int belong[maxn&lt;&lt;1];double ans[maxn];int cnt[maxn], l, r, T;long long sigma, sigma2, N;#define bar ((double)sigma / N)#define S2 ((sigma2 + bar * bar * N - bar * sigma * 2) / N)inline void add(long long c) {if (c &amp;&amp; !cnt[c]++) sigma += c, sigma2 += c * c, N++;}inline void del(long long c) {if (c &amp;&amp; !--cnt[c]) sigma -= c, sigma2 -= c * c, N--;}struct query{ int l, r, t, id, spj; query(int _l = 0, int _r = 0, int _id = 0, int _spj = 0, int _t = 0) : l(_l), r(_r), id(_id), spj(_spj), t(_t){}}q[maxm];inline bool operator &lt; (query A, query B) {return belong[A.l] &lt; belong[B.l] || (belong[A.l] == belong[B.l] &amp;&amp; belong[A.r] &lt; belong[B.r]) || (belong[A.l] == belong[B.l] &amp;&amp; belong[A.r] == belong[B.r] &amp;&amp; A.t &lt; B.t);}namespace path{ bool vis[maxn]; inline void opt(int x) { if (vis[x]) del(val[x]); else add(val[x]); vis[x] ^= 1; } int Q; inline void work() { REP(i, 1, m) if (o[i].type == 2) { int x(o[i].a), y(o[i].b), l(lca(x, y)); if (st[x] &gt; st[y]) swap(x, y); if (l ^ x &amp;&amp; l ^ y) q[++Q] = query(ed[x], st[y], i, l); else q[++Q] = query(st[x], st[y], i); } const int block_siz = ceil(sqrt(2 * n)); REP(i, 1, n+n) belong[i] = i / block_siz; sort(q + 1, q + 1 + Q); REP(i, 1, Q) { while (l &lt; q[i].l) opt(back[l++]); while (l &gt; q[i].l) opt(back[--l]); while (r &lt; q[i].r) opt(back[++r]); while (r &gt; q[i].r) opt(back[r--]); if (q[i].spj) opt(q[i].spj); ans[q[i].id] = S2; if (q[i].spj) opt(q[i].spj); } }}int ade02[maxn], cur;bool inside[maxn];inline void timego(){ int x = ade02[++T]; inside[dfn[x]] = 1; if (l &lt;= dfn[x] &amp;&amp; dfn[x] &lt;= r) add(val[x]);}inline void timeback(){ int x = ade02[T--]; inside[dfn[x]] = 0; if (l &lt;= dfn[x] &amp;&amp; dfn[x] &lt;= r) del(val[x]);}inline void Add(int x) {if (inside[x]) add(ww[x]);}inline void Del(int x) {if (inside[x]) del(ww[x]);}inline void output(){ REP(i,1,100000)if(cnt[i])printf(\"%d \",i);putchar(10); printf(\"%d %lld %lld %lf\\n\", N, sigma, sigma2, S2);}namespace subtree{ int Q; void work() { inside[1] = 1; REP(i, 1, m) if (o[i].type == 1) ade02[++cur] = o[i].a; else if (o[i].type == 3) q[++Q] = query(dfn[o[i].a], dfn[o[i].a] + siz[o[i].a] - 1, i, 0, cur); if (!Q) return; const int block_siz = ceil(pow(1. * n * Q, 1. / 3)); REP(i, 1, n) belong[i] = i / block_siz; sort(q + 1, q + 1 + Q); sigma = sigma2 = N = l = r = 0; memset(cnt, 0, sizeof(cnt)); REP(i, 1, Q) { while (T &lt; q[i].t) timego(); while (T &gt; q[i].t) timeback(); while (l &lt; q[i].l) Del(l++); while (l &gt; q[i].l) Add(--l); while (r &lt; q[i].r) Add(++r); while (r &gt; q[i].r) Del(r--); ans[q[i].id] = S2; } }}signed main(){#ifdef CraZYali freopen(\"A.in\", \"r\", stdin); freopen(\"A.out\", \"w\", stdout);#endif cin &gt;&gt; m &gt;&gt; val[1]; REP(i, 1, m) { int type(read&lt;int&gt;()), a(read&lt;int&gt;()); if (type == 1) { ++n; o[i] = opt{type, a}; val[a] = read&lt;int&gt;(); add(fa[a] = read&lt;int&gt;(), a); } else if (type == 2) o[i] = opt{type, a, read&lt;int&gt;()}; else o[i] = opt{type, a}; } dfs1(1);dfs_clock = 0; dfs2(1, 1); path::work(); subtree::work(); REP(i, 1, m) if (o[i].type &gt; 1) printf(\"%.10lf\\n\", ans[i]); return 0;}","link":"/2019/08/17/胡闹-方差/"},{"title":"ARC 093 F","text":"传送门 题目大意有$2^{n\\le16}$名选手，编号为$1$至$2^n$。现在这$2^n$名选手将进行$n$轮淘汰赛，决出胜者。 若$x&lt;y$，则$x$能够战胜$y$。但有$m\\le16$个例外，$1$号选手会输给这$m$个选手。 问有多少种选手的排列方式使得$1$号选手取得胜利。 解析假设选手的排列是$p$，我们考虑$1$会和哪些选手打。 显然，他会先和$p_2$打，然后和$min{p_3,p_4}$打，然后和$min{p_5,p_6,p_7,p_8}$打，也就是会和$S_{k\\in[1,n]}={p_{2^{k-1}+1},…,p_{2^k}}$打。 那么显然方案数等于上述$n$个集合中每个集合的最小值都不是给定的$m$个人的方案数。 考虑容斥。钦定哪些块的最小值一定是给定的$m$个人，那么就可以状压一下。设方案数为$f(S)$，那么答案就是$\\sum (-1)^{|S|}f(S)$。 怎么求$f(S)$？这个就可以状压dp一下了。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#define REP(i, s, e) for (int i = s; i &lt;= e; i++)#define DREP(i, s, e) for (int i = s; i &gt;= e; i--)#define DEBUG fprintf(stderr, \"Passing [%s] in Line %d\\n\", __FUNCTION__, __LINE__)#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;const int MOD = 1e9 + 7, maxn = 20, maxN = 1 &lt;&lt; maxn;int bin[maxn], fac[maxN], inv[maxN], Inv[maxN];inline int C(int n, int m) {return n &lt; m ? 0 : 1ll * fac[n] * Inv[m] % MOD * Inv[n-m] % MOD;}int n, m;long long ans;int a[maxn], dp[maxn][maxN], cnt[maxN];int power_pow(long long base, int b){ long long ans(1); while(b) { if (b &amp; 1) (ans *= base) %= MOD; (base *= base) %= MOD; b &gt;&gt;= 1; } return (ans + MOD) % MOD;}signed main(){#ifdef CraZYali freopen(\"F.in\", \"r\", stdin); freopen(\"F.out\", \"w\", stdout);#endif cin &gt;&gt; n &gt;&gt; m; cnt[0] = fac[0] = bin[0] = Inv[0] = inv[0] = inv[1] = 1; REP(i, 1, n) bin[i] = bin[i-1]&lt;&lt;1; REP(i, 1, bin[n]) fac[i] = 1ll * fac[i-1] * i%MOD; Inv[bin[n]] = power_pow(fac[bin[n]], MOD - 2); DREP(i, bin[n]-1, 1) Inv[i] = 1ll * Inv[i+1] * (i+1) % MOD; REP(i, 1, bin[n]) inv[i] = 1ll * Inv[i] * fac[i-1] % MOD; REP(i, 1, bin[n]) cnt[i] = (i&amp;1) ? MOD - cnt[i&gt;&gt;1]:cnt[i&gt;&gt;1]; REP(i, 1, m) scanf(\"%d\", a + i); sort(a + 1, a + 1 + m); dp[m+1][0] = 1; DREP(i, m, 1) REP(S, 0, bin[n]-1) if(dp[i+1][S]) { (dp[i][S] += dp[i+1][S]) %= MOD; int p = bin[n] - S - 1; REP(j, 0, n) if(!(S &amp; (1&lt;&lt;j))) (dp[i][S | (1&lt;&lt;j)] += 1ll * C(p - a[i] + 1, (1&lt;&lt;j) - 1) * dp[i+1][S] % MOD * fac[1&lt;&lt;j] % MOD) %= MOD; } REP(i, 0, bin[n]-1) (ans += 1ll * dp[1][i] * fac[bin[n]-1-i] % MOD * cnt[i] % MOD) % MOD; printf(\"%lld\\n\", (1ll * ans * bin[n] % MOD + MOD) % MOD); return 0;}","link":"/2019/08/13/ARC-093-F/"},{"title":"BZOJ5336 [TJOI2018 party]","text":"传送门 题目大意给你一个长度为$n\\le1000$的字符串S，对于$i\\in[0,k\\le16]$你需要求出符合以下条件的字符串的总个数： 长度为$n$ 只由n，o，i三个字符组成 不包含子串noi 与$S$的最长公共子序列长度为$i$ 解析这个题就比较神仙了。 一开始没看到数据范围，后来猛然醒悟。 这个东西大概就是一个dp套dp的技巧。d d p 首先考虑一下不包含noi子串的问题，这个东西好像比较好解决，直接加一维完事。 然后$k\\le16$，那么一看就是要我们枚举暴力枚举LCS能不能转移的亚子。我们只要再加一维这个东西就好了。 好暴力啊。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#define REP(i, s, e) for (int i = s; i &lt;= e; i++)#define DREP(i, s, e) for (int i = s; i &gt;= e; i--)#define DEBUG fprintf(stderr, \"Passing [%s] in Line %d\\n\", __FUNCTION__, __MOD__)#define chkmax(a, b) a = max(a, b)#define chkmin(a, b) a = min(a, b)#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int maxn = 1000 + 10, MOD = 1e9 + 7, K = 15, maxk = K + 5, maxK = 1 &lt;&lt; K;int n, k, ans[maxk];char s[maxk], ban[]{\"NOI\"};int f[2][maxK][3], transpos[maxK][3], cnt[maxK];int dp[maxk], temp[maxk];inline int Get(int S, int c){ int ret(0); REP(i, 1, k) { dp[i] = dp[i-1] + !!(S &amp; (1&lt;&lt;i-1)); temp[i] = ban[c] == s[i] ? dp[i-1] + 1 : max(dp[i], temp[i-1]); ret |= temp[i] - temp[i-1] &lt;&lt; i-1; }#ifdef CraZYali cout &lt;&lt; ret &lt;&lt; endl;#endif return ret;}int main(){#ifdef CraZYali freopen(\"5336.in\", \"r\", stdin); freopen(\"5336.out\", \"w\", stdout);#endif cin &gt;&gt; n &gt;&gt; k; scanf(\"%s\", s + 1); const int lim = 1 &lt;&lt; k; REP(i, 0, lim - 1) REP(c, 0, 2) transpos[i][c] = Get(i, c); REP(i, 0, lim - 1) cnt[i] = cnt[i&gt;&gt;1] + (i &amp; 1); f[0][0][0] = 1; int cur = 0; REP(i, 1, n) { cur ^= 1; memset(f[cur], 0, sizeof(f[cur])); REP(j, 0, lim - 1) REP(p, 0, 2) REP(c, 0, 2) { int np(c ? c == 1 ? p == 1 ? 2 : 0 : p == 2 ? 3 : 0 : 1); (f[cur][transpos[j][c]][np] += (!!(np ^ 3)) * f[cur ^ 1][j][p]) %= MOD; } } REP(i, 0, lim - 1) REP(c, 0, 2) (ans[cnt[i]] += f[cur][i][c]) %= MOD; REP(i, 0, k) printf(\"%d\\n\", (ans[i] + MOD) % MOD); return 0;}//基本上是copy的","link":"/2019/08/12/BZOJ5336-TJOI2018-party/"},{"title":"UOJ131 [NOI2015 品酒大会]","text":"传送门 题目大意给定一个长度为$n\\le3\\times10^5$的字符串$S$，每个位置有一个权值$a_i$。 定义$S$的两个位置$p,q$是$r$相似的当且仅当$S[p:p+r-1]=S[q:q+r-q]$并且$p\\not=q$，任意两个位置都是$0$相似的。 求$0…n-1$相似的位置共有多少对，并且它们组成的$a_p\\times a_q$最大是多少。 我的语文是真的不行。 解析有人竟然说这题比优秀的拆分好写？ 可以先把$height$数组求出来。 然后我们考虑一下枚举位置$i$，然后求出一个包含$i$的极大区间，这个区间的$height$的最小值为$height_i$。 那么现在这个区间对应的字符串都是$height_i$相似的，第一问就搞定了。 第二问随便$ST$表一下。 上面全是口胡，WO YE BU HUI。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204#define DREP(i, s, e) for(int i = s; i &gt;= e ;i--)#define REP(i, s, e) for(int i = s; i &lt;= e ;i++)#define DEBUG fprintf(stderr, \"Passing [%s] in Line %d\\n\", __FUNCTION__, __LINE__)#define chkmax(a, b) a = max(a, b)#define chkmin(a, b) a = min(a, b)#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;using namespace std;const int maxn = 3e5 + 10, maxN = maxn &lt;&lt; 1, inf = 1e9+1;const int siz = 26;int ch[maxN][siz], Max[maxN], id[maxN], nex[maxN];int start, last, cur;inline int newnode(int _Max = 0, int _id = 0){ ++cur; Max[cur] = _Max; id[cur] = _id; return cur;}inline void init() {start = last = newnode();}inline void extend(int c, int _id){ int u(newnode(Max[last] + 1, _id)), v(last); for (; v &amp;&amp; !ch[v][c]; v = nex[v]) ch[v][c] = u; if (!v) nex[u] = start; else if (Max[v] + 1 == Max[ch[v][c]]) nex[u] = ch[v][c]; else { int New(newnode(Max[v] + 1)), Old(ch[v][c]); copy(ch[Old], ch[Old] + siz, ch[New]); nex[New] = nex[Old]; nex[u] = nex[Old] = New; for (; v &amp;&amp; ch[v][c] == Old; v = nex[v]) ch[v][c] = New; } last = u;}bool vis[maxN];struct state{int x, y, z;}q[maxN];int top;int rk[maxN], dfn, sa[maxn], h[maxn], height[maxn], c[siz];int n, a[maxn];char s[maxn];int bg[maxN], ne[maxN], to[maxN], e;inline void add(int x, int y){ e++; to[e] = y; ne[e] = bg[x]; bg[x] = e;}void dfs(int x){ if (id[x]) sa[++dfn] = id[x]; for (int i = bg[x]; i ; i = ne[i]) dfs(to[i]);}int lg[maxn];struct st_Min{ int Min[maxn][20]; void init(int a[], int n) { REP(i, 1, n) Min[i][0] = a[i]; REP(j, 1, 19) REP(i, 0, n) if (i + (1 &lt;&lt; j) -1 &lt;= n) Min[i][j] = min(Min[i][j-1], Min[i + (1 &lt;&lt; j - 1)][j-1]); } int query(int l, int r) { int k = lg[r-l+1]; return min(Min[l][k], Min[r - (1&lt;&lt;k) + 1][k]); }}table;struct st_Max{ int Maxa[maxn][20], Maxb[maxn][20]; st_Max() { memset(Maxa, -63, sizeof(Maxa)); memset(Maxb, -63, sizeof(Maxb)); } void init(int a[], int n) { REP(i, 1, n) Maxa[i][0] = a[sa[i]] &gt;= 0 ? a[sa[i]] : -inf; REP(i, 1, n) Maxb[i][0] = a[sa[i]] &lt; 0 ? -a[sa[i]] : -inf; REP(j, 1, 19) REP(i, 0, n) if (i + (1 &lt;&lt; j) -1 &lt;= n) { Maxa[i][j] = max(Maxa[i][j-1], Maxa[i + (1 &lt;&lt; j - 1)][j-1]); Maxb[i][j] = max(Maxb[i][j-1], Maxb[i + (1 &lt;&lt; j - 1)][j-1]); } else break; } int querya(int l, int r) { int k = lg[r-l+1]; return max(Maxa[l][k], Maxa[r - (1&lt;&lt;k) + 1][k]); } int queryb(int l, int r) { int k = lg[r-l+1]; return max(Maxb[l][k], Maxb[r - (1&lt;&lt;k) + 1][k]); }}Table;int query(int l, int r){ if (l &gt; r) swap(l, r); return table.query(l+1, r);}int Left[maxn], Right[maxn];long long ans[2][maxn];int main(){#ifdef CraZYali freopen(\"131.in\", \"r\", stdin); freopen(\"131.out\", \"w\", stdout);#endif init(); scanf(\"%d\\n%s\\n\", &amp;n, s + 1); REP(i, 2, n) lg[i] = lg[i &gt;&gt; 1] + 1; REP(i, 1, n) scanf(\"%d\", a + i); DREP(i, n, 1) extend(s[i] - 'a', i); vis[1] = 1; REP(i, 2, cur) if (!vis[i] &amp;&amp; id[i]) for (int j = i, pos = n; !vis[j]; vis[j] = 1, j = nex[j], pos--) { pos -= Max[j] - Max[nex[j]] - 1; q[++top] = state{nex[j], j, s[pos] - 'a'}; } REP(i, 1, top) c[q[i].z]++; REP(i, 1, siz-1) c[i] += c[i-1]; DREP(i, top, 1) rk[c[q[i].z]--] = i; DREP(i, top, 1) add(q[rk[i]].x, q[rk[i]].y); dfs(start); REP(i, 1, n) rk[sa[i]] = i; REP(i, 1, n) { h[i] = max(0, h[i-1] - 1); int maxlen = min(n - i + 1, n - sa[rk[i]-1] + 1); while (h[i] &lt; maxlen &amp;&amp; s[i+h[i]] == s[sa[rk[i]-1]+h[i]]) h[i]++; } REP(i, 1, n) height[rk[i]] = h[i];#ifdef CraZYali REP(i, 1, n) fprintf(stderr,\"%d%c\", sa[i], i == n ? '\\n' : ' '); REP(i, 1, n) fprintf(stderr,\"%d%c\", rk[i], i == n ? '\\n' : ' '); REP(i, 1, n) fprintf(stderr,\"%d%c\", height[i], i == n ? '\\n' : ' ');#endif table.init(height, n); Table.init(a, n); REP(i, 1, n) { int pos; for (pos = i-1;pos;pos = Left[pos]-1) if (height[i] &gt; height[pos]) break; Left[i] = pos + 1; } DREP(i, n, 1) { int pos; for (pos = i+1;pos;pos = Right[pos]+1) if (height[i] &gt;= height[pos]) break; Right[i] = pos - 1; }#ifdef CraZYali REP(i, 1, n) fprintf(stderr,\"%d %d %d\\n\", height[i], Left[i],Right[i]);#endif REP(i, 1, n) ans[0][height[i]] += 1ll*(Right[i]-i+1)*(i-Left[i]+1); memset(ans[1], -63, sizeof(ans[1])); REP(i, 1, n) { int Max1(Table.querya(i, Right[i])); int Max2(Table.querya(Left[i]-1, i-1)); int negaMax1(Table.queryb(i, Right[i])); int negaMax2(Table.queryb(Left[i]-1, i-1));#ifdef CraZYali printf(\"%d %d %d %d %d %d %d\\n\",height[i],Left[i],Right[i],Max1,Max2,negaMax1,negaMax2);#endif if (Max1 &gt; -inf &amp;&amp; Max2 &gt; -inf) chkmax(ans[1][height[i]], 1ll * Max1 * Max2); if (negaMax1 &gt; -inf &amp;&amp; negaMax2 &gt; -inf) chkmax(ans[1][height[i]], 1ll * negaMax1 * negaMax2); if (negaMax1 &gt; -inf &amp;&amp; Max2 &gt; -inf) chkmax(ans[1][height[i]], -1ll * negaMax1 * Max2); if (Max1 &gt; -inf &amp;&amp; negaMax2 &gt; -inf) chkmax(ans[1][height[i]], -1ll * Max1 * negaMax2); } DREP(i, n-1, 0) { ans[0][i] += ans[0][i+1]; if (ans[0][i+1]) chkmax(ans[1][i], ans[1][i+1]); } ans[0][0] -= n; REP(i, 0, n-1) printf(\"%lld %lld\\n\", ans[0][i], ans[0][i]==0?0:ans[1][i]); return 0;}","link":"/2019/08/11/UOJ131-NOI2015-品酒大会/"},{"title":"LOJ2189 [SHOI2014 神奇化合物]","text":"我又写了个假解。 传送门 题目大意给你一个$n\\le5000$个点，$m\\le200000$的无向图。 $q\\le10000$次操作，要求兹磁加边删边，还要维护当前联通块数量。 解析注意到修改远远小于边数。 那么我们就可以先预处理出一些边，然后这些边永远也不会动，就随便并查集一下缩个点。 然后剩下的操作大概就可以暴力维护边修改时联通块的修改情况，这个应该是$\\mathcal O(玄学)$的。综合起来就是$\\mathcal O(能过)$的。 然后要注意一下缩点之后自环是允许的，不能只算一次。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#define DREP(i, s, e) for(int i = s; i &gt;= e ;i--)#define REP(i, s, e) for(int i = s; i &lt;= e ;i++)#define DEBUG fprintf(stderr, \"Passing [%s] in Line %d\\n\", __FUNCTION__, __LINE__)#define chkmax(a, b) a = max(a, b)#define chkmin(a, b) a = min(a, b)#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;bitset&gt;#include &lt;vector&gt;using namespace std;const int maxn = 5000 + 10, maxm = 200000 + 10, maxq = 100000 + 10;template &lt;typename T&gt; inline T read(){ T ans(0), p(1); char c = getchar(); while (!isdigit(c)) { if (c == '-') p = -1; c = getchar(); } while (isdigit(c)) { ans = ans * 10 + c - 48; c = getchar(); } return ans * p;}int n, m, q, N;int x[maxm + maxq], y[maxm + maxq], z[maxm + maxq];int fa[maxn];int find(int x) {return fa[x] == x ? x : fa[x] = find(fa[x]);}inline void uni(int x, int y) {fa[find(x)] = find(y);}int id[maxn], cur;int belong[maxn], ans, dfn;int have[maxn][maxn], G[maxn][maxn];int bg[maxn], ne[maxm + maxq &lt;&lt; 1], to[maxm + maxq &lt;&lt; 1], e;void dfs(int x, int y){ belong[x] = y; for (int i = bg[x]; i ; i = ne[i]) if (G[x][to[i]]&amp;&amp;belong[to[i]]!=y)dfs(to[i], y);}void Add(int x, int y){ e++; to[e] = y; ne[e] = bg[x]; bg[x] = e;}void add(int x, int y){ if (belong[x] ^ belong[y]) { --ans; dfs(y, belong[x]); } G[x][y]++, G[y][x]++; if(!have[x][y]) Add(x, y), Add(y, x), have[x][y] = have[y][x]=1;}void del(int x, int y){ G[x][y]--, G[y][x]--; dfs(x, ++dfn); if (belong[x] ^ belong[y]) ans++;}int main(){#ifdef CraZYali freopen(\"3562.in\", \"r\", stdin); freopen(\"3562.out\", \"w\", stdout);#endif cin &gt;&gt; n &gt;&gt; m ; REP(i, 1, n) fa[i] = i; REP(i, 1, m) { x[i] = read&lt;int&gt;(), y[i] = read&lt;int&gt;(); G[x[i]][y[i]] ++, G[y[i]][x[i]]++; } cin &gt;&gt; q; REP(i, m + 1, m + q) { char c = getchar(); while (!isalpha(c)) c = getchar(); if (c == 'Q') z[i] = 1; else { x[i] = read&lt;int&gt;();y[i] = read&lt;int&gt;(); if (c == 'D') z[i] = 2, G[x[i]][y[i]] = G[y[i]][x[i]] = 0; else z[i] = 3; } } REP(i, 1, m) if (G[x[i]][y[i]]) uni(x[i], y[i]); REP(i, 1, n) if (i == find(i)) id[i] = ++cur; REP(i, 1, m + q) if (x[i]+y[i]) { x[i] = id[find(x[i])]; y[i] = id[find(y[i])]; } n = dfn = ans = cur; REP(i, 1, cur) belong[i] = i; REP(i, 1, n) REP(j, 1, n) G[i][j] = 0; REP(i, 1, m) if (x[i] ^ y[i]) add(x[i], y[i]); REP(i, m + 1, m + q) if (z[i] == 1) printf(\"%d\\n\", ans); else if (x[i] ^ y[i]) if(z[i] == 2) del(x[i], y[i]); else add(x[i], y[i]); return 0;} 后记这个东西应该还有一个写法。 就是说我们可以以时间为轴，维护出每条边存在的时间区间。 那么这个东西我们就可以拿一个线段树来维护，把叶子节点存的就是操作。 然后我们就可以直接dfs每一棵线段树，进入某个节点的时候加上要加的边，走到时候删掉。 这个东西用一个按秩合并的并查集维护一下就可以了。 有时间把这个写一下。","link":"/2019/08/10/LOJ2189-SHOI2014-神奇化合物/"},{"title":"口胡 LOJ2059 [TJOI & HEOI2016 字符串]","text":"传送门 题目大意给定一个长度为$n\\le100000$的字符串S，$m\\le100000$次询问$S[a:b]$的所有子串和$S[c:d]$的所有字串中的最长的LCP的长度。 解析考虑二分答案$L$。 则问题变为有多少个起始位置在$[a, b − L + 1]$之间$i$，满足$L\\le LCP(S[i : n], S[c : n])$。 这个把后缀数组搞出来，然后和某个后缀的$LCP ≥ L$的范围是一段区间，可以$ST$表。 接下来的问题变为在后缀数组的某个区间$[l, r]$中，是否存在一个介于$[a, b − L + 1]$之间的数字。线段树合并就可以了。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#define REP(i, s, e) for (int i = s; i &lt;= e; i++)#define DREP(i, s, e) for (int i = s; i &gt;= e; i--)#define DEBUG fprintf(stderr, \"Passing [%s] in Line %d\\n\", __FUNCTION__, __LINE__)#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;const int maxn = 200000 + 10, maxN = maxn &lt;&lt; 1;int ls[maxn*50], rs[maxn*50], cur;#define mid (l + r &gt;&gt; 1)#define lson ls[p], l, mid#define rson rs[p], mid + 1, rvoid build(int &amp;p, int l, int r, int pos){ p = ++cur; if (l == r) return; else if (pos &lt;= mid) build(lson, pos); else build(rson, pos);}int merge(int a, int b){ if (!a || !b) return a + b; int now = ++cur; ls[now] = merge(ls[a], ls[b]); rs[now] = merge(rs[a], rs[b]); return now;}bool query(int p, int l, int r, int L, int R){ if (!p) return 0; if (L == l &amp;&amp; r == R) return 1; else { if (R &lt;= mid) return query(lson, L, R); if (L &gt; mid) return query(rson, L, R); return query(lson, L, mid) || query(rson, mid+1, R); }}int n, m;char str[maxN];int ch[maxN][26], ne[maxN][21], Max[maxN], sam_cur = 1, start = 1, last = 1;int rt[maxN], fin[maxN];inline int newnode(int _Max) {return Max[++sam_cur] = _Max, sam_cur;}inline void extend(int c, int id){ int v = last, u = newnode(Max[v] + 1); build(rt[u], 1, n, id); for (; v &amp;&amp; !ch[v][c]; v = ne[v][0]) ch[v][c] = u; if (!v) ne[u][0] = start; else if (Max[v] + 1 == Max[ch[v][c]]) ne[u][0] = ch[v][c]; else { int New = newnode(Max[v] + 1), Old = ch[v][c]; copy(ch[Old], ch[Old] + 26, ch[New]); ne[New][0] = ne[Old][0]; ne[u][0] = ne[Old][0] = New; for (; v &amp;&amp; ch[v][c] == Old;v = ne[v][0]) ch[v][c] = New; } fin[id] = last = u;}int bg[maxN], nex[maxN], to[maxN], e;inline void add(int x, int y){ e++; to[e] = y; nex[e] = bg[x]; bg[x] = e;}void dfs(int x){ for (int i = bg[x]; i ; i = nex[i]) { dfs(to[i]); rt[x] = merge(rt[x], rt[to[i]]); }}inline bool judge(int pos, int Mid, int a, int b){ DREP(i, 19, 0) if (Max[ne[pos][i]] &gt;= Mid) pos = ne[pos][i]; return query(rt[pos], 1, n, a+Mid-1, b);}int main(){#ifdef CraZYali freopen(\"2059.in\", \"r\", stdin); freopen(\"2059.out\", \"w\", stdout);#endif scanf(\"%d%d\\n%s\", &amp;n, &amp;m, str + 1); reverse(str+1, str+n+1); REP(i, 1, n) extend(str[i]-'a', i); REP(j, 1, 19) REP(i, 1, sam_cur) ne[i][j] = ne[ne[i][j-1]][j-1]; REP(i, 2, sam_cur) add(ne[i][0], i); dfs(start); while (m--) { int a, b, c, d; scanf(\"%d%d%d%d\", &amp;b, &amp;a, &amp;d, &amp;c); a = n-a+1, b = n-b+1, c = n-c+1, d = n-d+1; int pos = fin[d]; int l(1), r(min(b-a+1, d-c+1)); while (l &lt;= r) if (judge(pos, mid, a, b)) l = mid + 1; else r = mid - 1; printf(\"%d\\n\", l-1); } return 0;}","link":"/2019/08/07/口胡-LOJ2059-TJOI-HEOI2016-字符串/"},{"title":"BZOJ1951 [SDOI2010 古代猪文]","text":"传送门 题目大意给定$G,MOD=999911659$，求：$$G^{\\sum_{k|n}(^N_k)}$$ 解析根据费马小定理，$a^{p-1}\\equiv 1(\\bmod p)$，那么我们有$a^x\\equiv a^{x \\bmod (p-1)}(\\bmod p)$对吧。 主要是因为$MOD-1$不是一个质数，但是它可以分解质因数成$4$个质数。 那就随便$lucas$一下然后$crt$合并就可以了。 WO YE BU HUI","link":"/2019/08/07/BZOJ1951-SDOI2010-古代猪文/"},{"title":"Luogu 1117 [NOI2016 优秀的拆分]","text":"传送门 我大概率是一个错解 题目大意给定一个长度为$n\\le30000$的字符串$S$。 如果A和B都是非空字符串，那么AABB就是一个优秀的拆分。A和B可以相同。 求$S$的所有子串中有多少个优秀的拆分，不同位置出现的子串不算相同子串。 解析我们考虑怎么把AA和BB分开求。 那么我们只要求出每个以每个点为终点的AA串个数和以每个点为起点的AA串个数，然后相邻的点乘一下求和就可以了。 下面开始就是技巧了。 考虑枚举A串的长度$L$，然后每$L$个点设置关键点。 也就是说，设置的关键点为$L,2L,3L….$。 我们发现，每一个AA串长度为$2L$，那么它一定会正好包含两个相邻的关键点。 那么我们枚举这两个关键点，考虑求出正好包含这两个关键点的串的AA串的贡献。 设我们当前枚举的左边的关键点为$pos_1$，右边的关键点为$pos_2$这个AA串左端点最左可以到$head$，最右可以到$tail$。 那么在上图（是真的丑）中，AA串整体只能在灰色区域内滑动。 容易发现，$head$一定是在合法位置内，最左边的满足$S_{[head,pos_1]}=S_{[pos_2-(pos_1-head),pos_2]}$的点。 同理，$tail$一定是在合法位置内，最右边的满足$S_{[pos_2,tail]}=S_{[pos_1-(tail-pos_2),pos_1]}$的点。 这个东西二分一下就好了，有贡献的区间就是$[head+2L-1,tail]$和$[head,tail-2L+1]$，分别对应向前和向后的AA串个数。 然后这个对于不同的$L$有多次贡献，差分即可。 外层枚举$L$的复杂度是$\\sum_{L=1}^{n}\\frac nL=\\mathcal{O}(n\\ log\\ n)$的，加上二分，总复杂度就是$\\mathcal O(n\\ log^2\\ n)$的。 注意一下边界条件就可以了。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#define DREP(i, s, e) for(int i = s; i &gt;= e ;i--)#define REP(i, s, e) for(int i = s; i &lt;= e ;i++)#define DEBUG fprintf(stderr, \"Passing [%s] in Line %d\\n\", __FUNCTION__, __LINE__)#define chkmax(a, b) a = max(a, b)#define chkmin(a, b) a = min(a, b)#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;const int maxn = 30000 + 10;template &lt;typename T&gt; inline T read(){ T ans(0), p(1); char c = getchar(); while (!isdigit(c)) { if (c == '-') p = -1; c = getchar(); } while (isdigit(c)) { ans = ans * 10 + c - 48; c = getchar(); } return ans * p;}int n;char s[maxn];template &lt;long long base, long long MOD&gt;struct Hash_Table{ long long bin[maxn], Hash[maxn]; Hash_Table() { bin[0] = 1; REP(i, 1, maxn-10) bin[i] = bin[i-1] * base % MOD; } void calc() { REP(i, 1, n) Hash[i] = (Hash[i-1] * base % MOD + s[i] - 'a') % MOD; } long long get_val(int l, int r) { long long res = Hash[r] - Hash[l-1] * bin[r - l + 1] % MOD; return (res % MOD + MOD) % MOD; }};Hash_Table &lt;23, (long long)1e9 + 7&gt; H1;Hash_Table &lt;31, (long long)1e9 + 9&gt; H2;bool same(int l1, int r1, int l2, int r2){ return (r1 - l1 + 1 == r2 - l2 + 1) &amp;&amp; H1.get_val(l1, r1) == H1.get_val(l2, r2) &amp;&amp; H2.get_val(l1, r1) == H2.get_val(l2, r2);}long long pre[maxn], nex[maxn], ans;void add(long long s[], int Start, int End, int val){#ifdef CraZYali fprintf(stderr, \"%s: %d\\t%d\\t%d\\n\", s==pre?\"pre\":\"nex\",Start, End, val);#endif s[Start] += val; s[End+1] += -val;}void calc(){ REP(i, 1, n) pre[i] += pre[i-1]; REP(i, 1, n) nex[i] += nex[i-1]; ans = 0; REP(i, 1, n-1) ans += pre[i] * nex[i+1];}int main(){#ifdef CraZYali freopen(\"1117.in\", \"r\", stdin); freopen(\"1117.out\", \"w\", stdout); freopen(\"1117.err\", \"w\", stderr);#endif int T = read&lt;int&gt;(); while (T--) { scanf(\"%s\", s + 1); n = strlen(s + 1); H1.calc();H2.calc(); REP(i, 1, n) pre[i] = nex[i] = 0; REP(L, 1, n) for (int i = 2; i * L &lt;= n; i++) if (s[(i-1) * L] == s[i * L]) { int pos1 = (i-1) * L, pos2 = i * L, l, r, head(pos1), tail(pos2), Start, End; l = max(1, pos1 - L + 1), r = pos1; while (l &lt;= r) { int mid = l + r &gt;&gt; 1; if (same(mid, pos1, pos2 - (pos1 - mid), pos2)) { head = mid; r = mid - 1; } else l = mid + 1; } l = pos2, r = min(n, pos2 + L - 1); while (l &lt;= r) { int mid = l + r &gt;&gt; 1; if (same(pos2, mid, pos1, pos1 + (mid - pos2))) { tail = mid; l = mid + 1; } else r = mid - 1; }#ifdef CraZYali fprintf(stderr, \"%d %d %d %d %d\\n\", L, pos1, pos2, head, tail);#endif Start = head, End = tail - L * 2 + 1; if (Start &lt;= End) add(nex, Start, End, 1); Start = head + L * 2 - 1, End = tail; if (Start &lt;= End) add(pre, Start, End, 1); } calc();#ifdef CraZYali REP(i, 1, n) fprintf(stderr, \"%lld%c\", pre[i], i == n ? '\\n' : ' '); REP(i, 1, n) fprintf(stderr, \"%lld%c\", nex[i], i == n ? '\\n' : ' '); int pos1 = 3, pos2 = 6, mid = 8; cerr &lt;&lt; \"judge: \" &lt;&lt; same(pos2, mid, pos1 - (mid - pos2), pos1)&lt;&lt;endl; fputs(\"==========\\n\", stderr);#endif printf(\"%lld\\n\", ans); } return 0;} Notice为什么我说是个假解呢。 因为二分那个步骤完全可以$SA+ST$来$\\mathcal O(1)$解决，我有一个$log$。 那这个复杂度其实是不太对的，但是数据小啊QAQ。 到时候在补吧。","link":"/2019/08/03/Luogu-1117-NOI2016-优秀的拆分/"},{"title":"模板 多项式求逆","text":"传送门 题目大意给定一个多项式$F(x)$，请求出一个多项式$G(x)$，满足$F(x)\\times G(x) \\equiv 1 (\\bmod x^n)$。系数对$998244353$取模。 解析转载自huhaoo的博客 国际惯例，先把多项式长度弄成$2^k$。 如果我们求出了：$$f’^{-1}f\\equiv 1(\\bmod x^\\frac k2)$$那么可以得到：$$\\begin{align*}f^{-1}f&amp;\\equiv1(\\bmod x^\\frac k2)\\\\f(f^{-1}-f’^{-1})&amp;\\equiv0(\\bmod x^\\frac k2)\\\\(f^{-1}-f’^{-1})^2&amp;\\equiv0(\\bmod x^k)\\\\f^{-2}-2f^{-1}f’^{-1}-f’^{-2}&amp;\\equiv0(\\bmod x^k)\\\\f^{-1}-2f’{-1}-ff’^{-2}&amp;\\equiv0(\\bmod x^k)\\\\f^{-1}&amp;\\equiv f’^{-1}(2-ff’^{-1})(\\bmod x^k)\\end{align*}$$ 边界给整数求逆即可。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#define DREP(i, s, e) for(int i = s; i &gt;= e ;i--)#define REP(i, s, e) for(int i = s; i &lt;= e ;i++)#define DEBUG fprintf(stderr, \"Passing [%s] in Line %d\\n\", __FUNCTION__, __LINE__)#define chkmax(a, b) a = max(a, b)#define chkmin(a, b) a = min(a, b)#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;const int maxn = 1e5 + 10, maxlen = 1 &lt;&lt; 18, MOD = 998244353;template &lt;typename T&gt; inline T read(){ T ans(0), p(1); char c = getchar(); while (!isdigit(c)) { if (c == '-') p = -1; c = getchar(); } while (isdigit(c)) { ans = ans * 10 + c - 48; c = getchar(); } return ans * p;}int power_pow(int base, int b){ int ans(1); while (b) { if (b&amp;1) ans = 1ll * ans * base % MOD; base = 1ll * base * base % MOD; b &gt;&gt;= 1; } return ans;}#define inv(x) power_pow(x, MOD - 2)int n, f[maxlen], R[maxlen], len;void NTT(int a[], int flag){ REP(i, 1, len-1) if (i &lt; R[i]) swap(a[i], a[R[i]]); for (int i = 1; i &lt; len; i &lt;&lt;= 1) { int wn = power_pow(3, (MOD - 1) / (i &lt;&lt; 1)); if (flag &lt; 0) wn = inv(wn); for (int k = 0; k &lt; len; k += i &lt;&lt; 1) { int w = 1; for (int l = 0; l &lt; i;l++, w = 1ll * w * wn % MOD) { int x(a[k + l]), y(1ll * w * a[k + l + i] % MOD); a[k + l] = (x + y) % MOD; a[k + l + i] = (x - y) % MOD; } } } if (flag &lt; 0) { int invN = inv(len); REP(i, 0, len - 1) a[i] = 1ll * a[i] * invN % MOD; }}int Inv[maxlen], temp[maxlen];void solve(int lim, int a[], int b[]){ if (!lim) return b[0] = inv(a[0]), void(); solve(lim &gt;&gt; 1, a, b); len = lim + lim; REP(i, 1, len - 1) R[i] = (R[i &gt;&gt; 1] &gt;&gt; 1) | (i &amp; 1 ? lim : 0); copy(a, a + lim, temp); NTT(temp, 1);NTT(b, 1); REP(i, 0, len - 1) b[i] = 1ll * (2ll - 1ll * temp[i] * b[i] % MOD) % MOD * b[i] % MOD; NTT(b, -1); REP(i, lim, len - 1) b[i] = 0;}int main(){#ifdef CraZYali freopen(\"4238.in\", \"r\", stdin); freopen(\"4238.out\", \"w\", stdout);#endif cin &gt;&gt; n; REP(i, 0, n - 1) f[i] = read&lt;int&gt;(); solve(1 &lt;&lt; 17, f, Inv); REP(i, 0, n - 1) printf(\"%d%c\", (Inv[i] + MOD) % MOD, i == n - 1 ? '\\n' : ' '); return 0;}","link":"/2019/08/01/模板-多项式求逆/"},{"title":"BZOJ 3513 [MUTC2013 idiots]","text":"传送门 题目大意有$n\\le10^5$根木棍，每根木棍的长度为$a_i\\le10^5$。 求随便选$3$根木棍能组成三角形的概率。 解析直接搞好像不太行。 考虑求出不能组成的概率，那就是两边之和小于第三边。 那我们就记F[x]表示$x$的个数，然后F[x]的平方就是两边长度之和为$x$的个数对吧。 但是这样我们就把选两个自己的方案算进去了，那我们就减一下。 然后直接统计一下t[x]表示长度不小于$x$的个数，然后直接统计一下就好了。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#define REP(i, s, e) for (int i = s; i &lt;= e; i++)#define DREP(i, s, e) for (int i = s; i &gt;= e; i--)#define DEBUG fprintf(stderr, \"Passing [%s] in Line %d\\n\", __FUNCTION__, __LINE__)#define chkmax(a, b) a = max(a, (b))#define chkmin(a, b) a = min(a, (b))#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;using namespace std;const int l = 18, len = 1 &lt;&lt; l, maxn = 1e5 + 10;const double pi = acos(-1);template &lt;typename T&gt; inline T read(){ T ans(0), flag(1); char c(getchar()); while (!isdigit(c)) { if (c == '-') flag = -1; c = getchar(); } while (isdigit(c)) { ans = ans * 10 + c - 48; c = getchar(); } return ans * flag;}inline void file(string s){ freopen((s + \".in\").c_str(), \"r\", stdin); freopen((s + \".out\").c_str(), \"w\", stdout);}struct Complex{ double x, y; inline Complex(double _x = 0, double _y = 0) : x(_x), y(_y) {} inline Complex operator + (Complex B) {return Complex(x + B.x, y + B.y);} inline Complex operator - (Complex B) {return Complex(x - B.x, y - B.y);} inline Complex operator * (Complex B) {return Complex(x * B.x - y * B.y, x * B.y + B.x * y);} inline Complex operator *=(Complex B) {return *this = *this * B;} inline Complex operator / (double v) {return Complex(x / v, y / v);} inline Complex operator /=(double v) {return *this = *this / v;} //(x + yi) / (B.x + B.yi) //(x + yi) * (B.x - B.yi) / (B.x^2 + B.y^2) inline Complex operator / (Complex B) {return Complex(x, y) * Complex(B.x, -B.y) / (B.x * B.x + B.y * B.y);}}F[len];int m, n, k, R[len];inline void FFT(Complex a[], int flag){ REP(i, 1, len-1) if (i &lt; R[i]) swap(a[i], a[R[i]]); for (int i(1); i &lt; len; i &lt;&lt;= 1) { Complex T(cos(pi / i), flag * sin(pi / i)); for (int k(0); k &lt; len; k += (i &lt;&lt; 1)) { Complex t(1); for (int l(0); l &lt; i;l++, t *= T) { Complex x(a[k + l]), y(t * a[k + l + i]); a[k + l] = x + y; a[k + l + i] = x - y; } } } if (flag == -1) REP(i, 0, len-1) a[i] /= len;}long long t[len], G[len];signed main(){#ifdef CraZYali file(\"3513\");#endif REP(i, 1, len - 1) R[i] = (R[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; l - 1); int T = read&lt;int&gt;(); while (T--) { REP(i, 0, len-1) F[i] = Complex(); memset(t, 0, sizeof(t)); memset(G, 0, sizeof(G)); n = read&lt;int&gt;(); REP(i, 1, n) { int x = read&lt;int&gt;(); t[x]++; F[x].x += 1; G[x &lt;&lt; 1]--; } FFT(F, 1); REP(i, 0, len - 1) F[i] *= F[i]; FFT(F, -1); DREP(i, 1e5, 1) t[i] += t[i+1]; REP(i, 0, len - 1) G[i] += (long long)(F[i].x + .5); long long ans = 0, tot = 1ll * n * (n-1) * (n-2) / 6; REP(i, 0, len - 1) ans += (G[i] &gt;&gt; 1) * t[i]; printf(\"%.7lf\\n\", 1. - ans * 1. / tot); } return 0;}","link":"/2019/07/30/BZOJ-3513-MUTC2013-idiots/"},{"title":"模板 后缀排序（有待完善）","text":"UOJ传送门 题目大意给出一个字符串（由大小字母和英文组成），把后缀排序，输出后缀数组和$height$数组。 解析我不会后缀数组啊。 但是我屯了一个SAM的板子，听说用这个东西可以做。 然后我就想，能不能把后缀树搞出来，有了后缀树我们就可以随便dfs一下就行了吧。 但是怎么构造呢？ SAM好像有两部分来着?一个是DAWG，一个是Parent树？ 还是想不到，那么： 我们可以考虑上网搜题解。 ——hh 题解告诉我们，反串的Parent树就是后缀树？ 那就这样吧。 然后有了SA数组之后，我们要求$height_i=LCP(S[SA_{i-1}:n],S[SA_i:n]$对吧。 考虑一个辅助数组：$$\\begin{align*}h_i&amp;=height_{rank_i}\\\\&amp;=LCP(S[SA_{rank_i-1}:n],S[SA_{rank_i}:n])\\\\&amp;=LCP(S[SA_{rank_i-1}:n],S[i:n])\\end{align*}$$然后我听说有一个结论，就是说$h_{i-1}-1\\le h_i$，具体我不太会证。 然后就可以用这个不太又没的单调性来求出$h_i$，进而求出$height$了。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#define DREP(i, s, e) for(int i = s; i &gt;= e ;i--)#define REP(i, s, e) for(int i = s; i &lt;= e ;i++)#define DEBUG fprintf(stderr, \"Passing [%s] in Line %d\\n\", __FUNCTION__, __LINE__)#define chkmax(a, b) a = max(a, b)#define chkmin(a, b) a = min(a, b)#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;const int maxn = 1e5 + 10, maxnode = maxn &lt;&lt; 1;const int siz = 26;int Max[maxnode], id[maxnode], ch[maxnode][siz], ne[maxnode], start, last, cur;int newnode(int _Max = 0, int _id = 0){ ++cur; id[cur] = _id; Max[cur] = _Max; return cur;}void init() {start = last = newnode();}int n;char s[maxn];void extend(int c, int _id){ int u = newnode(Max[last] + 1, _id), v = last; for (; v &amp;&amp; !ch[v][c]; v = ne[v]) ch[v][c] = u; if (!v) ne[u] = start; else if (Max[v] + 1 == Max[ch[v][c]]) ne[u] = ch[v][c]; else { int Old = ch[v][c], New = newnode(Max[v] + 1); copy(ch[Old], ch[Old] + siz, ch[New]); ne[New] = ne[Old]; ne[u] = ne[Old] = New; for (; v &amp;&amp; ch[v][c] == Old; v = ne[v]) ch[v][c] = New; } last = u;}bool vis[maxnode];struct state{int x, y, z;}q[maxnode];int top;int cnt[siz], rk[maxnode];int bg[maxnode], nex[maxnode], to[maxnode], e;void add(int x, int y){ e++; to[e] = y; nex[e] = bg[x]; bg[x] = e;}int sa[maxn], _rank[maxn], height[maxn], h[maxn], dfn;void dfs(int x){ if (id[x]) sa[++dfn] = id[x]; for (int i = bg[x]; i ;i = nex[i]) dfs(to[i]);}int main(){#ifdef CraZYali freopen(\"35.in\", \"r\", stdin); freopen(\"35.out\", \"w\", stdout);#endif init(); scanf(\"%s\", s + 1);n = strlen(s + 1); DREP(i, n, 1) extend(s[i] - 'a', i); vis[1] = 1; REP(i, 2, cur) if (!vis[i] &amp;&amp; id[i]) for (int j = i, pos = n; !vis[j]; vis[j] = 1, j = ne[j], --pos) { pos = pos - Max[j] + Max[ne[j]] + 1; q[++top] = state{ne[j], j, s[pos] - 'a'}; } REP(i, 1, top) cnt[q[i].z]++; REP(i, 1, siz-1) cnt[i] += cnt[i-1]; DREP(i, top, 1) rk[cnt[q[i].z]--] = i; DREP(i, top, 1) add(q[rk[i]].x, q[rk[i]].y); dfs(start); REP(i, 1, n) printf(\"%d%c\", sa[i], i == n ? '\\n' : ' '); REP(i, 1, n) _rank[sa[i]] = i; REP(i, 1, n) { h[i] = max(0, h[i-1] - 1); int maxlen = min(n - i + 1, n - sa[_rank[i]-1] + 1); while (h[i] &lt; maxlen &amp;&amp; s[i + h[i]] == s[sa[_rank[i]-1] + h[i]]) h[i]++; } REP(i, 1, n) height[_rank[i]] = h[i]; REP(i, 2, n) printf(\"%d%c\", height[i], i == n ? '\\n' : ' '); return 0;}","link":"/2019/07/29/模板-后缀排序（有待完善）/"},{"title":"胡闹 交互程序","text":"毒瘤交互。 题目大意有$N$个盒子，第$i$个盒子里面有$p_i$个球，从一个盒子中只能拿一个球出来。求恰好拿出来$M$个球的方案数，对$998244353$取模。 你不知道$pi​$的具体的值，只能指定操作。 具体来说，你有一个长度为$T$的整型数组$A$，其中前$N$个位置初始存的是$p_1,p_2,⋯,p_N$。其余位置的初始值由你通过Set操作来决定。 在决定完初始值之后，你就只能指定操作了。你只能提出： $A_i=A_j+A_k$ $A_i=A_j−A_k$ $A_i=A_j\\times A_k$（所有运算均在模$998244353$意义下） 过程中不允许你修改前$N$个位置的值。 过程中不允许使用Set操作赋值。 你还需要指出$A$中的哪一个数是答案。 数据范围$1\\le M\\le N\\le 1000,T=1004$ 解析由生成函数，答案显然为：$$Ans=\\prod_{i=1}^n (1+p_i\\times x) [x^{n-m}]$$然后我们考虑一些事情： 操作的处理归零直接把一个数减去自身即可。 归一费马小定理即可。$$a^{P-1}\\equiv1(\\bmod P)$$ 复制先归零，然后加起来即可。 （计算中）赋值在计算前，先搞一个$1$出来。 把要赋的值二进制分解赋值即可。 优化直接搞暴力复杂度有点爆炸。 考虑一下$IDFT$的过程，那么我们可以把答案化成这样的形式：$$Ans=\\frac{1}{N}\\times\\sum_{i=0}^{N-1}f(\\omega_N^i)\\times\\omega_N^{-i\\times m}$$这个时候我们就发现$T=1004$给我们剩下了哪$4$个变量了：$$Ans,f(x),x,y=1$$ 实现时预处理出$\\omega_N^i$即可。 Notice哎呀这个东西时真的坑。 我被我的巨大常数送走无数次之后，决心： 让常数优化成为习惯。 然后我就疯狂加inline，然后就疯狂Complie Error。 调了好久，最后原因是交互库你里面的函数没有inline，而我加了。 这样会导致什么呢？对，交互库的函数就没有定义了。 而且这个东西不用g++ -o %&lt; % grader.cpp还查不出来。 难受😔。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#define REP(i, s, e) for (int i = s; i &lt;= e; i++)#include &lt;bits/stdc++.h&gt;#include \"polynomial.h\"using namespace std;const int maxn = 1000 + 30, g = 3, MOD = 998244353;int n, m, t, N = 1 &lt;&lt; 10;int ans, fx, w[maxn], t1, t2;inline int power_pow(int a, int b){ int ans = 1, base = a; while (b) { if (b &amp; 1) ans = 1ll * ans * base % MOD; base = 1ll * base * base % MOD; b &gt;&gt;= 1; } return ans;}void Init(int n, int m, int t){ ::n = n; ::m = n - m; N = 1024; Set(ans = n + 4, 0); Set(fx = n + 1, 0); Set(t1 = n + 2, 1); Set(t2 = n + 3, 1); w[0] = 1; w[1] = power_pow(3, (MOD - 1) / N); REP(i, 2, N - 1) w[i] = 1ll * w[i-1] * w[1] % MOD;}inline void Set_Zero(int x) {Minus(x, x, x);}inline void Copy(int i,int j){ Set_Zero(i); Plus(i, i, j);//i = i + j = 0 + j = j}inline void Power_pow(int base, int b){ bool first = 1; while (b) { if (b &amp; 1) if (first) { first = 0; Copy(t1, base); } else Multiply(t1, t1, base); Multiply(base, base, base); b &gt;&gt;= 1; } Copy(base, t1);}inline void Set_One(int x) {Power_pow(x, MOD - 1);/*a ^ (P-1) = 1 (MOD P)*/;}inline void Get(int x){ Set_One(t2); Set_Zero(t1); while (x) { if (x &amp; 1) Plus(t1, t1, t2); Plus(t2, t2, t2); x &gt;&gt;= 1; }}void Solve(){ REP(i, 0, N - 1) { Set_One(t2); Copy(fx, t2); Get(w[i]); REP(j, 1, n) { Plus(t1, t1, j); Multiply(fx, fx, t1); Minus(t1, t1, j); } Get(w[((-i * m % N) + N) % N]); Multiply(fx, fx, t1); Plus(ans, ans, fx); } Get(power_pow(N, MOD-2)); Multiply(ans, ans, t1); Answer(ans);}","link":"/2019/07/28/胡闹-交互程序/"},{"title":"胡闹 统计三角形","text":"题目大意给你平面上$n\\le3000$个点，每个点有一个颜色$c_i\\in[0,2]$。 定义一个三角形是好的，当且仅当这个三角形的三个定点颜色不同。 定义一对三角形是好的，当且仅当这两个三角形是好的其这两个三角形没有交集。 为了避免歧义，保证点的坐标互不相同。 统计好的三角形对有多少。 解析首先，两个三角形没有交集的的充要条件是这两个三角形之间存在两条内公切线。 那么我们就可以枚举内公切线。 这条直线会把平面分成两个部分，然后有贡献的点对一定一个在这条直线左边，一个在这条直线右边。 那我们可以先枚举一个点，然后把其他的点做极角排序。极角排序用向量比较麻烦，那就直接三角函数吧。 按照这样的顺序枚举两个点来枚举内公切线，就可以保证每次都只会把一个点从一边丢到另一边去。 统计的时候大力讨论一下颜色就可以了。 Notice值得注意的是，如果管坐标大小直接随便搞，答案会是真正的答案的$4$倍，要记得把这个东西搞掉。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#define REP(i, s, e) for (int i = s; i &lt;= e; i++)#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;using namespace std;const int maxn = 3000 + 10;const double pi = acos(-1), inf = 1e20;int n;long long ans;int cnt[2][3];//cnt[0/1][x] 分割线左右的cntbool app[maxn];//被搞过去几次struct point{ int x, y, c, id; double k; bool operator &lt; (point B) const {return k &lt; B.k;}//极角排序}P[maxn], p[maxn], O;int main(){#ifndef ONLINE_JUDGE freopen(\"B.in\", \"r\", stdin); freopen(\"B.out\", \"w\", stdout);#endif cin &gt;&gt; n; REP(i, 1, n) scanf(\"%d%d%d\", &amp;P[i].x, &amp;P[i].y, &amp;P[i].c), P[i].id = i; long long tmp; REP(i, 1, n) { O = P[i]; int k = O.c; copy(P + 1, P + 1 + n, p + 1); int cur(0); REP(j, 1, n) if (i ^ p[j].id) { p[++cur]=p[j]; p[cur].k = atan2(p[cur].y - O.y, p[cur].x - O.x); if (p[cur].k &lt;= 0) p[cur].k += pi; } sort(p + 1, p + n); memset(cnt, 0, sizeof(cnt)); memset(app, 0, sizeof(app)); REP(j, 1, cur) if (p[j].y &lt; O.y || p[j].y == O.y &amp;&amp; p[j].x &gt; O.x) ++cnt[0][p[j].c];//一开始下面 else ++cnt[1][p[j].c], app[j] = 1; REP(j, 1, cur) { --cnt[app[j]][p[j].c]; tmp = 1ll * (k ? cnt[0][0] : 1) * (p[j].c ? cnt[1][0] : 1) * ((k ^ 1) ? cnt[0][1] : 1) * ((p[j].c ^ 1) ? cnt[1][1] : 1) * ((k ^ 2) ? cnt[0][2] : 1) * ((p[j].c ^ 2) ? cnt[1][2] : 1);//大力统计颜色 ans += tmp; tmp = 1ll * (k ? cnt[1][0] : 1) * (p[j].c ? cnt[0][0] : 1) * ((k ^ 1) ? cnt[1][1] : 1) * ((p[j].c ^ 1) ? cnt[0][1] : 1) * ((k ^ 2) ? cnt[1][2] : 1) * ((p[j].c ^ 2) ? cnt[0][2] : 1); ans += tmp; ++cnt[app[j] ^= 1][p[j].c]; } } cout &lt;&lt; ans / 4 &lt;&lt; endl; return 0;}","link":"/2019/07/28/胡闹-统计三角形/"},{"title":"口胡 最小K覆盖圆","text":"这个什么“最小$K$覆盖圆”其实是我瞎整的一个定义。 题目大意给定平面上$n\\le500$个点$(x_i,y_i)$，求出最小的一个半径$r$使得有至少$k$个点被某个以$r$为半径的圆覆盖（包含边界）。 精确到$10^{-8}$。 解析这是一个悲伤的故事。如果不那么精确，比如说精确到$10^5$，那什么随机算法爬山啊、退火啊、粒子群啊都能过 这是一个更悲伤的故事UOJ的clock()好像是假的，这样就造成了薛定谔的TLE。 我们考虑二分答案。 显然可以先枚举一个固定点，然后确保这个固定点在圆的边界上。 注意到枚举固定点的时候，包含一个点的圆是一段区间。 那么我们的问题就变成了了给出若干段区间，问有没有一个位子被$k−1$个区间包含。 暴力二分答案的复杂度是$\\mathcal{O}(n^2log\\ n\\ log\\ ans)$的，不太行。 考虑稍微剪一下枝。如果我们当前点对于最优解不合法（搞不定那么多个区间），就直接不管了。 然后random_shuffle一下，复杂度就变成了期望$\\mathcal{O}(nlog^2\\ nlog\\ ans)$了。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586//modify to learn#define REP(i, s, e) for (int i = s; i &lt;= e; i++)#define dis(x1, y1, x2, y2) sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2))#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#define double long double#define point pair&lt;double, double&gt;#define x first#define y secondusing namespace std;const int maxn = 500 + 5;const double eps = 1e-9, inf = 1e20;int n, k;point a[maxn], b[maxn &lt;&lt; 1];double ans;inline double dist(point A, point B) {return dis(A.x, A.y, B.x, B.y);}inline int dcmp(double x) {return (x &gt; eps) - (x &lt; -eps);}bool same(double x, double y) {return fabs(x-y) &lt; eps;}inline bool cmp(point A, point B) {return A.x &lt; B.x || A.x == B.x &amp;&amp; A.y &lt; B.y;}point operator + (point A, point B) {return make_pair(A.x + B.x, A.y + B.y);}point operator - (point A, point B) {return make_pair(A.x - B.x, A.y - B.y);}point operator / (point A, double u) {return make_pair(A.x / u, A.y / u);}point operator * (point A, double u) {return make_pair(A.x * u, A.y * u);}inline void calc(point o1, point o2, double r, point&amp; x, point&amp; y){ double Dis = dist(o1, o2) / 2; point mid = (o1 + o2) / 2, p = (o2 - o1) / 2; p = make_pair(p.y, -p.x) / Dis * sqrt(r * r - Dis * Dis); x = mid + p, y = mid - p;}inline bool check(point o, double r){ int m = k - 1, p = 0; REP(i, 1, n) if (dcmp(dist(o, a[i])) &amp;&amp; dcmp(dist(o, a[i]) - 2 * r) &lt;= 0) { point x,y; calc(o, a[i], r, x, y); double ax = atan2(x.y - o.y, x.x - o.x), ay = atan2(y.y - o.y, y.x - o.x); b[++p] = make_pair(ax, -1); b[++p] = make_pair(ay, 1); if (ax &gt; ay) m--; } if (m &lt;= 0) return 1; sort(b + 1, b + p + 1, cmp); REP(i, 1, p) if ((m += b[i].y) &lt;= 0) return 1; return 0;}int main(){#ifndef ONLINE_JUDGE freopen(\"A.in\", \"r\", stdin); freopen(\"A.out\", \"w\", stdout);#endif srand(233); cin &gt;&gt; n &gt;&gt; k; REP(i, 1, n) scanf(\"%LF%LF\", &amp;a[i].x, &amp;a[i].y); random_shuffle(a + 1, a + n + 1); double L, R = inf; REP(i, 1, n) if (check(a[i], R)) { L = 0; while (R - L &gt; eps) { double MID = (L + R) / 2; if (check(a[i], MID)) R = MID; else L = MID; } } printf(\"%.8LF\\n\", R); return 0;}","link":"/2019/07/27/口胡-最小K覆盖圆/"},{"title":"口胡 字符串最小等价串","text":"这种东西见过一两次了，稍微口胡一下吧。 定义什么是最小等价串？ 可以理解为把一个字符串中的字符按顺序重新“编号”。 比如说一个字符串S=BBCBA，那么它的最小表示就是T=AABAC。 问题快速判断两个串是否等价（即最小等价串相同） 解析我们发现问题就在于这个字符可以随便搞，这样随便怎样都会挂。 怎么办呢？能不能反过来利用这个东西？ 注意到我们不关心每一种字符具体是什么，只关心它们在哪里出现了。 那么我们可以考虑记last[i]表示字符i上一次出现的位置，第$1$次出现则记为$0$。 不难发现，只要两个字符串对应的i-last[i]相同，它们就是等价的。 比如说字符串S=BBCBA： Source String B B C B A LAST 0 1 0 2 0 i-LAST 1 1 3 2 5 字符串T=AABAC： Source String A A B A C LAST 0 1 0 2 0 i-LAST 1 1 3 2 5 说明S和T是等价的。 而对于SS=AAABC来说： source String A A A B C LAST 0 1 2 0 0 i-LAST 1 1 1 4 5 说明SS与S,T是不等价的。 对不对？WO YE BU HUI。","link":"/2019/07/26/口胡-字符串最小等价串/"},{"title":"胡闹 回文","text":"题目大意求$[0,n]$中有几个$n\\le10^6$位数（考虑前导$0$）满足如下情况： 这个数是一个回文数。 这个数奇数位上的和等于偶数位上的和。 解析假设$n$是一个偶数，那么答案显然是$10^\\frac{n}{2}$对吧。 然后假设$n$是一个奇数。 $\\mathcal{O(n^2)}$ 的$dp$做法我们可以设dp[i][j]​为长度为i（不考虑前导$0$），奇数位与偶数位的差为j的数的总数。 这个随便转移一下就好了。 但是这可能出现负数下标，这很难受，有两个解决方案： #define Dp(i, j) dp[i][j+Min_Value] __gnu_pbds::gp_hash_table&lt;int, int&gt; 但是如果你傻逼如我（不可能）用了这种东西：map&lt;int, int&gt; 那么恭喜你，获得一个$log$的$debuff$并且挂成暴力。 正确的复杂度这看上去是一个容斥。 然后我们考虑怎么个容斥法。 对于形如$n=4k+1$的数的话，我们推一推式子：$$\\begin{align}2\\times(x_1 + x_3 + · · · + x_{2k−1}) + x_{2k+1} &amp;= 2 \\times (x_2 + x_4 + · · · + x_{2k})\\\\x_2+x_4+· · ·+x_{2k}+(9−x_1)+(9−x_2)+· · ·+(9−x_{2k−1})&amp;=9k+\\frac{x_{2k+1}}{2}\\end{align}$$那么我们考虑枚举一下$\\frac{x_{2k+1}}{2}$，这就变成了一个容斥然后隔板法（别问我为什么，WO YE BU HUI）。 对于形如$n=4k+3$的样子，多考虑一个数就可以了（WO YE BU HUI） Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#define REP(i, s, e) for (register int i = s; i &lt;= e; i++)#define DREP(i, s, e) for (register int i = s; i &gt;= e; i--)#include &lt;bits/extc++.h&gt;#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int maxn = 1e7 + 10, MOD = 1e9 + 7;inline int power_pow(int a, int b){ int ans(1), base(a); while (b) { if (b &amp; 1) ans = ans * base % MOD; base = base * base % MOD; b &gt;&gt;= 1; } return (ans + MOD) % MOD;}#define inv(x) power_pow(x, MOD - 2)int n;int fac[maxn], Inv[maxn];inline int C(int n, int m) {return n &lt; m || m &lt; 0 ? 0 : fac[n] * Inv[n-m] % MOD * Inv[m] % MOD;}inline int solve(int S, int n){ int res(0), cur(-1); REP(i, 0, n) res += (cur *= -1) * C(n, i) * C(S - i * 10 + n - 1, n - 1) % MOD, res %= MOD; return (res + MOD) % MOD;}__gnu_pbds::gp_hash_table &lt;int,int&gt; cnt;__gnu_pbds::gp_hash_table &lt;int,int&gt; :: iterator it;signed main(){#ifndef ONLINE_JUDGE freopen(\"B.in\", \"r\", stdin); freopen(\"B.out\", \"w\", stdout);#endif Inv[0] = fac[0] = 1; REP(i, 1, 10000000) fac[i] = fac[i-1] * i % MOD; Inv[10000000] = inv(fac[10000000]); DREP(i, 9999999, 1) Inv[i] = Inv[i+1] * (i+1) % MOD; int T;cin &gt;&gt; T; while (T--) { scanf(\"%lld\", &amp;n); int ans = 0; if (n % 2 == 0) ans = power_pow(10, n &gt;&gt; 1); else if (n == 1) ans = 1; else if (n == 3) ans = 5; else if (n % 4 == 1) REP(i, 0, 4) ans += solve(i + 9 * (n &gt;&gt; 2), n &gt;&gt; 1) % MOD, ans %= MOD; else { cnt.clear(); REP(i, 0, 4) REP(j, 0, 9) cnt[i-j]++; for (it = cnt.begin(); it != cnt.end(); it++) ans += solve(it -&gt; first + 9 * (n &gt;&gt; 2), (n &gt;&gt; 1) - 1) * it -&gt; second % MOD, ans %= MOD; } printf(\"%lld\\n\", ans); } return 0;}","link":"/2019/07/25/胡闹-回文/"},{"title":"胡闹 填数","text":"这种题能做？ 我也就靠着重构$std$过活了。 题目大意给你一个$n\\times m$的矩阵要你填数。填的数范围为$[1,k]$。 问你本质不同的方案有多少。本质不同定义为任意交换行列后无法全同。 Notice时限$4s$ $1\\le n,m\\le45,1\\le k\\le10^9$ 解析一看就是我不会的题。 考虑一下$Brunside$引理（其实大概是$polya$?)。直接随便整数划分枚举行列置换的循环长度，这个复杂度大概是$\\mathcal{O(B_nB_m\\times n\\times m)}$的。 这个复杂度不太行，大概只能卡过$n,m\\le20$的数据。 怎么优化呢？ 我们发现如果我们枚举了行的整数划分，我们其实不用管列的具体情况，只要管一管它的贡献和。 具体来说可以把每个循环长度的贡献全部搞起来$dp$，发现这是一个背包的形式，卡卡常就能低空飞过了。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495//modify#define REP(i, s, e) for (register int i = s; i &lt;= e; i++)#define DREP(i, s, e) for (register int i = s; i &gt;= e; i--)#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;ctime&gt;using namespace std;const long long N = 150, maxn = N + 10, MOD = 1e9 + 7;inline long long power_pow(long long a, long long b){ long long ans = 1, base = a; while (b) { if (b &amp; 1) ans = ans * base % MOD; base = base * base % MOD; b &gt;&gt;= 1; } return ans;}#define inv(x) power_pow(x, MOD-2)int n, m, k;int fac[maxn], Inv[maxn], single[maxn], bin[maxn], dp[maxn];int v[maxn], p;int calc(){ int n = p; REP(i, 1, m) dp[i] = 0; dp[0] = 1; REP(i, 1, m) { long long coef = single[i]; REP(j, 1, n) coef = coef * bin[__gcd(v[j], i)] % MOD; DREP(j, m, 0) { long long cur = coef; for (int k = 1; j + i * k &lt;= m; k++) { dp[j + i * k] = (dp[j + i * k] + dp[j] * cur % MOD * Inv[k]) % MOD; cur = cur * coef % MOD; } } } int ans = dp[m], cnt = 0; REP(i, 1, n) { ans = ans * 1ll * single[v[i]] % MOD; if (i &gt; 1 &amp;&amp; v[i] ^ v[i - 1]) { ans = ans * 1ll * Inv[cnt] % MOD; cnt = 0; } cnt++; } return ans * 1ll * Inv[cnt] % MOD;}int dfs(int less, int last){ if (!less) return calc(); int res = 0; DREP(i, min(less, last), 1) { res = (0ll + res + dfs(less - i, v[++p] = i)) % MOD; --p; } return res;}signed main(){#ifndef ONLINE_JUDGE freopen(\"A.in\", \"r\", stdin); freopen(\"A.out\", \"w\", stdout);#endif cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; fac[0] = Inv[0] = bin[0] = 1; REP(i, 1, N) { fac[i] = 1ll * fac[i - 1] * i % MOD; single[i] = power_pow(i, MOD - 2); bin[i] = 1ll * bin[i - 1] * k % MOD; } Inv[N] = inv(fac[N]); DREP(i, N-1, 1) Inv[i] = 1ll * Inv[i+1] * (i+1) % MOD; cout &lt;&lt; dfs(n, n) &lt;&lt; endl;#ifndef ONLINE_JUDGE cerr&lt;&lt;clock()*1./CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;}","link":"/2019/07/25/胡闹-填数/"},{"title":"Luogu 4074 [WC2013 糖果公园]","text":"传送门 正确性什么的先咕咕咕一下吧，我也不太会。 题目大意有一个$n\\le10^5$个节点的树，每个节点有一个颜色。 每次询问：$$\\sum_cval_c\\times\\sum_{i=1}^{cnt}w_i$$$val_c$表示该颜色的价值 $cnt$表示颜色出现的次数 $w_i$表示该颜色出现$i$次后的价值 带修改。 解析可以考虑用$dfs$把这棵树拍平。 我们记录到达每个点的$dfn$和离开每个点的$dfn$： 在上图的例子中，我们设蓝色数字为$st_i$表示到达的$dfn$，绿色数字为$ed_i$表示离开的$dfn$。 对于一条链$(x,y)$，我们分类讨论（以下假设$st_x&lt;st_y$）： 若$x$和$y$构成祖孙关系，考虑区间$[st_x,st_y]$。 否则考虑区间$[ed_x,st_y]$。 我们发现，所有不在链上的点所对应的$dfn$（包括$st$和$ed$）都经过了正好偶数遍！ ⬆这个是假的，我们要特判$lca$。 然后就可以随便莫队了。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176#define DREP(i, s, e) for(int i = s; i &gt;= e ;i--)#define REP(i, s, e) for(int i = s; i &lt;= e ;i++)#define DEBUG fprintf(stderr, \"Passing [%s] in Line %d\\n\", __FUNCTION__, __LINE__)#define chkmax(a, b) a = max(a, b)#define chkmin(a, b) a = min(a, b)#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;const int maxn = 100000 + 10, maxm = 100000 + 10, maxq = 100000 + 10, block_siz = 800;int bg[maxn], ne[maxm &lt;&lt; 1], to[maxm &lt;&lt; 1], e;inline void add(int x, int y){ e++; to[e] = y; ne[e] = bg[x]; bg[x] = e;}template &lt;typename T&gt; inline T read(){ T ans(0), p(1); char c = getchar(); while (!isdigit(c)) { if (c == '-') p = -1; c = getchar(); } while (isdigit(c)) { ans = ans * 10 + c - 48; c = getchar(); } return ans * p;}int n, m, q, c[maxn];int st[maxn], ed[maxn], back[maxn &lt;&lt; 1], dfs_clock, top[maxn], fa[maxn], siz[maxn], hvy[maxn], depth[maxn];void dfs1(int x){ back[st[x] = ++dfs_clock] = x; siz[x] = 1; for (int i = bg[x]; i ; i = ne[i]) if (to[i] ^ fa[x]) { fa[to[i]] = x; depth[to[i]] = depth[x] + 1; dfs1(to[i]); siz[x] += siz[to[i]]; if (siz[to[i]] &gt; siz[hvy[x]]) hvy[x] = to[i]; } back[ed[x] = ++dfs_clock] = x;}void dfs2(int x, int y){ top[x] = y; if (hvy[x]) dfs2(hvy[x], y); for (int i = bg[x]; i ; i = ne[i]) if (to[i] ^ fa[x] &amp;&amp; to[i] ^ hvy[x]) dfs2(to[i], to[i]);}inline int lca(int x, int y){ while (top[x] ^ top[y]) { if (depth[top[x]] &lt; depth[top[y]]) swap(x, y); x = fa[top[x]]; } return depth[x] &lt; depth[y] ? x : y;}int belong[maxn &lt;&lt; 1];struct query{ int l, r, t, spj, id; query(){} query(int _l, int _r, int _t, int _id, int _spj = 0) : l(_l), r(_r), t(_t), id(_id), spj(_spj) {} }qlist[maxq];inline bool operator &lt; (query A, query B) {return belong[A.l] &lt; belong[B.l] || (belong[A.l] == belong[A.l] &amp;&amp; belong[A.r] &lt; belong[B.r]) || (belong[A.l] == belong[B.l] &amp;&amp; belong[A.r] == belong[B.r] &amp;&amp; A.t &lt; B.t);}int cur, Q;pair &lt;int, int&gt; cz[maxq];long long ans, cnt[maxm], v[maxn], w[maxn];bool vis[maxn];int l, r, T;inline void timego(){ T++; int x = cz[T].first, &amp;b = cz[T].second, &amp;a = c[x]; if (!vis[x]) swap(a, b); else { ans -= w[(cnt[a]--)] * v[a]; swap(a, b); ans += w[(++cnt[a])] * v[a]; }}inline void timeback(){ int x = cz[T].first, &amp;b = cz[T].second, &amp;a = c[x]; if (!vis[x]) swap(a, b); else { ans -= w[(cnt[a]--)] * v[a]; swap(a, b); ans += w[(++cnt[a])] * v[a]; } T--;}inline void add(int x){ if (!vis[x]) ans += w[(++cnt[c[x]])] * v[c[x]]; else ans -= w[(cnt[c[x]]--)] * v[c[x]]; vis[x] ^= 1;}inline void del(int x){ if (vis[x]) ans -= w[(cnt[c[x]]--)] * v[c[x]]; else ans += w[(++cnt[c[x]])] * v[c[x]]; vis[x] ^= 1;}bool needoutput[maxq];long long realans[maxq];signed main(){#ifdef CraZYali freopen(\"4074.in\", \"r\", stdin); freopen(\"4074.out\", \"w\", stdout);#endif cin &gt;&gt; n &gt;&gt; m &gt;&gt; q; REP(i, 1, m) v[i] = read&lt;int&gt;(); REP(i, 1, n) w[i] = read&lt;int&gt;(); REP(i, 2, n) { int x(read&lt;int&gt;()), y(read&lt;int&gt;()); add(x, y);add(y, x); } REP(i, 1, n) c[i] = read&lt;int&gt;(); dfs1(1); dfs2(1, 1); REP(i, 1, q) { int opt(read&lt;int&gt;()), x(read&lt;int&gt;()), y(read&lt;int&gt;()); if (opt == 0) cz[++cur] = make_pair(x, y); else { needoutput[i] = 1; if (st[x] &gt; st[y]) swap(x, y); int l(lca(x, y)); if (x ^ l &amp;&amp; y ^ l) qlist[++Q] = query(ed[x], st[y], cur, i, l); else qlist[++Q] = query(st[x], st[y], cur, i); } } REP(i, 1, n + n) belong[i] = i / block_siz; sort(qlist + 1, qlist + 1 + Q); REP(i, 1, Q) { while (T &lt; qlist[i].t) timego(); while (T &gt; qlist[i].t) timeback(); while (l &lt; qlist[i].l) del(back[l++]); while (l &gt; qlist[i].l) add(back[--l]); while (r &lt; qlist[i].r) add(back[++r]); while (r &gt; qlist[i].r) del(back[r--]); if (qlist[i].spj) add(qlist[i].spj); realans[qlist[i].id] = ans; if (qlist[i].spj) del(qlist[i].spj); } REP(i, 1, q) if (needoutput[i]) printf(\"%lld\\n\", realans[i]); return 0;}","link":"/2019/07/24/Luogu-4074-WC2013-糖果公园/"},{"title":"胡闹 tree","text":"题目大意给你一棵$n\\le10^5$的树，你分别有白链、黑链$B,W\\le30000$条。 你要把树上的点染成黑白。如果一条白链锁包含的点都被染成了白色，那你会的得到这条白链的奖励，黑链同理。 求最大奖励。 解析我们首先假设所有的链都能选上并且不冲突。 那么我们只要最小化消去冲突的代价就可以了。 是不是很像最小割？ 我们把一条链上所包含的点全部连起来构成一个网络流上的“大点”，然后就是分别处理黑链、白链之间连边，跑最小割就可以了。 但是这样每个点之间都可能会连一条$inf$的边（表示在都在一条链上，即最小割隔不断它），这样边数可能会爆炸。 怎么办呢？考虑优化连边。 一种可行的方法是上线段树 一个简单的方法是倍增，把一个大区间倍增成几个小区间，然后小区间之间连$inf$边来成为大区间，而不是一个点一个点地连。 这样边数就会显著减少，随便搞一搞就行了。 优化时限$10s$卡常？怎么优化？ 优化$lca$：利用$dfn$，只用一次倍增就可以求出$lca$。这个用处不大，因为还有更好的方法求lca 优化$Dinic$ 当前弧优化 分层的时候从$T$开始分到$S$，我也不知道为什么这样会快很多。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213//modify std//still learning#define REP(i, s, e) for (int i = s; i &lt;= e; i++)#define DREP(i, s, e) for (int i = s; i &gt;= e; i--)#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 10, inf = 1&lt;&lt;30;namespace dinic{ const int maxn = 4e6 + 10, maxm = 3e7 + 100; int bg[maxn], ne[maxm], to[maxm], w[maxm], e = 1; int S, T, dis[maxn], q[maxn], head, tail; int cur[maxn]; void add(int x, int y, int z) { e++; to[e] = y; ne[e] = bg[x]; bg[x] = e; w[e] = z; } void link(int a, int b, int c) {add(a, b, c);add(b, a, 0);} bool bfs() { REP(i, S, T) dis[i] = -1; dis[q[head = tail = 1] = T] = 0; while (head &lt;= tail) { int x = q[head++]; for (int i = bg[x]; i ;i = ne[i]) if (w[i ^ 1] &amp;&amp; dis[to[i]] == -1) dis[q[++tail] = to[i]] = dis[x] + 1; } return dis[S] != -1; } int dfs(int x, int y = inf) { if (x == T || !y) return y; int res = 0; for (int &amp;i = cur[x]; i ; i = ne[i]) if (w[i] &amp;&amp; dis[to[i]] == dis[x] - 1) { int temp = dfs(to[i], min(y, w[i])); if (temp &gt; 0) { res += temp; y -= temp; w[i] -= temp; w[i ^ 1] += temp; if (!y) break; } } return res; } void output() { REP(x, S, T) for (int i = bg[x];i;i=ne[i])printf(\"%d %d %d\\n\",x,to[i],w[i]); } int work() { int ans = 0; while (bfs()) { REP(i, S, T) cur[i] = bg[i]; ans += dfs(S); } return ans; }}int n, B, W, ans, LOG;int dfn[maxn], dfs_clock, grand[maxn][20], depth[maxn];namespace tree{ int bg[maxn], ne[maxn &lt;&lt; 1], to[maxn &lt;&lt; 1], e; void add(int x, int y) { e++; to[e] = y; ne[e] = bg[x]; bg[x] = e; } void dfs(int x) { dfn[x] = ++dfs_clock; REP(i, 1, LOG) grand[x][i] = grand[grand[x][i-1]][i-1]; for (int i = bg[x]; i ; i = ne[i]) if (to[i] ^ grand[x][0]) { grand[to[i]][0] = x; depth[to[i]] = depth[x] + 1; dfs(to[i]); } } void init() { LOG = log2(n); depth[1] = 1; dfs(1); } int lca(int x, int y) { if (x == y) return x; if (dfn[x] &gt; dfn[y]) swap(x, y); DREP(i, LOG, 0) if (dfn[grand[y][i]] &gt; dfn[x]) y = grand[y][i]; return grand[y][0]; }}using tree::add;using tree::lca;using dinic::link;int L[maxn][20], R[maxn][20];vector &lt;pair &lt;int, int&gt; &gt; E;int cur;void getl(int k, int t){ if (!L[k][t]) { L[k][t] = ++cur; getl(k, t - 1); getl(grand[k][t-1], t-1); link(L[k][t], L[k][t-1], inf); link(L[k][t], L[grand[k][t-1]][t-1], inf); }}int jump(int k, int d){ REP(i, 0, LOG) if (d &amp; (1 &lt;&lt; i)) k = grand[k][i]; return k;}void getr(int k, int t){ if (!R[k][t]) { R[k][t] = ++cur; getr(k, t - 1); getr(grand[k][t-1], t-1); link(R[k][t-1], R[k][t], inf); link(R[grand[k][t-1]][t-1], R[k][t], inf); }}void linkl(int k,int a,int c){ if (a==c) return; int t; for (t=0;(1&lt;&lt;(t+1))&lt;depth[a]-depth[c];t++); getl(a, t); link(k, L[a][t], inf); a = jump(a, depth[a]-depth[c]-(1&lt;&lt;t)); getl(a, t); link(k, L[a][t], inf);}void linkr(int k,int a,int c){ if (a==c) return; int t; for (t=0;(1&lt;&lt;(t+1))&lt;depth[a]-depth[c];t++); getr(a, t); link(R[a][t], k, inf); a = jump(a, depth[a]-depth[c]-(1&lt;&lt;t)); getr(a, t); link(R[a][t], k, inf);}int main(){#ifndef ONLINE_JUDGE freopen(\"B.in\",\"r\",stdin); freopen(\"B.out\",\"w\",stdout);#endif cin &gt;&gt; n &gt;&gt; B &gt;&gt; W;ans = n; REP(i, 2, n) { int x, y; scanf(\"%d%d\", &amp;x, &amp;y); add(x, y); } tree::init(); REP(i, 1, n) { L[i][0] = R[i][0] = ++cur; link(0, cur, 1); } while (B--) { int x, y, z, v; scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;v);z = lca(x, y); ++cur; ans += v; link(0, cur, v); linkl(cur, x, grand[z][0]); linkl(cur, y, z); } while (W--) { int x, y, z, v; scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;v);z = lca(x, y); ++cur; ans += v; E.push_back(make_pair(cur, v)); linkr(cur, x, grand[z][0]); linkr(cur, y, z); } dinic::T = ++cur; int siz = (int)E.size() - 1; REP(i, 0, siz) link(E[i].first, cur, E[i].second); REP(i, 1, n) link(i, cur, 1); cout &lt;&lt; ans - dinic::work() &lt;&lt; endl; return 0;}","link":"/2019/07/24/胡闹-tree/"},{"title":"胡闹 interval","text":"题目大意有一些形如$[L,R]$的区间，你要选出尽可能多的区间，并满足区间两两交集为空（注意$[X,X]$非空）。 输出字典序最小的最优方案。 解析首先可以想到一个简单的贪心。 把所有的区间按右端点排序，能取就取，这样一定最优。 如何维护字典序最小？ 考虑二分决策点，然后暴力往回跳。 为什么是对的？WO YE BU HUI Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#define REP(i, s, e) for (int i = s; i &lt;= e; i++)#define chkmin(a, b) a = min(a, b)#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;const int maxn = 200000 + 10;#define mid (l + r &gt;&gt; 1)int n, frm[maxn], last[maxn], dp[maxn], pos;struct line{ int l, r, id;}q[maxn];bool cmp(line A, line B) {return A.r &lt; B.r;}void jump(int x){ int a = x, b = last[x-1], mina(q[a].id), minb(q[b].id); while (frm[a] ^ frm[b]) { chkmin(mina, q[a].id), a = frm[a]; chkmin(minb, q[b].id), b = frm[b]; } chkmin(mina, q[a].id); chkmin(minb, q[b].id); if(mina &lt; minb) dp[x] = dp[pos] + 1, last[x] = x, frm[x] = last[pos]; else dp[x] = dp[x-1], last[x] = last[x-1], frm[x] = frm[x-1];}int stack[maxn], top;int main(){#ifndef ONLINE_JUDGE freopen(\"A.in\", \"r\", stdin); freopen(\"A.out\", \"w\", stdout);#endif cin &gt;&gt; n; REP(i, 1, n) scanf(\"%d%d\", &amp;q[i].l, &amp;q[i].r), q[i].id = i; sort(q + 1, q + 1 + n, cmp); REP(i, 1, n) { int l(0), r(i-1); pos = 0; while (l &lt;= r) if (q[mid].r &lt; q[i].l) { pos = mid; l = mid + 1; } else r = mid - 1; dp[i] = dp[pos] + 1; frm[i] = last[pos]; if (dp[i] &gt; dp[i-1]) dp[i] = dp[pos] + 1, last[i] = i; else if (dp[i] &lt; dp[i-1]) dp[i] = dp[i-1], last[i] = last[i-1]; else jump(i); } cout &lt;&lt; dp[n] &lt;&lt; endl; pos = last[n]; while(pos) stack[++top] = q[pos].id, pos = frm[pos]; sort(stack + 1, stack + 1 + top); REP(i, 1, top) printf(\"%d%c\", stack[i], i == top ? '\\n' : ' '); return 0;}","link":"/2019/07/23/胡闹-interval/"},{"title":"Luogu 2597 [ZJOI2012 灾难]","text":"传送门 题目大意一个食物网有$N$个点，代表$N$种生物，如果生物$x$可以吃生物$y$，那么从$y$向$x$连一个有向边。这个图没有环。 图中有一些点没有连出边，这些点代表的生物都是生产者，可以通过光合作用来生存； 而有连出边的点代表的都是消费者，它们必须通过吃其他生物来生存。 如果某个消费者的所有食物都灭绝了，它会跟着灭绝。 我们定义一个生物在食物网中的“灾难值”为，如果它突然灭绝，那么会跟着一起灭绝的生物的种数。 举个例子：在一个草场上，生物之间的关系是： 如 如果羊都死了，那么狼会因为没有食物而灭绝，而小强可以通过吃牛、牛可以通过吃草来生存下去。所以，羊的灾难值是$1$。 但是，如果草突然灭绝，那么整个草原上的$5$种生物都无法幸免，所以，草的灾难值是$4$。 给定一个食物网，你要求出每个生物的灾难值。 解析把所有的边反向，按时拓扑序处理某个点，这样就可以保证处理一个点的时候，这个点能吃的点都会被吃掉。现在我们假设处理一个点之前，其他的点统统都是一棵树的形态。 那么这个点吃的所有，等价于吃吃的所有的lca。 这个随便维护。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#define REP(i, s, e) for (int i = s; i &lt;= e; i++)#define DREP(i, s, e) for (int i = s; i &gt;= e; i--)#define DEBUG fprintf(stderr, \"Passing [%s] in Line %d\\n\", __FUNCTION__, __LINE__)#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cmath&gt;using namespace std;const int maxn = 70000 + 10, maxm = maxn;int bg[maxn], ne[maxn], to[maxn], e;void add(int x, int y){ e++; to[e] = y; ne[e] = bg[x]; bg[x] = e;}int n, k, depth[maxn], grand[maxn][20], LOG;int tcnt;vector &lt;int&gt; G[maxn], eat[maxn];int in[maxn], q[maxn], head, tail;int lca(int x, int y){ if (depth[x] &lt; depth[y]) swap(x, y); DREP(i, LOG, 0) if (depth[grand[x][i]] &gt;= depth[y]) x = grand[x][i]; if (x == y) return x; DREP(i, LOG, 0) if (grand[x][i] ^ grand[y][i]) x = grand[x][i], y = grand[y][i]; return grand[x][0];}int ans[maxn];void dfs(int x){ ans[x] = 1; for (int i = bg[x]; i ;i = ne[i]) { dfs(to[i]); ans[x] += ans[to[i]]; }}int main(){#ifndef ONLINE_JUDGE freopen(\"2597.in\", \"r\", stdin); freopen(\"2597.out\", \"w\", stdout);#endif cin &gt;&gt; n;LOG = log2(n); REP(i, 1, n) while (scanf(\"%d\", &amp;k), k) G[k].push_back(i), in[i]++, eat[i].push_back(k); REP(i, 1, n) if (!in[i]) depth[q[++tail] = i] = 1; while (head &lt;= tail) { int x = q[head++]; int siz = (int)G[x].size()-1; REP(i, 0, siz) if (!(--in[G[x][i]])) q[++tail] = G[x][i]; if (!eat[x].empty()) { siz = (int)eat[x].size() - 1; int l = eat[x][0]; REP(i, 1, siz) l = lca(l, eat[x][i]); grand[x][0] = l; depth[x] = depth[l] + 1; REP(j, 1, LOG) grand[x][j] = grand[grand[x][j-1]][j-1]; add(l, x); } } REP(i, 1, n) if(!ans[i])dfs(i); REP(i, 1, n) printf(\"%d\\n\", ans[i] - 1); return 0;}","link":"/2019/07/23/Luogu-2597-ZJOI2012-灾难/"},{"title":"胡闹 reform","text":"题目大意给你两个长度分别为$n,m\\le10^6$的串$S,T$。 询问$S$中有多少子串可以经过变换全等于$T$。 变换的定义是交换某个元素，即把元素$x$与元素$y$交换。 如$S=12321$， 交换$1$和$2$变成$S=21312$ 交换$1$和$4$变成$S=42324$ 解析UPD：加了一片口胡，可以search一下（懒得放link)了不用管具体元素的值，只需要关心一下离它最近的之前出现的它和之后出现的它离它的距离，把这个距离$Hash$一下就可以了。 然后注意搞到答案的时候要废掉后面的一些东西（因为移动字串相当于删掉了串首，加入了一个新元素。对于串首后面的”之前出现的”自然要更新，也就是要更新最早出现的之后的它） 语文太菜，看Code吧 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#define REP(i, s, e) for (int i = s; i &lt;= e ; i++)#define DREP(i, s, e) for (int i = s; i &gt;= e ; i--)#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;const int maxn = 1000000 + 10, maxm = 1000000 + 10;template &lt;typename T&gt; T read(){ T ans(0); char c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) { ans = ans * 10 + c - 48; c = getchar(); } return ans;}int n, m, a[maxn], b[maxm], c[maxn], s[maxn], t[maxm], temp[maxn + maxm &gt;&gt; 1];unsigned long long P = 131, bin[maxn], h, H;int ans, pos[maxn];int main(){#ifndef ONLINE_JUDGE freopen(\"A.in\", \"r\", stdin); freopen(\"A.out\", \"w\", stdout);#endif bin[0] = 1; REP(i, 1, 1e6) bin[i] = bin[i-1] * P; int Case(read&lt;int&gt;()), C(read&lt;int&gt;()); while (Case--) { n = read&lt;int&gt;();m = read&lt;int&gt;(); REP(i, 1, n) temp[i] = 0; REP(i, 1, n) s[i] = read&lt;int&gt;(), (a[i] = temp[s[i]] ? i - temp[s[i]] : m), temp[s[i]] = i; REP(i, 1, m) temp[i] = 0; REP(i, 1, m) t[i] = read&lt;int&gt;(), (b[i] = temp[t[i]] ? i - temp[t[i]] : m), temp[t[i]] = i; REP(i, 1, n) temp[i] = 0; DREP(i, n, 1) c[i] = temp[s[i]], temp[s[i]] = i; h = H = 0; REP(i, 1, m) H = H * P + b[i]; REP(i, 1, m) h = h * P + a[i]; ans = 0; if (h == H) pos[++ans] = 1; REP(i, 1, n - m) { h -= bin[m-1] * a[i]; if (c[i] &amp;&amp; c[i] &lt; i + m) h += bin[i-c[i]-1+m] * (m-a[c[i]]); a[c[i]] = m; h = h * P + a[i+m]; if (h == H) pos[++ans] = i + 1; } printf(\"%d\\n\", ans); REP(i, 1, ans) printf(\"%d%c\", pos[i], i == ans ? '\\n' : ' '); } return 0;}","link":"/2019/07/22/胡闹-reform/"},{"title":"胡闹 老园丁与小司机","text":"题目大意你是一个资本家，你的花园结构是一棵$n\\le3\\times10^5$个节点的树，有$m\\le 3\\times10^5$个无产阶级可以帮你标记路径，但只能是从一个节点到它的某一个祖先。 雇佣某个无产阶级需要工资。你想知道让你的花园里面所有的边都被标记所需要支付的最小工资。 如果全部雇佣也不够，你就会放 弃 思 考，认为需要$-1$的工资。 解析我 放 弃 了 思 考。 考虑树形$dp$，用左偏树维护决策。 发现可以维护无产阶级深度最高点为关键字的左偏树来维护决策，无脑上代码即可。 注意打标记。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#define REP(i, s, e) for (int i = s; i &lt;= e ; i++)#define DEBUG fprintf(stderr, \"Passing [%s] in Line %d\\n\", __FUNCTION__, __LINE__)#include &lt;iostream&gt;#include &lt;cstdio&gt;#define int long longusing namespace std;const int maxn = 300000 + 10, maxm = maxn, inf = 1ll &lt;&lt; 40;int bg[maxn], ne[maxm &lt;&lt; 1], to[maxm &lt;&lt; 1], e;void add(int x, int y){ e++; to[e] = y; ne[e] = bg[x]; bg[x] = e;}int depth[maxn];void dfs(int x, int fa = -1){ for (int i = bg[x]; i ; i = ne[i]) if (to[i] ^ fa) { depth[to[i]] = depth[x] + 1; dfs(to[i], x); }}struct worker{ int up, w, ne;}p[maxm &lt;&lt; 1];int cur = 300000;void insert(int x, int up, int w){ p[++cur] = (worker){up, w, p[x].ne}; p[x].ne = cur;}struct heap *null;heap* merge(heap *x, heap *y){};struct heap{ int up, f, Min, tag, dis; heap *l, *r; void pushdown() { if (tag) { f += tag; Min += tag; l -&gt; tag += tag; r -&gt; tag += tag; tag = 0; } } void pushup() { Min = min(f, min(l -&gt; Min + l -&gt; tag, r -&gt; Min + r -&gt; tag)); if (l -&gt; dis &lt; r -&gt; dis) swap(l, r); dis = r -&gt; dis + 1; } void pop() {*this = merge(l, r);}}pool[maxn], *now = pool, *root[maxn];heap* merge(heap *x, heap *y){ if (x == null) return y; if (y == null) return x; x -&gt; pushdown();y -&gt; pushdown(); if (x -&gt; up &lt;= y -&gt; up) swap(x, y); x -&gt; r = merge(x -&gt; r, y); x -&gt; pushup(); return x;}void solve(int x, int fa = -1){ int sum = 0; for (int i = bg[x]; i ; i = ne[i]) if (to[i] ^ fa) { solve(to[i], x); while (root[to[i]] -&gt; up &gt;= depth[to[i]]) root[to[i]].pop(); if (root[to[i]] == null) { cout &lt;&lt; -1 &lt;&lt; endl; exit(0); } sum += root[to[i]] -&gt; Min; } for (int i = p[x].ne; i ; i = p[i].ne) { *now = (heap) {p[i].up, sum + p[i].w, sum + p[i].w, 0, 1, null, null}; root[x] = merge(root[x], now++); } for (int i = bg[x]; i ; i = ne[i]) if (to[i] ^ fa) { int Min = root[to[i]] -&gt; Min; root[to[i]] -&gt; tag += sum - Min; root[x] = merge(root[x], root[to[i]]); } if (root[x] == null) { cout &lt;&lt; -1 &lt;&lt; endl; exit(0); }}int m, n, k;signed main(){#ifndef ONLINE_JUDGE freopen(\"A.in\", \"r\", stdin); freopen(\"A.out\", \"w\", stdout);#endif cin &gt;&gt; n &gt;&gt; m; REP(i, 2, n) { int x, y; scanf(\"%lld%lld\", &amp;x, &amp;y); add(x, y);add(y, x); } depth[1] = 1; dfs(1); REP(i, 1, m) { int u, v, w; scanf(\"%lld%lld%lld\", &amp;u, &amp;v, &amp;w); insert(u, depth[v], w); } null = new heap; null -&gt; l = null -&gt; r = null; null -&gt; Min = inf; REP(i, 1, n) root[i] = null; solve(1); printf(\"%lld\\n\", root[1] -&gt; Min + root[1] -&gt; tag); return 0;}","link":"/2019/07/21/胡闹-老园丁与小司机/"},{"title":"胡闹 string","text":"题目大意定义两个字符串匹配为它们的最小循环表示法相同。给定一个模式串和$n$个主串，求模式串对每一个主串的模式匹配次数。 最小循环表示法：对一个长度为$n$的字符串做$n$次操作，每次把第一个字符放到最后。这$n$个串中字典序最小的称为最小循环表示法 解析循环主串不好搞，我们就循环模式串。 然后如果循环后的模式串匹配上了，那说明这个匹配的地方的最小表示法和模式串一定是可以匹配上的。 直接一个$Hash$走人。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546#define REP(i, s, e) for (int i = s; i &lt;= e ; i++)#include &lt;bits/stdc++.h&gt;#define int unsigned long longusing namespace std;const int maxn = 100 + 5, maxlen = 1e6 + 10, P = 1e9 + 7;unordered_map &lt;int, bool&gt; cnt;int n, Hash[maxlen];char s[maxlen];int power_pow(int a, int b){ int ans = 1, base = a; while (b) { if (b &amp; 1) ans *= base; base *= base; b &gt;&gt;= 1; } return ans;}signed main(){#ifndef ONLINE_JUDGE freopen(\"B.in\", \"r\", stdin); freopen(\"B.out\", \"w\", stdout);#endif scanf(\"%s\", s + 1); int len = strlen(s + 1); REP(i, len + 1, len + len) s[i] = s[i-len]; REP(i, 1, len + len) Hash[i] = Hash[i-1] * P + s[i]; int PP = power_pow(P, len); REP(i, 1, len) cnt[Hash[i + len - 1] - Hash[i-1] * PP] = 1; cin &gt;&gt; n; while (n--) { scanf(\"%s\", s + 1); int Len = strlen(s + 1), ans(0); REP(i, 1, Len) Hash[i] = Hash[i-1] * P + s[i]; if (Len &gt;= len) REP(i, 1, Len - len + 1) ans += cnt[Hash[i + len - 1] - Hash[i-1] * PP]; printf(\"%llu\\n\", ans); } return 0;}","link":"/2019/07/21/胡闹-string/"},{"title":"胡闹 序列","text":"题目大意给定一个长度为$n\\le10^6$的序列$x$。 你需要从序列中选出一些位置。对于第$i$个位置，如果它被选中，你会获得$x_i$的收益；如果它没被选中，找到最小的$j$使得第$j$个位置到第$i$个位置都没有被选中，你需要付出$i−j+1$的代价。 此外，你选出的位置必须满足$x_i$是单调不下降的。 最大化收益减去代价的结果。 解析可以先考虑一下$x_i$单调不降的情况。 设$dp_i$表示最后一个选的数是第$i$个的最佳答案，则：$$dp_i=x_i+max{dp_j+\\frac{(i-j)\\times(i-j-1)}{2}}$$这个东西是一个非常板子的斜率优化对吧。 然后怎么考虑$x_i$无序的情况呢？ 我们发现，我们采用的顺序是可以换的。 那么我们对$x_i$进行分治，就是把$x_i$分成$(l,r)$的区间分别计算答案，然后归并一下就好了。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586//for test ? why#define REP(i, s, e) for (int i = s; i &lt;= e ; i++)#include &lt;stdio.h&gt;#include &lt;algorithm&gt;typedef long long ll;namespace io { const int SIZE = (1 &lt;&lt; 21) + 1; char ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr; // getchar#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++) // print the remaining part inline void flush () { fwrite (obuf, 1, oS - obuf, stdout); oS = obuf; } // putchar inline void putc (char x) { *oS ++ = x; if (oS == oT) flush (); } // input a signed integer template &lt;class I&gt; inline void gi (I &amp;x) { for (f = 1, c = gc(); c &lt; '0' || c &gt; '9'; c = gc()) if (c == '-') f = -1; for (x = 0; c &lt;= '9' &amp;&amp; c &gt;= '0'; c = gc()) x = x * 10 + (c &amp; 15); x *= f; } // print a signed integer template &lt;class I&gt; inline void print (I &amp;x) { if (!x) putc ('0'); if (x &lt; 0) putc ('-'), x = -x; while (x) qu[++ qr] = x % 10 + '0', x /= 10; while (qr) putc (qu[qr --]); }}using io :: gi;using io :: putc;using io :: print;const int N = 1000005, G = 21;int n, a[N], id[N], rid[N], qu[N], ql, qr, pos[G][N], m; ll dp[N], ret;bool check (int x, int y, int z) { return (dp[z] - dp[y]) * (y - x) &gt;= (dp[y] - dp[x]) * (z - y); }void mergesort (int l, int r, int d) { if (l == r) return (void)(pos[d][l] = id[l]); int mi = (l + r) &gt;&gt; 1, i = l, j = mi + 1; mergesort (l, mi, d + 1); mergesort (mi + 1, r, d + 1); int *x = pos[d], *y = pos[d + 1], p = l; while (p &lt;= r) if (i &lt;= mi &amp;&amp; (y[i] &lt; y[j] || j &gt; r)) x[p ++] = y[i ++]; else x[p ++] = y[j ++];}void solve (int l, int r, int d) { if (l == r) { int u = id[l]; dp[u] += a[u] - (ll)u * u; return ; } int mi = (l + r) &gt;&gt; 1, i; solve (l, mi, d + 1); for (ql = 1, qr = 0, i = l; i &lt;= r; i ++) { int u = pos[d][i]; if (rid[u] &lt;= mi) { while (ql &lt; qr &amp;&amp; check (qu[qr - 1], qu[qr], u)) qr --; qu[++ qr] = u; } else { while (ql &lt; qr &amp;&amp; dp[qu[ql]] + (ll)u * qu[ql] &lt;= dp[qu[ql + 1]] + (ll)u * qu[ql + 1]) ql ++; if (ql &lt;= qr) dp[u] = std :: max (dp[u], dp[qu[ql]] + (ll)u * qu[ql]); } } solve (mi + 1, r, d + 1);}int main () { int i; for (gi (n), i = 1; i &lt;= n; i ++) gi (a[i]), id[i] = i, dp[i] = 0; std :: sort (id + 1, id + n + 1, [&amp;] (const int &amp;x, const int &amp;y) { return a[x] == a[y] ? x &lt; y : a[x] &lt; a[y]; }); for (i = 1; i &lt;= n; i ++) rid[id[i]] = i; ;mergesort (1, n, 0); solve (1, n, 0); for (ret = -(ll)n * (n + 1) / 2, i = 1; i &lt;= n; i ++) ret = std :: max (ret, dp[i] + (ll)i * (i + 1) / 2 - (ll)(n - i) * (n - i + 1) / 2); printf (\"%lld\\n\", ret); return 0;}","link":"/2019/07/20/胡闹-序列/"},{"title":"胡闹 一路畅通","text":"题目大意给你一个$n\\le10^5$个点，$m\\le2\\times10^5$的无向图，每条边有一个权值$a_i&lt;2^{31}$。 求一条从$S$点走到$T$的路径，这条路径上的边权最大值除以边权最小值应该全局最小，输出这个值。 解析考虑先枚举一个上界，然后我们要让联通的下界尽量大。 怎么枚举上界呢？可以考虑把所有的边都按边权从大到小排序，然后类似$Kruskal$的方法来做。 如果新加入一条边，这条边两边是不联通的，那它显然是要保留的。 然后如果这条边两边是联通的，那么我们就应该把这个联通块中边权最小的边删掉，换成着一条边。 可以发现，这个联通块一定是一棵树。 现在我们要做的事情变成了： 维护一个森林 加边 删边 查询最小值 这个用一个$LCT$就可以维护好了。 答案怎么计算？非常简单，处理每一条边的时候都康康看看$S,T$是否联通，联通的话就就查询一下最小值就行了，这个直接用$Kruskal$里面的并查集就可以维护了。 注意一点，边权非常大，$inf$不能开太大！ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#define REP(i, s, e) for (int i = s; i &lt;= e; i++)#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;const int maxn = 100000 + 10, maxm = 200000 + 10, maxN = maxn + maxm;struct Edge{ int x, y, z;}E[maxN];bool cmp(Edge A, Edge B) {return A.z &gt; B.z;}int n, m, S, T;int f[maxN];int find(int x) {return f[x] == x ? f[x] : f[x] = find(f[x]);}void uni(int x, int y) {f[find(x)] = find(y);}int fa[maxN], ch[maxN][2], s[maxN];bool tag[maxN];#define ls(p) ch[p][0]#define rs(p) ch[p][1]#define get(x) (rs(fa[x]) == x)#define notroot(x) (ls(fa[x]) == x || rs(fa[x]) == x)void pushup(int x){ s[x] = x;s[0] = 0; if (E[s[x]].z &lt; E[s[ls(x)]].z) s[x] = s[ls(x)]; if (E[s[x]].z &lt; E[s[rs(x)]].z) s[x] = s[rs(x)];}void rotate(int x){ int y = fa[x], z = fa[y]; bool k = get(x); if (ch[x][k ^ 1]) fa[ch[x][k ^ 1]] = y; ch[y][k] = ch[x][k ^ 1]; if (notroot(y)) ch[z][get(y)] = x; fa[fa[y] = x] = z; ch[x][k ^ 1] = y; pushup(y);pushup(x);}void pushdown(int x){ if (!tag[x]) return; swap(ls(x), rs(x)); tag[ls(x)] ^= 1;tag[rs(x)] ^= 1; tag[x] = 0;}void pushall(int x){ if (notroot(x)) pushall(fa[x]); pushdown(x);}void splay(int x){ pushall(x); while (notroot(x)) { int y = fa[x]; if (notroot(y)) rotate(get(x) == get(y) ? y : x); rotate(x); }}void access(int x){ for (int t = 0; x; x = fa[t = x]) { splay(x); rs(x) = t; pushup(x); }}void makeroot(int x){ access(x); splay(x); tag[x] ^= 1;}void link(int x, int y){ makeroot(x); fa[x] = y;}void cut(int x, int y){ makeroot(x); access(y); splay(y); fa[x] = ls(y) = 0;}int query(int u, int v){ makeroot(u); access(v); splay(v); return s[v];}long long ansu = 1 &lt;&lt; 30, ansv = 1;int main(){#ifndef ONLINE_JUDGE freopen(\"B.in\", \"r\", stdin); freopen(\"B.out\", \"w\", stdout);#endif cin &gt;&gt; n &gt;&gt; m; REP(i, n + 1, n + m) scanf(\"%d%d%d\", &amp;E[i].x, &amp;E[i].y, &amp;E[i].z); cin &gt;&gt; S &gt;&gt; T; sort(E + n + 1, E + 1 + n + m, cmp); REP(i, 1, n) f[i] = i; REP(i, n + 1, n + m) { if (find(E[i].x) ^ find(E[i].y)) { uni(E[i].x, E[i].y); link(E[i].x, i); link(E[i].y, i); } else { int pos = query(E[i].x, E[i].y); if (E[pos].z &lt;= E[i].z) continue; cut(E[pos].x, pos); cut(E[pos].y, pos); link(E[i].x, i); link(E[i].y, i); } if (find(S) == find(T)) { int v = E[query(S, T)].z; if (ansu * E[i].z &gt;= ansv * v) ansu = v, ansv = E[i].z; } } if (ansu % ansv == 0) printf(\"%lld\\n\", ansu / ansv); else printf(\"%lld/%lld\\n\", ansu / __gcd(ansu, ansv), ansv / __gcd(ansu, ansv)); return 0;}","link":"/2019/07/19/胡闹-一路畅通/"},{"title":"胡闹 卷积练习题","text":"题目大意给定两个长度为$n$的非负整数数组$a,b$，求$$\\sum_{i=1}^n\\sum_{j=1}^n\\lfloor\\sqrt{|a_i-b_j|}\\rfloor$$ Notes$1\\le n\\le 10^6$，$0\\le a_i,b_i\\le 3\\times 10^6$，$\\sum a_i,\\sum b_i\\le 10^7$ 解析这个题目啊，interesting。 本来题目名字叫做“卷积练习题”，但是正解和卷积一点关系都没有。 一个套路，我们注意到$0\\le a_i$并且$\\sum a_i\\le10^7$，那么我们知道$a_i$的取值一定是$O(\\sqrt{10^7})$的？ 为什么呢？考虑抽屉原理。从$0$开始，放$1,2,3,4…$，那么放了$n$个的时候，必然有$\\sum a_i\\ge\\frac{n\\times(n-1)}{2}$。 所以$a_i$取值一定是$O(\\sqrt{10^7})$的。 我们又注意到，$\\lfloor\\sqrt{|a_i-b_j|}\\rfloor\\le \\sqrt{10^7}$。 那么就很简单了，枚举$a$中每一个出现的数，然后枚举$\\lfloor\\sqrt{|a_i-b_j|}\\rfloor$，$b$中合法的数一定是在两个区间内，统计的话直接及一个前缀和就好了。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#define REP(i, s, e) for (int i = s; i &lt;= e ;i++)#define chkmax(a, b) a = max(a, b)#define chkmin(a, b) a = min(a, b)#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#define double long double#define int long longusing namespace std;const int maxn = 1e6 + 10, maxL = 4200000;int n, ans, a[maxn], b[maxn], cnt[3000005];int s[3000005];signed main(){#ifndef ONLINE_JUDGE freopen(\"A.in\", \"r\", stdin); freopen(\"A.out\", \"w\", stdout);#endif cin &gt;&gt; n; REP(i, 1, n) scanf(\"%lld\", a + i), a[i]++; REP(i, 1, n) scanf(\"%lld\", b + i), b[i]++; if (n &lt;= 2000) { REP(i, 1, n) REP(j, 1, n) ans += floor(sqrt(abs(a[i] - b[j]))); } else { REP(i, 1, n) cnt[a[i]]++; REP(i, 1, n) s[b[i]]++; REP(i,1,3000001)s[i]+=s[i-1]; REP(A, 1, 3000001) if (cnt[A]) REP(C, 1, 1732) { int l, r; l = A - C * C - C * 2, r = A - C * C; if (max(l, 1ll) &lt;= min(r, 3000001ll)) { chkmax(l, 1ll);chkmin(l, 3000001ll); chkmax(r, 1ll);chkmin(r, 3000001ll); ans += C * cnt[A] * (s[r] - s[l-1]); } l = A + C * C, r = A + C * C + C * 2; if (max(l, 1ll) &lt;= min(r, 3000001ll)) { chkmax(l, 1ll);chkmin(l, 3000001ll); chkmax(r, 1ll);chkmin(r, 3000001ll); ans += C * cnt[A] * (s[r] - s[l-1]); } } } cout &lt;&lt; ans &lt;&lt; endl; return 0;}","link":"/2019/07/19/胡闹-卷积练习题/"},{"title":"胡闹 斐波那契","text":"题目大意求$$\\sum_{i=1}^n\\sum_{j=1}^mgcd(Fib_i,Fib_j)$$ 有人提出了神奇的解法。 注意到一个式子：$$Fib_a\\times Fib_b+Fib_{a+1}\\times Fib_{b+1}=Fib_{a+b+1}$$那么我们就有一个非常interesting的结论了：$$\\begin{align*}gcd(Fib_i,Fib_j)&amp;=gcd(Fib_j\\times Fib_{i-j+1}+Fib_{j-1}\\times Fib_{i-j},Fib_j)\\\\&amp;=gcd(Fib_{i-1}\\times Fib_{j-1},Fib_j)\\\\&amp;=Fib_{gcd(i,j)}\\end{align*}$$ 然后怎么利用莫比乌斯反演呢？ 记$f(k)$为$gcd(i,j)=k$的$(i,j)$的对数，$g(k)$表示$k|gcd(i,j)$的$i,j$对数。 然后推式子：$$\\begin{align*}Ans&amp;=\\sum_{k=1}^n f(k)\\times Fib_k\\\\&amp;=\\sum_{k=1}^n Fib_k\\times \\sum_{k’|d}\\mu(\\frac{d}{k’})\\times g(d)\\\\&amp;=\\sum_{k=1}^n Fib_k\\times \\sum_{k’|d}\\mu(\\frac{d}{k’})\\times \\lfloor\\frac{n}{d}\\rfloor\\lfloor\\frac{m}{d}\\rfloor\\end{align*}$$然后上板子吧。 latex挂了大家自求多福吧 Code1234567891011121314151617181920212223242526272829303132333435363738394041#define REP(i, s, e) for (register int i = s; i &lt;= e ;i++)#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2e6 + 10, MOD = 1e9 + 7;int m, n, k;bitset &lt;maxn&gt; notprime;int p[maxn], x[maxn], p_cnt;int fib[maxn], u[maxn], ans;inline int mod(int x) {return x &gt;= MOD ? x - MOD : x;}int main(){#ifndef ONLINE_JUDGE freopen(\"B.in\", \"r\", stdin); freopen(\"B.out\", \"w\", stdout);#endif cin &gt;&gt; n &gt;&gt; m; REP(i, 2, n) { if (!notprime[i]) x[p[++p_cnt] = i] = i; REP(j, 1, p_cnt) { if (i * p[j] &gt; n) break; notprime[i * p[j]] = 1; x[i * p[j]] = p[j]; if (i % p[j] == 0) break; } } fib[1] = 1; REP(i, 2, n) fib[i] = mod(fib[i-1] + fib[i-2]); u[1] = 1; REP(i, 2, n) if (x[i] ^ x[i / x[i]]) u[i] = -u[i / x[i]]; REP(i, 1, n) for (register int j = 1; i * j &lt;= n; j++) ans += 1ll * u[j] * (n / i / j) * (m / i / j) % MOD * fib[i] % MOD, ans %= MOD; cout &lt;&lt; (ans + MOD) % MOD &lt;&lt; endl; return 0;}","link":"/2019/07/19/胡闹-斐波那契/"},{"title":"胡闹 最小质因数","text":"题目大意求$[1,n]$中所有合数的最小质因数的$k$次方和，对$2^{64}$取模。 解析学习了学习了，这好像是一个经典套路吧。 就是说我们其实对于每一个素数$p$，只需要管$[1,\\frac{n}{p}]$这个区间。 那我们就可以考虑把所有的质数分成两部分。 小的部分直接暴力容斥（可以记忆化一下，具体用$unordered\\_map$当哈希表）。 大的部分$\\frac{n}{p}$就比较小了，可以直接筛一下。 $pb\\_ds​$的$gp\\_hash\\_table​$好像是假的？ Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#define REP(i, s, e) for (int i = s; i &lt;= e ;i++)#include &lt;bits/stdc++.h&gt;#define ll long long#define ull unsigned llusing namespace std;const ll K = 170;ull power_pow(ull a, int b){ ull ans = 1, base = a; while (b) { if (b &amp; 1) ans *= base; base *= base; b &gt;&gt;= 1; } return ans;}ll p[38000], p_cnt;bitset &lt;450000&gt; notprime;void init(int N){ REP(i, 2, N) { if (!notprime[i]) p[++p_cnt] = i; REP(j, 1, p_cnt) { if (i * p[j] &gt; N) break; notprime[i * p[j]] = 1; if (i % p[j] == 0) break; } }}ll n, k;ull ans;unordered_map &lt;ll, ll&gt; rem;#define not_same_pos(x, y) ((x) * n + y)//make sure no 冲突ll dfs(int pos, ll cur, int flag){ if (rem[not_same_pos(pos, cur)]) return rem[not_same_pos(pos, cur)] * flag; if (!pos) return cur * flag; ll ret = dfs(pos-1, cur, flag); if (p[pos] &lt;= cur) ret += dfs(pos-1, cur / p[pos], -flag); rem[not_same_pos(pos, cur)] = ret * flag; return ret;}ll cnt, N;bitset &lt;200000000&gt; w;signed main(){#ifndef ONLINE_JUDGE freopen(\"A.in\", \"r\", stdin); freopen(\"A.out\", \"w\", stdout);#endif cin &gt;&gt; n &gt;&gt; k; init(sqrt(n) + 1); REP(i, 1, min(p_cnt, K)) ans += (dfs(i - 1, n / p[i], 1)-1) * power_pow(p[i], k); if (p_cnt &gt; K) { cnt = N = n / p[K+1]; REP(i, 1, K) for (int j = 1; p[i] * j &lt;= N; j++) if (!w[p[i] * j]) { w[p[i] * j] = 1; cnt--; } REP(i, K + 1, p_cnt) { ans += (cnt-1) * power_pow(p[i], k); if (i &lt; p_cnt) { N = n / p[i+1]; for (int j = n / p[i]; j &gt; N; j--) cnt -= !w[j]; for (int j = 1; p[i] * j &lt;= N; j++) if (!w[p[i] * j]) { w[p[i] * j] = 1; cnt--; } } } } cout &lt;&lt; ans &lt;&lt; endl; return 0;}","link":"/2019/07/18/胡闹-最小质因数/"},{"title":"胡闹 文本编辑器","text":"题目大意你要支持以下几种操作： $I$ $x$ $a$ : 在第$x$个字符后面插入字符$a$ $D$ $x$ $y$：删除从$x$到$y$的这一段 $C$ $x$ $y$ $z$ ：复制从$x$到$y$这一段，粘贴到第$z$个字符后面 $P$ $x$ $y$ $z$ ：打印$x$次修改操作之前，从$y$到$z$这一段。其中，$x$不超过一个给定的数$M$。 保证输入的所有数在$int$范围内。 数据规模与约定对于$40%$的数据，总操作数和任意时刻字符串的长度在$1000$以内。 对于$100%$的数据，字符串的内容仅包含大小写字母和数字，初始字符串的长度和操作数不超过$100000$ ，$M\\le 1000$ 。 解析就是说用一个$fhq​$来维护 然后可持久化一下，就是$split​$的时候新建结点。 有以下卡常技巧： 按秩合并（玄学） $inline，register​$ 输出的时候不中序遍历，一个一个往下找（玄学） 少传址 用返回$int$的$merge$而不用传址的$merge$ srand(咕咕咕) Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#define REP(i, s, e) for (int i = s; i &lt;= e ;i++)#include &lt;bits/stdc++.h&gt;using namespace std;const int maxnode = 8e7 + 10;struct node{ int l, r, s; char c;}t[maxnode];int cur;inline int newnode(char c){ ++cur; t[cur].l = t[cur].r = 0; t[cur].c = c;t[cur].s = 1; return cur;}inline int copy(int x){ t[++cur] = t[x]; return cur;}inline void pushup(int x) {t[x].s = t[t[x].l].s + t[t[x].r].s + 1;}inline void split(int x, int &amp;a, int &amp;b, int siz){ if (!x) a = b = 0; else if (t[t[x].l].s &gt;= siz) { b = copy(x); split(t[b].l, a, t[b].l, siz); pushup(b); } else { a = copy(x); split(t[a].r, t[a].r, b, siz - t[t[x].l].s - 1); pushup(a); }}inline int merge(int a, int b){ if (!a || !b) return a ^ b; register int z; if (t[a].s &lt; t[b].s) z = b, t[z].l = merge(a, t[z].l); else z = a, t[z].r = merge(t[z].r, b); pushup(z); return z;}int rt[100000 + 10], now;int n, m;char c;inline int read(){ c = getchar(); while (!isdigit(c)) c = getchar(); int ans(0); while (isdigit(c)) ans = (ans &lt;&lt; 1) + (ans &lt;&lt; 3) + (c &amp; 15), c = getchar(); return ans;}inline void output(int _){ if (!_) return; output(t[_].l); putchar(t[_].c); output(t[_].r);}char ssr[10], s[100000 + 10];inline int build(int l, int r){ if (l &gt; r) return 0; int mid = l + r &gt;&gt; 1; int p = newnode(s[mid]); t[p].l = build(l, mid - 1); t[p].r = build(mid + 1, r); pushup(p); return p;}inline char query(int p, int k){ while (1) { if (t[t[p].l].s + 1 == k) return t[p].c; if (t[t[p].l].s + 1 &lt; k) k -= t[t[p].l].s + 1, p = t[p].r; else p = t[p].l; }}int pos, l, r, ccc, x, y, z;int main(){#ifndef ONLINE_JUDGE freopen(\"B.in\", \"r\", stdin); freopen(\"B.out\", \"w\", stdout);#endif t[0] = (node){0,0,0,'\\0'}; read(); scanf(\"%s\", s + 1); rt[0] = build(1, strlen(s + 1)); while (scanf(\"%s\", ssr) != EOF) if (ssr[0] == 'I') { pos = read(); scanf(\"%s\", ssr); ++now; x = y = 0; split(rt[now-1], x, y, pos); rt[now] = merge(merge(x, newnode(ssr[0])), y); } else if (ssr[0] == 'D') { l = read(), r = read(); ++now; x = y = z = 0; split(rt[now-1], x, y, l - 1); split(y, y, z, r - l + 1); rt[now] = merge(x, z); } else if (ssr[0] == 'C') { l = read(), r = read(), pos = read(); ++now; x = y = z = 0; split(rt[now-1], x, y, l - 1); split(y, y, z, r - l + 1); split(rt[now-1], x, z, pos); rt[now] = merge(merge(x, y), z); } else { ccc = read(), l = read(), r = read(); REP(i, l, r) putchar(query(rt[now-ccc], i)); putchar(10); } return 0;}","link":"/2019/07/17/胡闹-文本编辑器/"},{"title":"胡闹 多重集合问题","text":"题目大意维护一颗树，兹磁以下操作： 向以$v$为根的子树的所有节点各插入$k$个数$z$（相当于每个节点存了一些数） 询问某个节点$v$中有多少个数$x\\ xor\\ y\\le z$，其中$y,z$是给出的 把整棵树的根换成某一个节点$v$ $n,m\\le 140000$ 解析首先考虑查询假设我们现在有一些数，然后查询有多少个异或上$y$不大于$z$ 我们考虑把这些数建一个二进制的$Trie$。 考虑$z$的最高位，如果是$1$，那么就可以把$0$的$cnt$全部加进贡献。 如果是$0$，只能走到$0$。 这样每一位算一下就行。 接着考虑插入对于一个子树的话，就用树链剖分的方法存$dfn$，然后映射出来就是一段区间。 这样的话直接$Trie$和线段树套一下就可以了。 最后考虑换根换根的话，影响的只是子树的区间。 判一下根在不在区间内就可以了。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191#define REP(i, s, e) for (int i = s ; i &lt;= e; i++)#define DREP(i, s, e) for (int i = s ; i &gt;= e; i--)#define DEBUG fprintf(stderr, \"Passing [%s] in Line %d\\n\", __FUNCTION__, __LINE__)#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int maxn = 140000 + 10, maxm = 140000 + 10;int now = 1, root;int bg[maxn], ne[maxn &lt;&lt; 1], to[maxn &lt;&lt; 1], e = 1;void add(int x, int y){ e++; to[e] = y; ne[e] = bg[x]; bg[x] = e;}int fa[maxn], top[maxn], siz[maxn], depth[maxn], hvy[maxn];int dfn[maxn], bac[maxn], dfs_clock;void dfs1(int x){ siz[x] = 1; for (int i = bg[x]; i ; i = ne[i]) if (to[i] ^ fa[x]) { fa[to[i]] = x; depth[to[i]] = depth[x] + 1; dfs1(to[i]); siz[x] += siz[to[i]]; if (siz[to[i]] &gt; siz[hvy[x]]) hvy[x] = to[i]; }}void dfs2(int x, int y){ top[x] = y; dfn[x] = ++dfs_clock; if (hvy[x]) dfs2(hvy[x], y); for (int i = bg[x]; i ; i = ne[i]) if (to[i] ^ hvy[x] &amp;&amp; to[i] ^ fa[x]) dfs2(to[i], to[i]); bac[x] = dfs_clock;}int find(int x, int y){ while (1) { if (top[x] == top[y]) return hvy[y]; if (fa[top[x]] == y) return top[x]; x = fa[top[x]]; }}struct node{ int cnt; node *ls, *rs;}pool[55555555], *null, *node_cur = pool;node* newnode(){ node_cur -&gt; ls = node_cur -&gt; rs = null; return node_cur++;}#define mid (l + r &gt;&gt; 1)#define lson p -&gt; ls, l, mid#define rson p -&gt; rs, mid + 1, rvoid update(node *&amp;p, int l, int r, int pos, int val){ if (p == null) p = newnode(); p -&gt; cnt += val; if (l == r) return; if (pos &lt;= mid) update(lson, pos, val); else update(rson, pos, val);}int query(node *p, int l, int r, int pos){ if (p == null) return 0; if (l == r) return p -&gt; cnt; if (pos &gt; mid) return p -&gt; ls -&gt; cnt + query(rson, pos); else return query(lson, pos);}struct Trie{ node *t; Trie *ch[2];}t[4444444], *pt = t + 1;int ans[maxm];struct Query{ int id, y, z, ne; Query(){} Query(int _id, int _y, int _z, int _ne) : id(_id), y(_y), z(_z), ne(_ne) {} void query() { Trie* p = t; DREP(i, 29, 0) { if (z &gt;&gt; i &amp; 1) if (p -&gt; ch[((z^y)&gt;&gt;i&amp;1) ^ 1]) ans[id] += ::query(p -&gt; ch[((z^y)&gt;&gt;i&amp;1) ^ 1] -&gt; t, 1, now, id); p = p -&gt; ch[(z^y)&gt;&gt;i&amp;1]; if (!p) return; } ans[id] += ::query(p -&gt; t, 1, now, id); }}q[288888];int pq = 144444;void insert(int v, int id, int y, int z){ q[pq] = Query(id, y, z, q[v].ne); q[v].ne = pq++;}struct opt{ int t, k, x, v; opt(){} opt(int _t, int _k, int _x, int _v) : t(_t), k(_k), x(_x), v(_v) {} void modify() { Trie* p = ::t; DREP(l, 29, 0) { if (!p -&gt; ch[x &gt;&gt; l &amp; 1]) pt -&gt; t = newnode(), p -&gt; ch[x &gt;&gt; l &amp; 1] = pt++; p = p -&gt; ch[x &gt;&gt; l &amp; 1]; update(p -&gt; t, 1, now, t, k); } } bool operator &lt; (opt B) const {return v &lt; B.v;}}op[433333];int qcnt, Cur = 1;int m, n;signed main(){#ifndef ONLINE_JUDGE freopen(\"B.in\", \"r\", stdin); freopen(\"B.out\", \"w\", stdout);#endif cin &gt;&gt; n; REP(i, 2, n) { int x, y; scanf(\"%lld%lld\", &amp;x, &amp;y); add(x, y);add(y, x); } dfs1(1); dfs2(1, 1); null = pool + 55555500; t -&gt; t = newnode(); cin &gt;&gt; m; REP(i, 1, m) { int Opt;scanf(\"%lld\", &amp;Opt); if (Opt == 1) { int v, x, k; scanf(\"%lld%lld%lld\", &amp;v, &amp;x, &amp;k); if (dfn[v] &gt;= dfn[root] || dfn[root] &gt; bac[v]) if (v == root) op[++qcnt] = opt(now, k, x, 1); else { op[++qcnt] = opt(now, k, x, dfn[v]); op[++qcnt] = opt(now, -k, x, bac[v] + 1); } else { int temp = find(root, v); op[++qcnt] = opt(now, k, x, 1); op[++qcnt] = opt(now, -k, x, dfn[temp]); op[++qcnt] = opt(now, k, x, bac[temp] + 1); } } else if (Opt == 2) { int v, y, z; scanf(\"%lld%lld%lld\", &amp;v, &amp;y, &amp;z); insert(dfn[v], now++, y, z); } else scanf(\"%lld\", &amp;root); } sort(op + 1, op + qcnt + 1); REP(i, 1, n) { while (op[Cur].v == i) op[Cur++].modify(); for (int p = q[i].ne; p ; p = q[p].ne) q[p].query(); } REP(i, 1, now - 1) printf(\"%lld\\n\", ans[i]); return 0;}","link":"/2019/07/16/胡闹-多重集合问题/"},{"title":"模板 三维偏序","text":"传送门 题目大意空间内有$n$个点$(x_i,y_i,z_i)$。定义$f(i)=\\sum_{j=1}^n [x_j\\le x_i, y_j\\le x_j, z_j\\le z_i, i \\not=j]$。求$f(i),i\\in[0,n)$。 解法首先可以把所有的点按第一维排序。然后对于第二维，对与所有第二维大于等于这个点的位置记录存在一个这个点的第三维。然后就可以简单地用平衡树统计第三维得出答案了。第二维的话就可以简单的用一下树状数组搞一搞。 由于题目中可以大于等于，那么我们把所有第一维相同的全部记录完再算它们的答案。具体看代码喽。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#define DREP(i, s, e) for(int i = s; i &gt;= e ;i--)#define REP(i, s, e) for(int i = s; i &lt;= e ;i++)#define DEBUG fprintf(stderr, \"Passing [%s] in Line %d\\n\", __FUNCTION__, __LINE__)#define chkmax(a, b) a = max(a, b)#define chkmin(a, b) a = min(a, b)#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1000000 + 10, maxk = 2000000;template &lt;typename T&gt; inline T read(){ T ans(0), p(1); char c = getchar(); while (!isdigit(c)) { if (c == '-') p = -1; c = getchar(); } while (isdigit(c)) { ans = ans * 10 + c - 48; c = getchar(); } return ans * p;}int n, k;struct flower{ int s, c, m, id; flower(){} flower(int _s, int _c, int _m, int _id) : s(_s), c(_c), m(_m), id(_id){}}f[maxn];bool cmp(flower A, flower B) {return A.s &lt; B.s;}vector &lt;int&gt; s[maxn];void update(int c, int m){ while (c &lt;= k) { s[c].insert(lower_bound(s[c].begin(), s[c].end(), m), m); c += c &amp; -c; } // REP(i, c, cmax)s[i].insert(lower_bound(s[i].begin(), s[i].end(), m), m);}int ans[maxn];int query(int c, int m){ int res = 0; while (c &gt; 0) { res += lower_bound(s[c].begin(), s[c].end(), m+1) - s[c].begin(); c -= c &amp; -c; } return res-1;}int cnt[maxn];int main(){#ifdef CraZYali freopen(\"B.in\", \"r\", stdin); freopen(\"B.out\", \"w\", stdout); freopen(\"B.err\", \"w\", stderr);#endif cin &gt;&gt; n &gt;&gt; k; REP(i, 1, n) { int s(read&lt;int&gt;()), c(read&lt;int&gt;()), m(read&lt;int&gt;()); f[i] = flower(s, c, m, i); } sort(f + 1, f + 1 + n, cmp); // REP(i, 1, n) printf(\"%d %d %d %d\\n\", f[i].s, f[i].c, f[i].m, f[i].id); int last = 1; REP(i, 1, n) { if (i &gt; 1 &amp;&amp; f[i].s ^ f[i-1].s) { REP(j, last, i-1) cnt[ans[f[j].id] = query(f[j].c, f[j].m)]++;//, puts(\"----\"), cerr &lt;&lt; f[i].id &lt;&lt; ' ' &lt;&lt; ans[f[i].id] &lt;&lt; endl; last = i; } update(f[i].c, f[i].m); } REP(i, last, n) cnt[ans[f[i].id] = query(f[i].c, f[i].m)]++;//, puts(\"----\"), cerr &lt;&lt; f[i].id &lt;&lt; ' ' &lt;&lt; ans[f[i].id] &lt;&lt; endl; REP(i, 0, n-1) printf(\"%d\\n\", cnt[i]); // REP(i, 1, n) fprintf(stderr, \"%d\\n\", ans[i]); return 0;}","link":"/2019/07/07/模板-三维偏序/"},{"title":"Luogu 2042 [NOI2005 维护数列]","text":"传送门工业题，爽歪歪。 题目大意 解法维护一下区间和$sum$，从左端点开始的最大子段和$lmax$，以右端点结束的最大子段和$rmax$。$pushup$可能挺简单的。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240#define REP(i, s, e) for (int i = s; i &lt;= e; i++)#define DREP(i, s, e) for (int i = s; i &gt;= e; i--)#define DEBUG fprintf(stderr, \"Passing [%s] in Line %lld\\n\", __FUNCTION__, __LINE__)#define chkmax(a, b) a = max(a, (b))#define chkmin(a, b) a = min(a, (b))#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int maxn = 500000 + 10, inf = 1ll&lt;&lt;40;template &lt;typename T&gt; T read(){ T ans(0), flag(1); char c(getchar()); while (!isdigit(c)) { if (c == '-') flag = -1; c = getchar(); } while (isdigit(c)) { ans = ans * 10 + c - 48; c = getchar(); } return ans * flag;}void file(string s){ freopen((s + \".in\").c_str(), \"r\", stdin); freopen((s + \".out\").c_str(), \"w\", stdout); freopen((s + \".err\").c_str(), \"w\", stderr);}struct node{ int l, r, s, order, val, sum, lmax, rmax, max_sum, tag_reverse, tag_same; bool need; node() : l(0), r(0), s(0), order(0), val(0), sum(0), lmax(0), rmax(0), max_sum(0), tag_reverse(0), tag_same(0), need(0) {} node(int _val) : l(0), r(0), s(1), order(rand()), val(_val), sum(_val), lmax(_val), rmax(_val), max_sum(_val), tag_reverse(0), need(0){};}t[maxn];int s[maxn], top, root;int create(int val){ int id = s[top--]; t[id] = node(val); return id;}void recycle(int x) {s[++top] = x;}#define max3(x, y, z) max(max(x, y), z)void same(int x, int v){ if (!x) return; t[x].tag_same = v; t[x].need = 1; t[x].val = v; t[x].sum = v * t[x].s; if (v &gt;= 0) t[x].lmax = t[x].rmax = t[x].max_sum = t[x].sum; else t[x].lmax = t[x].rmax = t[x].max_sum = v;}void pushdown(int x){ if (!x) return; t[0].lmax=t[0].rmax=t[0].max_sum=-1e9; int &amp;l(t[x].l), &amp;r(t[x].r); if (t[x].tag_reverse) { t[x].tag_reverse = 0; t[l].tag_reverse ^= 1; t[r].tag_reverse ^= 1; swap(l, r); swap(t[x].lmax, t[x].rmax); } if (t[x].need) { if (l) same(l, t[x].tag_same); if (r) same(r, t[x].tag_same); t[x].need = 0; }}void pushup(int x){ if (!x) return; int l = t[x].l, r = t[x].r; if(l) pushdown(l); if(r) pushdown(r); t[x].s = t[l].s + t[r].s + 1; t[x].sum = t[l].sum + t[r].sum + t[x].val; t[x].lmax = max(t[l].lmax, t[l].sum + max(t[r].lmax, 0ll) + t[x].val); t[x].rmax = max(t[r].rmax, t[r].sum + max(t[l].rmax, 0ll) + t[x].val); t[x].max_sum = max3( t[l].max_sum, t[r].max_sum, max(t[l].rmax, 0ll) + t[x].val + max(t[r].lmax, 0ll));}void merge(int &amp;x, int a, int b){ if (!a || !b) x = a + b; else { if (t[a].order &gt; t[b].order) { pushdown(b); merge(t[x = b].l, a, t[b].l); } else { pushdown(a); merge(t[x = a].r, t[a].r, b); } pushup(x); }}void split(int x, int &amp;a, int &amp;b, int siz){ if (!x) a = b = 0; else { pushdown(x); if (t[t[x].l].s &gt;= siz) split(t[b = x].l, a, t[x].l, siz); else split(t[a = x].r, t[x].r, b, siz - t[t[x].l].s - 1); pushup(x); }}int GET(int pos){ int x(0), y(0), z(0); split(root, x, y, pos - 1); split(y, y, z, 1); int ans = t[y].val; merge(y, y, z); merge(root, x, y); return ans;}void INSERT(int pos, int a[], int len){ int x(0), y(0); split(root, x, y, pos); REP(i, 1, len) merge(x, x, create(a[i])); merge(root, x, y);}void del(int y){ if (!y) return; del(t[y].l); del(t[y].r); recycle(y);}void DELETE(int pos, int tot){ int x(0), y(0), z(0); split(root, x, y, pos - 1); split(y, y, z, tot); merge(root, x, z); del(y);}void MAKE_SAME(int pos, int tot, int c){ int x(0), y(0), z(0); split(root, x, y, pos - 1); split(y, y, z, tot); same(y, c); merge(y, y, z); merge(root, x, y);}void REVERSE(int pos, int tot){ int x(0), y(0), z(0); split(root, x, y, pos - 1); split(y, y, z, tot); t[y].tag_reverse ^= 1; merge(y, y, z); merge(root, x, y);}int GET_SUM(int pos, int tot){ int x(0), y(0), z(0); split(root, x, y, pos - 1); split(y, y, z, tot); int ans = t[y].sum; merge(y, y, z); merge(root, x, y); return ans;}void PUSH_BACK(int val){ int z(create(val)); merge(root, root, z);}int m, n, a[maxn];char ss[20];signed main(){#ifdef CraZYali file(\"2042\");#endif srand((unsigned long long)new char); top = 500000; REP(i, 1, top) s[i] = i; cin &gt;&gt; n &gt;&gt; m; REP(i, 1, n) PUSH_BACK(read&lt;int&gt;()); while (m--) { scanf(\"%s\", ss + 1); if (ss[1] == 'I') { int pos(read&lt;int&gt;()), tot(read&lt;int&gt;()); REP(i, 1, tot) a[i] = read&lt;int&gt;(); INSERT(pos, a, tot); n += tot; } else if (ss[1] == 'D') { int pos(read&lt;int&gt;()), tot(read&lt;int&gt;()); DELETE(pos, tot); n -= tot; } else if (ss[1] == 'M' &amp;&amp; ss[3] == 'K') { int pos(read&lt;int&gt;()), tot(read&lt;int&gt;()); MAKE_SAME(pos, tot, read&lt;int&gt;()); } else if (ss[1] == 'R') { int pos(read&lt;int&gt;()), tot(read&lt;int&gt;()); REVERSE(pos, tot); } else if (ss[1] == 'G') { int pos(read&lt;int&gt;()), tot(read&lt;int&gt;()); printf(\"%lld\\n\", GET_SUM(pos, tot)); } else printf(\"%lld\\n\", t[root].max_sum); // REP(i, 1, n) GET(i); } return 0;}","link":"/2019/07/07/Luogu-2042-NOI2005-维护数列/"},{"title":"Luogu 4197 [ONTAK2010 Peaks]","text":"传送门垃圾BZOJ，又过不了我的大常数。 题目大意给你一个$N\\le 10^5$个点$M\\le 5\\times 10^5$条边的无向图，每条边有边权，每个点有点权。每次给你一组$v,x,k$，询问从$v$开始经过不超过$x$的路可以走到的所有点中的第$k$大。无解输出$-1$。 解析显然这个东西是在最小生成树上跑。这个不超过$x$的东西有一类方法。这个东西叫做Kruskal重构树。 Kruskal重构树我们考虑把边改成点。还是Kruskal求最小生成树的过程，但是我们“不加边”。方便表达，下面说的都是代表了联通块的节点。具体来说，假设我们现在要吧$u,v$之间权值为$w$的边弄到最小生成树中去。那么我们就new一个$fa$，让这个$fa$的权值为$w$，然后这个$fa$向$u,v$连边。容易发现，这样我们就会new出一颗新树来，这棵树就是Kruskal重构树。 那么这棵树有两个非常好的性质： 原生成树的节点都是叶子节点（显然） 非叶子节点的权值一定不超过其父亲的权值（按Kruskal的顺序加边，自然后来的边权值不小于先来的边）所以说，从一个点出发，只要找到它的权值不超过$x$最老祖先，然后以它为根的子树的所有叶子节点就都可以到了。 这题要求$kth$，套一个主席树就可以啦。细节稍微注意一下。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169#define REP(i, s, e) for (int i = s; i &lt;= e; i++)#define DREP(i, s, e) for (int i = s; i &gt;= e; i--)#define DEBUG fprintf(stderr, \"Passing [%s] in Line %d\\n\", __FUNCTION__, __LINE__)#define chkmax(a, b) a = max(a, (b))#define chkmin(a, b) a = min(a, (b))#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;queue&gt;using namespace std;const int maxn = 1e5 + 10, maxm = 5e5 + 10, n_log_n = 3600000;int bg[maxn &lt;&lt; 1], to[maxm], ne[maxm], e;inline void add(int x, int y){ e++; to[e] = y; ne[e] = bg[x]; bg[x] = e;}int fa[maxn &lt;&lt; 1];int find(int x) {return fa[x] == x ? fa[x] : fa[x] = find(fa[x]);}void file(string s){ freopen((s + \".in\").c_str(), \"r\", stdin); freopen((s + \".out\").c_str(), \"w\", stdout);}int n, m, q, cur, M;int val[maxn &lt;&lt; 1];struct Edge{ int x, y, z; Edge() {} Edge(int _x, int _y, int _z) : x(_x), y(_y), z(_z) {}}E[maxm];bool cmp(Edge A, Edge B) {return A.z &lt; B.z;}int N, grand[maxn &lt;&lt; 1][25], LOG, Left[maxn &lt;&lt; 1], Right[maxn &lt;&lt; 1];int dfn[maxn], dfs_clock, vv[maxn];void prepare(int x){ if (x &lt;= n) vv[Left[x] = Right[x] = dfn[x] = ++dfs_clock] = val[x]; bool flag = 0; for (int i = bg[x]; i ; i = ne[i]) if (to[i] ^ grand[x][0]) { grand[to[i]][0] = x; prepare(to[i]); if (x &gt; n) if (!flag) {Left[x] = Left[to[i]];Right[x] = Right[to[i]];flag = 1;} else { chkmin(Left[x], Left[to[i]]); chkmax(Right[x], Right[to[i]]); } }}void output(int x){ for (int i = bg[x]; i ; i = ne[i]) if (to[i] ^ grand[x][0]) { printf(\"%d %d\\n\", x, to[i] &lt;= n&amp;&amp;0 ? dfn[to[i]] : to[i]); output(to[i]); }}int a[maxn], b[maxn];int rt[n_log_n], ls[n_log_n], rs[n_log_n], sum[n_log_n], nd_cur;#define mid (l + r &gt;&gt; 1)#define lson ls[p], l, mid#define rson rs[p], mid + 1, rvoid build(int pre, int &amp;p, int l, int r, int pos){ p = ++nd_cur; ls[p] = ls[pre]; rs[p] = rs[pre]; sum[p] = sum[pre] + 1; if (l == r) return; if (pos &lt;= mid) build(ls[pre], lson, pos); else build(rs[pre], rson, pos);}int query(int u, int v, int l, int r, int k){ if (l &gt;= r) return l; int x = sum[ls[v]] - sum[ls[u]]; if (x &lt; k) return query(rs[u], rs[v], mid + 1, r, k - x); else return query(ls[u], ls[v], l, mid, k);}int main(){#ifdef CraZYali file(\"4197\");#endif cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;cur = n; REP(i, 1, n) scanf(\"%d\", val + i); REP(i, 1, n * 2) fa[i] = i; REP(i, 1, m) { int x, y, z; scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;z); E[i] = Edge(x, y, z); } sort(E + 1, E + 1 + m, cmp); int cnt = 0; REP(i, 1, m) { int x(find(E[i].x)), y(find(E[i].y)); if (x ^ y) { val[++cur] = E[i].z; add(cur, x); add(cur, y); fa[x] = fa[y] = cur; if (++cnt == n - 1) break; } } N = n + n - 1; prepare(cur); LOG = log2(N); REP(j, 1, LOG) REP(i, 1, N) grand[i][j] = grand[grand[i][j-1]][j-1]; // REP(i, n+1, N) // printf(\"%d %d %d\\n\", i, Left[i], Right[i]);// output(cur); REP(i, 1, n) a[i] = b[i] = vv[i];// al[dfn[i]]; sort(b + 1, b + 1 + n); M = unique(b + 1, b + 1 + n) - b - 1; REP(i, 1, n) build(rt[i-1], rt[i], 1, M, lower_bound(b + 1, b + 1 + M, a[i]) - b);// REP(i, 1, n) printf(\"%d%c\", dfn[i], i == n ? '\\n' : ' ' );// REP(i, 1, n) printf(\"%d%c\", vv[i], i == n ? '\\n' : ' ' );// REP(i, 1, n) printf(\"%d%c\", a[i], i == n ? '\\n' : ' ' );// REP(i, 1, M) printf(\"%d%c\", b[i], i == M ? '\\n' : ' ' );// REP(i, 1, n) printf(\"%d%c\", lower_bound(b+1,b+1+M,a[i])-b, i == n ? '\\n' : ' ' );// REP(i, 1, n)// REP(j, i, n)// REP(k, 1, j - i + 1)// printf(\"%d %d %d %d\\n\", i, j, k, b[query(T[i-1], T[j], 1, M, k)]); while (q--) { int v, x, k; scanf(\"%d%d%d\", &amp;v, &amp;x, &amp;k);// cout &lt;&lt; v &lt;&lt; \" -&gt; \"; DREP(i, LOG, 0) if (!grand[v][i]) continue; else if (val[grand[v][i]] &lt;= x) v = grand[v][i];// cout &lt;&lt; v &lt;&lt; \"\\n\";// cout &lt;&lt; Left[v] &lt;&lt; ' ' &lt;&lt; Right[v] &lt;&lt; endl; int len = Right[v] - Left[v] + 1; printf(\"%d\\n\", k &gt; len ? - 1 : b[query(rt[Left[v]-1], rt[Right[v]], 1, M, len - k + 1)]); } return 0;}","link":"/2019/07/02/Luogu-4197-ONTAK2010-Peaks/"},{"title":"Luogu 2444 [POI2000 病毒]","text":"传送门这题目很好骗分啊。 题目大意有一些由$0,1$构成的病毒代码，询问存不存在一个无限长的$01$代码不包含病毒代码。 解析建一个AC自动机出来。考虑一个普通的文本串匹配的情况，如果匹配不上的话就不会包含病毒代码。但是文本串是无限长的，那匹配不上就只能是指针在AC自动机上面的一个环上循环。所以我们知道存不存在一个不包含危险结点的环就可以啦。危险结点就是可以匹配上的结点，那么显然所有fail指向危险结点的结点和Trie上有结束标记的结点都是危险结点。这里找环很好找，由于fail只会指向比当前节点深度浅的结点，所以直接一遍dfs就可以了。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#define REP(i, s, e) for (int i = s; i &lt;= e; i++)#define DREP(i, s, e) for (int i = s; i &gt;= e; i--)#define DEBUG fprintf(stderr, \"Passing [%s] in Line %d\\n\", __FUNCTION__, __LINE__)#define chkmax(a, b) a = max(a, b)#define chkmin(a, b) a = min(a, b)#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;const int maxn = 2000 + 10, maxlen = 30000 + 10, sumS = maxlen;int ch[sumS][3], fail[sumS], rt, cur;bool End[sumS];void insert(char s[]){ int now = rt; for (int i = 1; s[i]; i++) now = !ch[now][s[i]] ? ch[now][s[i]] = ++cur : ch[now][s[i]]; End[now] = 1;}int q[sumS], head, tail;void build(){ head = 1; REP(i, 1, 2) if (ch[0][i]) q[++tail] = ch[0][i]; while (head &lt;= tail) { int x = q[head++]; if (End[fail[x]]) End[x] = 1; REP(i, 1, 2) if (ch[x][i]) fail[q[++tail] = ch[x][i]] = ch[fail[x]][i]; else ch[x][i] = ch[fail[x]][i]; }}bool vis[sumS], ins[sumS];void dfs(int x = rt){ if (ins[x]) {puts(\"TAK\");exit(0);} if (vis[x] || End[x]) return; vis[x] = ins[x] = 1; REP(i, 1, 2) if (ch[x][i]) dfs(ch[x][i]); ins[x] = 0;}int n;char s[maxlen];int main(){#ifdef CraZYali freopen(\"2444.in\", \"r\", stdin); freopen(\"2444.out\", \"w\", stdout);#endif cin &gt;&gt; n; while (n--) { scanf(\"%s\", s + 1); for (int i = 1; s[i]; i++) s[i] -= '0'-1; insert(s); } build();#ifdef CraZYali REP(i, 1, cur) printf(\"%d%c\", (int)fail[i], i == cur ? '\\n' : ' '); REP(i, 1, cur) printf(\"%d%c\", (int)End[i], i == cur ? '\\n' : ' ');#endif dfs(); puts(\"NIE\"); return 0;}","link":"/2019/04/02/Luogu-2444/"},{"title":"合集 斜率优化","text":"昨天晚上肝了几道斜率优化的题，这里一起把题解写了吧。 BZOJ 1096题目大意有$n\\le 10^6$个工厂，每个工厂的位置在$x_i$，有$p_i$个存货。可以在工厂处建造仓库，在第$i$个工厂建造仓库的花费是$c_i$。每个工厂的存货不能往编号小的仓库运东西。一个单位货物运送一个单位长度需要一个花费。求最小的总费用。 解析考虑dp。设$s1_i=\\sum_{k\\in[1,i]} p_k$，$s2_i=\\sum_{k\\in[1,i]} p_k\\times x_k$，那么我们可以推出这个方程：$$dp_i=min(dp_j + c_i + \\sum_{k\\in[j+1,i]}(x_i-x_j)\\times p_j)=min(dp_j+c_i-(s2_i-s2_j)+x_i\\times(s1_i-s1_j))$$套路一波，假设$k$比$j$优秀（$k&gt;j$），那么：$$dp_k+c_i-(s2_i-s2_k)+x_i\\times(s1_i-s1_k)&lt;dp_j+c_i-(s2_i-s2_j)+x_i\\times(s1_i-s1_j)$$随便推一下式子，应该就可以发现：$$dp_k-dp_j+s2_k-s2_j&lt;x_i\\times(s1_k-s1_j)$$$$\\frac{dp_k-dp_j+s2_k-s2_j}{s1_k-s1_j}&lt;x_i$$那么斜率就出来了，直接上套路板子就可以了。时间复杂度$O(n)$。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#define DREP(i, s, e) for(int i = s; i &gt;= e ;i--)#define REP(i, s, e) for(int i = s; i &lt;= e ;i++)#define DEBUG fprintf(stderr, \"Passing [%s] in Line %d\\n\", __FUNCTION__, __LINE__)#define chkmax(a, b) a = max(a, b)#define chkmin(a, b) a = min(a, b)#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;#define int long longconst int maxn = 1e6 + 10;template &lt;typename T&gt; inline T read(){ T ans(0), p(1); char c = getchar(); while (!isdigit(c)) { if (c == '-') p = -1; c = getchar(); } while (isdigit(c)) { ans = ans * 10 + c - 48; c = getchar(); } return ans * p;}int n, x[maxn], p[maxn], c[maxn], dp[maxn], s1[maxn], s2[maxn];int q[maxn], head, tail;double K(int k, int j) {return (s2[j] - s2[k] + dp[j] - dp[k]) * 1. / (s1[j] - s1[k]);}signed main(){#ifdef CraZYali freopen(\"1096.in\", \"r\", stdin); freopen(\"1096.out\", \"w\", stdout);#endif cin &gt;&gt; n; REP(i, 1, n) x[i] = read&lt;int&gt;(), p[i] = read&lt;int&gt;(), c[i] = read&lt;int&gt;(); REP(i, 1, n) s1[i] = s1[i-1] + p[i], s2[i] = s2[i-1] + x[i] * p[i]; REP(i, 1, n) { while (head &lt; tail &amp;&amp; K(q[head + 1], q[head]) &lt; x[i]) head++; dp[i] = dp[q[head]] + c[i] + x[i] * (s1[i-1] - s1[q[head]]) - (s2[i-1] - s2[q[head]]); while (head &lt; tail &amp;&amp; K(q[tail - 1], i) &lt; K(q[tail], q[tail - 1])) tail--; q[++tail] = i; } cout &lt;&lt; dp[n] &lt;&lt; endl; return 0;} BZOJ 1911题目大意一个部队中有$n\\le 10^6$个人，每个人的战斗力为$x_i$。假设一坨人的战斗力总和为$x$，那么他们最终的战斗力为$ax^2+bx+c$。一坨人的编号要连续，最大化最终的战斗力。 解析设$s_i=\\sum_{k\\in[1,i]} x_k$，则：$$dp_i=max(dp_j+a\\times(s_i-s_j)^2+b\\times(s_i-s_j)+c)$$套路：$$dp_k-dp_j&lt;a\\times(s_k-s_j)\\times(2s_i-s_k-s_j)+b(s_k-s_j)$$$$\\frac{\\frac{dp_k-dp_j}{s_k-s_j}-b}{a}+s_k+s_j&lt;2s_i$$然后上板子 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#define DREP(i, s, e) for(int i = s; i &gt;= e ;i--)#define REP(i, s, e) for(int i = s; i &lt;= e ;i++)#define DEBUG fprintf(stderr, \"Passing [%s] in Line %d\\n\", __FUNCTION__, __LINE__)#define chkmax(a, b) a = max(a, b)#define chkmin(a, b) a = min(a, b)#include &lt;iostream&gt;#include &lt;cstdio&gt;#define int long longusing namespace std;const int maxn = 1e6 + 10;template &lt;typename T&gt; inline T read(){ T ans(0), p(1); char c = getchar(); while (!isdigit(c)) { if (c == '-') p = -1; c = getchar(); } while (isdigit(c)) { ans = ans * 10 + c - 48; c = getchar(); } return ans * p;}int n, a, b, c, s[maxn], dp[maxn];int q[maxn], head, tail;double K(int k, int j) {return ((dp[k] - dp[j]) * 1. / (s[k] - s[j]) - b) / a + s[k] + s[j];}signed main(){#ifdef CraZYali freopen(\"1911.in\", \"r\", stdin); freopen(\"1911.out\", \"w\", stdout);#endif cin &gt;&gt; n &gt;&gt; a &gt;&gt; b &gt;&gt; c; REP(i, 1, n) { s[i] = s[i-1] + read&lt;int&gt;(); while (head &lt; tail &amp;&amp; K(q[head+1], q[head]) &lt; 2 * s[i]) head++; int ret = s[i] - s[q[head]]; dp[i] = dp[q[head]] + a * ret * ret + b * ret + c; while (head &lt; tail &amp;&amp; K(q[tail-1], i) &lt; K(q[tail-1], q[tail])) tail--; q[++tail] = i; } cout &lt;&lt; dp[n] &lt;&lt; endl; return 0;} BZOJ 4518题目大意由$n\\le 3000$条路$L_i$，分成$m$天走，最小化每天走的路程的方差。设方差为$v$，输出$v\\times m^2$。 解析我们设总路程为$sum$，第$i$天走的路程为$l_i$，那么我们推一下方差：要最小化答案，只要最小化$W=\\sum_{i\\in[1,m]}l_i^2$就可以了。设$dp_{i,cur}$表示已经$cur$天走了$i$段路的最小$W$，记$s_i=\\sum_{k\\in[1,m]}L_k$，我们可以写出如下方程：$$dp_{i,cur}=min(dp_{j,cur-1}+(s_i-s_j)^2)$$套路一波，设$a(x)=dp_{x,cur-1}$，然后设$k&gt;j$比$j$优秀，那么：$$a(k)+(s_i-s_k)^2&lt;a(j)+(s_i-s_j)^2$$$$a(k)-a(j)&lt;(2s_i-s_j-s_k)\\times(s_k-s_j)$$$$\\frac{a(k)-a(j)}{s_k-s_j}+s_j+s_k&lt;2s_i$$然后就可以套路上板子了。时间复杂度$O(n\\times m)$。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#define DREP(i, s, e) for(int i = s; i &gt;= e ;i--)#define REP(i, s, e) for(int i = s; i &lt;= e ;i++)#define DEBUG fprintf(stderr, \"Passing [%s] in Line %d\\n\", __FUNCTION__, __LINE__)#define chkmax(a, b) a = max(a, b)#define chkmin(a, b) a = min(a, b)#include &lt;iostream&gt;#include &lt;cstdio&gt;#define int long longusing namespace std;const int maxn = 3000 + 10, inf = 2e9;template &lt;typename T&gt; inline T read(){ T ans(0), p(1); char c = getchar(); while (!isdigit(c)) { if (c == '-') p = -1; c = getchar(); } while (isdigit(c)) { ans = ans * 10 + c - 48; c = getchar(); } return ans * p;}int n, m, l[maxn], s[maxn], a[maxn];int q[maxn], head, tail;int dp[maxn][2];bool cur;int A(int x) {return dp[x][cur ^ 1];}double K(int j, int k) {return (A(j) - A(k)) * 1. / (s[j] - s[k]) + s[j] + s[k];}signed main(){#ifdef CraZYali freopen(\"4518.in\", \"r\", stdin); freopen(\"4518.out\", \"w\", stdout);#endif cin &gt;&gt; n &gt;&gt; m; REP(i, 1, n) s[i] = s[i-1] + (a[i] = read&lt;int&gt;()); REP(i, 1, n) dp[i][cur ^ 1] = s[i] * s[i]; REP(L, 2, m) { q[head = tail = 1] = 0; REP(i, 1, n) { while (head &lt; tail &amp;&amp; K(q[head + 1], q[head]) &lt; 2 * s[i]) head++; dp[i][cur] = dp[q[head]][cur ^ 1] + (s[i] - s[q[head]]) * (s[i] - s[q[head]]); while (head &lt; tail &amp;&amp; K(i, q[tail - 1]) &lt; K(q[tail-1], q[tail])) tail--; q[++tail] = i; } cur ^= 1; } cout &lt;&lt; m * dp[n][cur ^ 1] - s[n] * s[n]; return 0;}","link":"/2019/03/30/合集-斜率优化/"},{"title":"模板 exCRT","text":"传送门Orz 小昊 题目大意求同余方程组的最小非负整数解。$$x\\equiv a_i(mod\\ b_i)$$ 解析这个东西的关键是合并同余方程。考虑两个方程：$$x\\equiv a_1(mod\\ b_1)$$$$x\\equiv a_2(mod\\ b_2)$$则可以设：$$x=k_1b_1+a_1=k_2b_2+a_2$$推导一下：$$b_1k_1+b_2\\times(-k_2)=a_2-a_1$$那么这就成了一个exgcd的形式了，显然有解的充要条件是$a_2-a_1\\mid gcd(b_1,b_2)$。然后我们惊奇的发现，合并之后求出$k_1$，只要$x\\equiv k_1b_1+a_1(mod\\ lcm(b_1, b_2))$，就可以满足上面两个式子了。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#define REP(i, s, e) for (int i = s; i &lt;= e; i++)#define DREP(i, s, e) for (int i = s; i &gt;= e; i--)#define DEBUG fprintf(stderr, \"Passing [%s] in Line %d\\n\", __FUNCTION__, __LINE__)#define chkmax(a, b) a = max(a, b)#define chkmin(a, b) a = min(a, b)#include &lt;iostream&gt;#include &lt;cstdio&gt;#define int __int128using namespace std;template &lt;typename T&gt; T read(){ T ans = 0, p = 1; char c = getchar(); while (!isdigit(c)) { if (c == '-') p = -1; c = getchar(); } while (isdigit(c)) { ans = ans * 10 + c - 48; c = getchar(); } return ans * p;}void write(int x){ if (x &lt; 0) {putchar('-');write(-x);return;} if (x / 10) write(x / 10); putchar(x % 10 + '0');}int n, a1, b1, a2, b2, x;int exgcd(int a, int b, int &amp;x, int &amp;y){ if (!b) { x = 1; y = 0; return a; } int ans = exgcd(b, a % b, y, x); y -= a / b * x; return ans;}signed main(){#ifdef CraZYali freopen(\"4777-new-new.in\", \"r\", stdin); freopen(\"4777-new-new.out\", \"w\", stdout);#endif int n = read&lt;int&gt;(), b1 = read&lt;int&gt;(), a1 = read&lt;int&gt;(), lcm; x = a1; while (--n) { b2 = read&lt;int&gt;();a2 = read&lt;int&gt;(); int k, temp, g(exgcd(b1, b2, k, temp)); k *= (a2 - a1) / g; lcm = b1 * b2 / g; x = a1 = (b1 * k + a1) % lcm; b1 = lcm; } write((x + lcm) % lcm); return 0;}","link":"/2019/03/29/模板-exCRT/"},{"title":"BZOJ 4503 [两个串]","text":"传送门这真的是个黑科技了。以后忘了怎么写KMP就写FFT了。 题目大意给出两个长度不超过$10^5$的由小写英文字符构成的字符串$S,T$，询问$T$在$S$中出现了多少次及每次出现的位置（下标从$0$开始）。$T$中可能存在?通配符，可以匹配任何英文字符。 解析由于存在通配符，普通的KMP什么的是肯定不行了。考虑以下卷积：$$C_k=\\sum_{i+j=k}(S_i-T_j)^2\\times T_j$$如果$C_k=0$，那么只可能是对于每一个$j\\in[1,k-1]$，只有可能是$T_j=0$或者$S_{k-j}=T_k$。所以我们把$T$串翻转过来，并且将?的位置设为$0$，再做一下卷积。这个时候，如果存在一个$k\\ge m$并且$C_k=0$，那么$k-m$就是一个匹配上的位置了。怎么做卷积呢？我们拆一些式子，发现最终$C_k$变成了这个东西：$$C_k=\\sum_{i+j=k}(S_i^2)\\times T_j + \\sum_{i\\in[1,k]}T_j^3 -2\\sum_{i+j=k}S_i\\times(T_j^2)$$前一部分和最后一个部分直接是卷积，中间一个前缀和。时间复杂度$O(n log_2n)$，虽然比KMP慢蛮多，但是适用性更广，个人觉得也挺好理解的。注意FFT精度掉的不少，$eps$开到了$10^{-2}$。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#define DREP(i, s, e) for(int i = s; i &gt;= e ;i--)#define REP(i, s, e) for(int i = s; i &lt;= e ;i++)#define DEBUG fprintf(stderr, \"Passing [%s] in Line %d\\n\", __FUNCTION__, __LINE__)#define chkmax(a, b) a = max(a, b)#define chkmin(a, b) a = min(a, b)#include &lt;iostream&gt;#include &lt;complex&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#define double long doubleusing namespace std;const int maxn = 1e5 + 10, maxN = (1&lt;&lt;18) + 10;const double pi = acos(-1), eps = 1e-2;char s[maxn], t[maxn];int n, m, S[maxn], S2[maxn], T[maxn], T2[maxn], T3[maxn], sum[maxn];struct Complex{ double a, b; Complex(double _a = 0, double _b = 0) : a(_a), b(_b) {} Complex operator + (Complex B) {return Complex(a + B.a, b + B.b);} Complex operator - (Complex B) {return Complex(a - B.a, b - B.b);} Complex operator * (Complex B) {return Complex(a * B.a - b * B.b, a * B.b + b * B.a);} Complex operator *= (Complex B) {return *this = *this * B;}};int L, len, R[maxN];Complex F1[maxN], F2[maxN];void FFT(Complex a[], int flag){ REP(i, 0, len - 1) if (i &lt; R[i]) swap(a[i], a[R[i]]); for (int i = 1; i &lt; len; i &lt;&lt;= 1) { Complex T(cos(pi / i), flag * sin(pi / i)); for (int k = 0; k &lt; len; k += (i &lt;&lt; 1)) { Complex t(1, 0); for (int l = 0; l &lt; i; l++, t *= T) { Complex x(a[k+l]), y(t * a[k+l+i]); a[k + l] = x + y; a[k + l + i] = x - y; } } } if (flag &lt; 0) REP(i, 0, len - 1) a[i].a /= 4*len;}int ans[maxn];signed main(){#ifdef CraZYali freopen(\"4503.in\", \"r\", stdin); freopen(\"4503.out\", \"w\", stdout);#endif scanf(\"%s\\n%s\", s + 1, t + 1); n = strlen(s + 1); m = strlen(t + 1); REP(i, 1, n) { S[i] = s[i] - 'a' + 1; S2[i] = S[i] * S[i]; } REP(i, 1, m) { T[i] = t[m - i + 1] == '?' ? 0 : t[m - i + 1] - 'a' + 1; T2[i] = T[i] * T[i]; T3[i] = T2[i] * T[i]; sum[i] = sum[i-1] + T3[i]; } REP(i, m + 1, n) sum[i] = sum[i-1]; len = 1; while (len &lt;= n + n) len &lt;&lt;= 1; L = log2(len); REP(i, 0, len) R[i] = (R[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; L - 1); REP(i, 1, n) F1[i] = Complex(S2[i] + T[i], S2[i] - T[i]); REP(i, 1, n) F2[i] = Complex(S[i] + T2[i], S[i] - T2[i]); FFT(F1, 1);FFT(F2, 1); REP(i, 0, len-1) F1[i] *= F1[i], F2[i] *= F2[i]; FFT(F1, -1);FFT(F2, -1); REP(k, 1, n) { double c = F1[k+1].a + sum[k] - 2. * F2[k+1].a; if (k-m &gt;= 0 &amp;&amp; fabs(c)&lt;eps) ans[++ans[0]] = k-m; } cout &lt;&lt; ans[0] &lt;&lt; endl; REP(i, 1, ans[0])printf(\"%d\\n\", ans[i]); return 0;}","link":"/2019/03/29/BZOJ-4503/"},{"title":"BZOJ 3527 [ZJOI2014 力]","text":"传送门简直就是万有引力吧。 题目大意给出$n$个数$q_i$，定义： $F_i={j&lt;i}\\frac{q_iq_j}{(i-j)^2}-{j&gt;i}\\frac{q_iq_j}{(i-j)^2}$ $$E_i=\\frac{F_i}{q_i}​$$求$E_i​$ 解析先推一推式子。显然： $$E_i=\\sum_{j&lt;i}\\frac{q_j}{(i-j)^2}-\\sum_{j&gt;i}\\frac{q_j}{(i-j)^2}$$ 设$F[i]=q_i​$，$G[i]=\\frac{1}{i^2}​$，$GG[i]=G[n-i+1]​$，则：$$E_i=\\sum_{j&lt;i}F[j]G[i-j]-\\sum_{j&gt;i}F[j]G[j-i]=\\sum_{j&lt;i}F[j]G[i-j]-\\sum_{j&gt;i}F[j]GG[n-j+i+1]​$$。那这后面就是两个标准的卷积减一下了，FFT即可。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#define REP(i, s, e) for(int i = s; i &lt;= e ;i++)#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#define double long doubleusing namespace std;const int maxn = 100000 + 10;const double pi = acos(-1);struct Complex{ double a, b; Complex(double _a = 0, double _b = 0) : a(_a), b(_b) {} Complex operator + (Complex B) {return Complex(a + B.a, b + B.b);} Complex operator += (Complex B) {return *this = *this + B;} Complex operator - (Complex B) {return Complex(a - B.a, b - B.b);} Complex operator -= (Complex B) {return *this = *this - B;} Complex operator * (Complex B) {return Complex(a * B.a - b * B.b, a * B.b + b * B.a);} Complex operator *= (Complex B) {return *this = *this * B;}}F[maxn &lt;&lt; 2], G[maxn &lt;&lt; 2], GG[maxn &lt;&lt; 2];int n;double q[maxn];int len, L, R[maxn &lt;&lt; 2];void FFT(Complex a[], int flag){ REP(i, 1, len - 1) if (i &lt; R[i]) swap(a[i], a[R[i]]); for (int i = 1; i &lt; len; i &lt;&lt;= 1) { Complex T(cos(pi / i), flag * sin(pi / i)); for (int k = 0; k &lt; len; k += (i &lt;&lt; 1)) { Complex t(1); for (int l = 0; l &lt; i; l++, t *= T) { Complex x(a[k + l]), y(t * a[k + l + i]); a[k + l] = x + y; a[k + l + i] = x - y; } } } if (flag &lt; 0) REP(i, 0, len - 1) a[i].a /= len;}int main(){#ifdef CraZYali freopen(\"3527-new.in\", \"r\", stdin); freopen(\"3527-new.out\", \"w\", stdout);#endif cin &gt;&gt; n; REP(i, 1, n) scanf(\"%LF\", q + i); REP(i, 1, n) { F[i].a = q[i]; G[i].a = GG[n - i + 1].a = 1. / i / i; } len = 1; while (len &lt;= n + n) len &lt;&lt;= 1; L = log2(len); REP(i, 1, len) R[i] = (R[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; L - 1); FFT(F, 1);FFT(G, 1);FFT(GG, 1); REP(i, 0, len-1) G[i] *= F[i]; REP(i, 0, len-1) GG[i] *= F[i]; FFT(G, -1);FFT(GG, -1); REP(i, 1, n) printf(\"%.3LF\\n\", G[i].a - GG[n + i + 1].a); return 0;}","link":"/2019/03/28/BZOJ-3527/"},{"title":"BZOJ 4827 [HNOI2017 礼物]","text":"传送门我一定是脑子烧坏了，FFT都写不对。 题目大意给你两个长度为$n$的序列$a,b$，满足$a_i,b_i\\in [1,m]$，$a,b$中的数组可以循环（即可以把开头放到结尾，结尾放到开头）。 定义$a,b$之间的差异值为$$\\sum_{i\\in[1,n]} (a_i-b_i)^2$$。你可以选择一个常数$c$，使得$a$或$b$中的每个数加上$c$。 求最小差异值。$n\\le 50000,m\\le 100$ 解析显然可以先确定$c\\in[-m,m]$。 然后两个序列一起循环是没有意义的，只要循环一个就可以了。 计差异值为$D$，我们把式子拆一下。 令： 则： 所以，如果我们要让$D$尽量小的话，就要尽量让$k=\\sum_{i\\in[1,n]}a_ib_i$大。 等一下。 把$b$反转一下，$k$就变成$\\sum_{i\\in[1,n]}a_ib_{n-i+1}$，这不就是一个卷积形式吗？ 那把$a$倍长（把链变成环），再和$b$做一下$FFT$，再枚举一下最大值就可以了。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#define REP(i, s, e) for (int i = s; i &lt;= e; i++)#define DREP(i, s, e) for (int i = s; i &gt;= e; i--)#define DEBUG fprintf(stderr, \"Passing [%s] in Line %d\\n\", __FUNCTION__, __LINE__)#define chkmax(a, b) a = max(a, b)#define chkmin(a, b) a = min(a, b)#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#define double long double#define int long longusing namespace std;const int maxn = 50000 + 10 &lt;&lt; 1, inf = 1ll &lt;&lt; 60;const double pi = acos(-1);template &lt;typename T&gt; T read(){ T ans = 0, p = 1; char c = getchar(); while (!isdigit(c)) { if (c == '-') p = -1; c = getchar(); } while (isdigit(c)) { ans = ans * 10 + c - 48; c = getchar(); } return ans * p;}struct Complex{ double x, y; Complex(double _x = 0, double _y = 0) : x(_x), y(_y){} Complex operator + (Complex B) {return Complex(x + B.x, y + B.y);} Complex operator += (Complex B) {return *this = *this + B;} Complex operator - (Complex B) {return Complex(x - B.x, y - B.y);} Complex operator -= (Complex B) {return *this = *this - B;} Complex operator * (Complex B) {return Complex(x * B.x - y * B.y, x * B.y + y * B.x);} Complex operator *= (Complex B) {return *this = *this * B;}}F[3 * maxn], G[3 * maxn];int n, m, a[maxn], b[maxn];int R[maxn * 3], len, L;int static_sum, all_sum, ans = inf;void FFT(Complex *a, int flag){ REP(i, 0, len - 1) if (i &lt; R[i]) swap(a[i], a[R[i]]); for (int i = 1; i &lt; len; i &lt;&lt;= 1) { Complex T(cos(pi / i), flag * sin(pi / i)); for (int k = 0; k &lt; len; k += (i &lt;&lt; 1)) { Complex t(1, 0); for (int l = 0; l &lt; i; l++, t *= T) { Complex x = a[k + l], y = t * a[k + l + i]; a[k + l] = x + y; a[k + l + i] = x - y; } } } if (flag &lt; 0) REP(i, 0, len - 1) a[i].x = (int)(a[i].x / len + 0.5);}signed main(){#ifdef CraZYali freopen(\"4827.in\", \"r\", stdin); freopen(\"4827.out\", \"w\", stdout);#endif cin &gt;&gt; n &gt;&gt; m; REP(i, 1, n) a[i] = read&lt;int&gt;(); REP(i, 1, n) b[i] = read&lt;int&gt;(); REP(i, 1, n) static_sum += a[i] * a[i] + b[i] * b[i], all_sum += a[i] - b[i]; len = 1; while (len &lt;= n + n + n) len &lt;&lt;= 1; L = log2(len); REP(i, 0, len) R[i] = (R[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; L - 1); int l(1), r(n); while (l &lt; r) swap(b[l++], b[r--]); REP(i, 1, n) F[i].x = F[i + n].x = a[i]; REP(i, 1, n) G[i].x = b[i]; FFT(F, 1); FFT(G, 1); REP(i, 0, len) F[i] *= G[i]; FFT(F, -1); REP(i, 1, n) REP(c, -m, m) chkmin(ans, static_sum + n * c * c + 2 * c * all_sum - 2 * (int)F[i+n].x); cout &lt;&lt; ans &lt;&lt; endl; return 0;}","link":"/2019/03/26/BZOJ-4827/"},{"title":"Luogu 3157 [CQOI2011 动态逆序对]","text":"传送门垃圾BZOJ，硬是过不了我的大常数。 题目大意给出一个$1$到$n$的排列$P$，依次删除$m$个数，问每次删除前整个序列的逆序对数。 解析普通不带删除的谁都会写吧，一棵树状数组完事。待删除的？我们又发现，只要维护区间内数字出现的次数就可以了。直接上一棵树状数组套权值线段树，完事。单次操作$O(log_2^2n)$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#define REP(i, s, e) for (int i = s; i &lt;= e; i++)#define DREP(i, s, e) for (int i = s; i &gt;= e; i--)#define DEBUG fprintf(stderr, \"Passing [%s] in Line %d\\n\", __FUNCTION__, __LINE__)#define chkmax(a, b) a = max(a, b)#define chkmin(a, b) a = min(a, b)#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;const int maxn = 100000 + 10;template &lt;typename T&gt; T read(){ T ans = 0, p = 1; char c = getchar(); while (!isdigit(c)) { if (c == '-') p = -1; c = getchar(); } while (isdigit(c)) { ans = ans * 10 + c - 48; c = getchar(); } return ans * p;}struct node *null;const int maxnode = 28000000;int rt[maxnode], ls[maxnode], rs[maxnode], sum[maxnode], cur, LL[30], RR[30];#define mid (l + r &gt;&gt; 1)#define lson ls[p], l, mid#define rson rs[p], mid + 1, rvoid update(int &amp;p, int l, int r, int pos, int num){ if (!p) p = ++cur; sum[p] += num; if (l == r) return; else if (pos &lt;= mid) update(lson, pos, num); else update(rson, pos, num);}int n, m, a[maxn], pos[maxn];long long ans;int query(int l, int r, int val, bool mode){ int lsz(0), rsz(0), s(0); for (int i = l-1; i &gt; 0; i -= i &amp; -i) LL[++lsz] = rt[i]; for (int i = r ; i &gt; 0; i -= i &amp; -i) RR[++rsz] = rt[i]; l = 1, r = n; while (l &lt; r) if (val &gt; mid) { if (mode) { REP(i, 1, lsz) s -= sum[ls[LL[i]]]; REP(i, 1, rsz) s += sum[ls[RR[i]]]; } REP(i, 1, lsz) LL[i] = rs[LL[i]]; REP(i, 1, rsz) RR[i] = rs[RR[i]]; l = mid + 1; } else { if (!mode) { REP(i, 1, lsz) s -= sum[rs[LL[i]]]; REP(i, 1, rsz) s += sum[rs[RR[i]]]; } REP(i, 1, lsz) LL[i] = ls[LL[i]]; REP(i, 1, rsz) RR[i] = ls[RR[i]]; r = mid ; } return s;}int main(){#ifdef CraZYali freopen(\"3157.in\", \"r\", stdin); freopen(\"3157.out\", \"w\", stdout);#endif cin &gt;&gt; n &gt;&gt; m; REP(i, 1, n) { pos[a[i] = read&lt;int&gt;()] = i; ans += 1ll * query(1, i-1, a[i], 0); for (int j = i; j &lt;= n; j += j &amp; -j) update(rt[j], 1, n, a[i], 1); } while (m --&gt; 0) { printf(\"%lld\\n\", ans); int x = read&lt;int&gt;(), p = pos[x]; ans -= query(1, p - 1, x, 0); ans -= query(p + 1, n, x, 1); for (int i = p; i &lt;= n; i += i &amp; -i) update(rt[i], 1, n, x, -1); } return 0;} P.S内存限制128MB是真的坑。之前用指针，直接new结点结果MLE。后来预先分配内存池，MLE。再后来把内存池改小，RE。我可去您的吧，一气之下吧指针改成普通数组，过了？垃圾题目，毁我青春。","link":"/2019/03/23/Luogu-3157/"},{"title":"BZOJ 1901（动态区间第K小）","text":"传送门树套树什么的真的头晕死了。 题目大意给你一个序列$a_{i\\in [1,n]}$，要求单点修改，区间询问第$k$小值。 解析如不没有修改，直接一棵主席树就可以了。有修改也没关系，整体二分就可以了。有修改的话，主席树肯定没办法了，因为它存的是前缀，修改的话时间直接GG。但是我们仍然可以运用主席树的思想。我们要做的，其实就是维护一个区间内的$cnt=[a_{i\\in [l,r]} \\le val]$，就可以查询排名、找到$k$大值了。那如果我们还是建出来$n$棵权值线段树，每次对操作暴力$O(n\\ log_2n)$的更新，就可以维护，但是显然时间GG。但是我们注意到一个事情，我们要做的东西类似下面的操作： 12345678910void update(int l, int r){ for (int i = l ; i &lt;= r; i++) tree_add(i);}int query(int l, int r){ int res = 0; for (int i = l ; i &lt;= r; i++) res += get_sum(i); return res;} 这个东西可以用什么操作？树状数组！如果我们采用类似主席树的方法，只是在权值线段树外面套一层树状数组，那我们单次操作的复杂度就成功成$O(n\\ log_2n)$降低到了可以接受的$O(log_2^2n)$了。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#define DREP(i, s, e) for(int i = s; i &gt;= e ;i--)#define REP(i, s, e) for(int i = s; i &lt;= e ;i++)#define DEBUG fprintf(stderr, \"Passing [%s] in Line %d\\n\", __FUNCTION__, __LINE__)#define chkmax(a, b) a = max(a, b)#define chkmin(a, b) a = min(a, b)#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e4 + 10, maxq = 1e4 + 10;template &lt;typename T&gt; inline T read(){ T ans(0), p(1); char c = getchar(); while (!isdigit(c)) { if (c == '-') p = -1; c = getchar(); } while (isdigit(c)) { ans = ans * 10 + c - 48; c = getchar(); } return ans * p;}int n, m, q, a[maxn], b[maxn + maxq];int to(int val) {return lower_bound(b + 1, b + 1 + m, val) - b;}bool type[maxq];int x[maxq], y[maxq], z[maxq];struct node *null;struct node{ node *ls, *rs; int sum; node() : ls(null), rs(null), sum(0) {}}*c[maxn];#define mid (l + r &gt;&gt; 1)void update(node *pre, node *&amp;p, int l, int r, int pos, int num){ node temp = *pre; p = new node(); p -&gt; ls = temp.ls; p -&gt; rs = temp.rs; p -&gt; sum = temp.sum + num; if (l == r) return; else if (pos &lt;= mid) update(temp.ls, p -&gt; ls, l, mid, pos, num); else update(temp.rs, p -&gt; rs, mid + 1, r, pos, num);}void add(int x, int pos, int num = 1){ while (x &lt;= n) { if (c[x] == NULL) c[x] = new node(); update(c[x], c[x], 1, m, pos, num); x += x &amp; -x; }}void update(int l, int r, int pos, int num = 1) {add(l, pos, num);add(r + 1, pos, num * -1);}int lsz, rsz;node *LLL[maxn], *RRR[maxn];int query(int l, int r, int k){ if (l == r) return l; int x = 0; REP(i, 1, rsz) x += RRR[i] -&gt; ls -&gt; sum; REP(i, 1, lsz) x -= LLL[i] -&gt; ls -&gt; sum; if (x &gt;= k) { REP(i, 1, lsz) LLL[i] = LLL[i] -&gt; ls; REP(i, 1, rsz) RRR[i] = RRR[i] -&gt; ls; return query(l, mid, k); } else { REP(i, 1, lsz) LLL[i] = LLL[i] -&gt; rs; REP(i, 1, rsz) RRR[i] = RRR[i] -&gt; rs; return query(mid + 1, r, k - x); }}int main(){#ifdef CraZYali freopen(\"1901-new.in\", \"r\", stdin); freopen(\"1901-new.out\", \"w\", stdout);#endif null = new node(); null -&gt; ls = null -&gt; rs = null;null -&gt; sum = 0; cin &gt;&gt; n &gt;&gt; q; REP(i, 1, n) a[i] = b[++m] = read&lt;int&gt;(); REP(i, 1, q) { char cc = getchar(); while (cc != 'Q' &amp;&amp; cc != 'C') cc = getchar(); x[i] = read&lt;int&gt;();y[i] = read&lt;int&gt;(); if (cc == 'Q') type[i] = 1, z[i] = read&lt;int&gt;(); else b[++m] = y[i]; } sort(b + 1, b + 1 + m); m = unique(b + 1, b + 1 + m) - b - 1; REP(i, 1, n) add(i, to(a[i])); REP(i, 1, q) if (type[i]) { lsz = rsz = 0; for (int now = x[i]-1; now &gt; 0;now -= (now &amp; -now)) LLL[++lsz] = c[now]; for (int now = y[i]; now &gt; 0;now -= (now &amp; -now)) RRR[++rsz] = c[now]; //提前提取需要查询的树状数组的结点 printf(\"%d\\n\", b[query(1, m, z[i])]); } else { add(x[i], to(a[x[i]]), -1); add(x[i], to(a[x[i]] = y[i])); } return 0;} P.S做题都做得感觉脑子有问题了。对于这种会让人脑子有问题的东西，有的时候不要想太多，直接把一些东西当成工具就好，不然真的头疼。","link":"/2019/03/22/BZOJ-1901（动态区间第K小）/"},{"title":"模板 静态区间第K小（主席树）","text":"传送门啊，推了一晚上，大概搞定了吧。 题目大意给定一个序列$a_{k\\in [1,n]}$，$q$次询问，每次询问$[l,r]$中第$K$小的数。 解析主席树定义有人说这就是可持久化线段树，没怎么懂这种说法。主席树其实就是一堆权值线段树，第$i$棵表示的是序列$a_{k\\in [1,i]}$的权值线段树。那这样不会超空间吗？其实不会，因为第$i$棵和第$i+1$棵权值线段树之间可能有很多公共结点。比如说${3,1,2,4,5}$这个主席树，建出来是这样的。 发现从第$i-1$棵加到第$i$棵时，只要管新加入的数$val$是应该划分到$[l,mid]$还是$[mid+1,r]$这个区间就好了。如果$val\\in [l,mid]$，那么当前结点的右儿子就和前一棵的右儿子完全相同，这时候递归处理它们的左儿子就行了。反之，如果$val\\in [mid+1,r]$，那么左儿子完全相同，递归右儿子就可以了。这样就可以共用结点了，那么动态开点就可以了。 性质由于保存的是区间的权值线段树，主席树上的数值具有区间可加性！这是一个非常好的性质，用两棵权值线段树的$query$值相减就可以方便我们在$O(log_2n)$的时间内查询一个$cnt=\\sum_{i\\in [l,r]} [a_i \\le val]$，方便查询一个数在区间内的排名（可能还要稍微修改一下，问题不大）。这就差不多了。时间复杂度应该是$O(n\\ log_2n)$的，空间复杂度动态开点。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#define DREP(i, s, e) for(int i = s; i &gt;= e ;i--)#define REP(i, s, e) for(int i = s; i &lt;= e ;i++)#define DEBUG fprintf(stderr, \"Passing [%s] in Line %d\\n\", __FUNCTION__, __LINE__)#define chkmax(a, b) a = max(a, b)#define chkmin(a, b) a = min(a, b)#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2e5 + 10;template &lt;typename T&gt; inline T read(){ T ans(0), p(1); char c = getchar(); while (!isdigit(c)) { if (c == '-') p = -1; c = getchar(); } while (isdigit(c)) { ans = ans * 10 + c - 48; c = getchar(); } return ans * p;}int a[maxn], b[maxn], n, m, q;#define mid (l + r &gt;&gt; 1)#define lson p -&gt; ls, l, mid#define rson p -&gt; rs, mid + 1, rstruct node *null;struct node{ node *ls, *rs;int sum; node() : ls(null), rs(null), sum(0){}}*rt[maxn];void build(node *pre, node *&amp;p, int l, int r, int val){ p = new node(); p -&gt; ls = pre -&gt; ls; p -&gt; rs = pre -&gt; rs; p -&gt; sum = pre -&gt; sum + 1; if (l &gt;= r) return; else if (val &lt;= mid) build(pre -&gt; ls, lson, val); else build(pre -&gt; rs, rson, val);}int query(node *u, node *v, int l, int r, int k){ if (l &gt;= r) return l; int x = v -&gt; ls -&gt; sum - u -&gt; ls -&gt; sum; if (x &lt; k) return query(u -&gt; rs, v -&gt; rs, mid + 1, r, k - x); else return query(u -&gt; ls, v -&gt; ls, l, mid, k);}int main(){#ifdef CraZYali freopen(\"3834-new-new.in\", \"r\", stdin); freopen(\"3834-new-new.out\", \"w\", stdout);#endif cin &gt;&gt; n &gt;&gt; q; REP(i, 1, n) b[i] = a[i] = read&lt;int&gt;(); sort(b + 1, b + 1 + n); m = unique(b + 1, b + 1 + n) - b - 1; rt[0] = null = new node(); null -&gt; ls = null;null -&gt; rs = null;null -&gt; sum = 0; REP(i, 1, n) { rt[i] = null; build(rt[i-1], rt[i], 1, m, lower_bound(b + 1, b + 1 + m, a[i]) - b); } while (q --&gt; 0) { int L = read&lt;int&gt;(), R = read&lt;int&gt;(), k = read&lt;int&gt;(); printf(\"%d\\n\", b[query(rt[L-1], rt[R], 1, m, k)]); } return 0;}","link":"/2019/03/21/模板-静态区间第K小（主席树）/"},{"title":"BZOJ 3110 [ZJOI2013 K大数查询]","text":"传送门哎呀这题刚了一上午没刚出来，下午发现少写$5$个字符，浑身难受。 题目大意有$N$个位置，$M$个操作。操作有$2$种： $1\\ a\\ b\\ c$ 在第$a$个位置到第$b$个位置，每个位置加入一个数$c$。 $2\\ a\\ b\\ c$ 询问从第$a$个位置到第$b$个位置，第$c$大的数是多少。 解析整体二分？早就弃坑了。我记得我之前的计划中有一个线段树套线段树来着，这个题就是一个树套树。外层搞一个权值线段树，内层套一个区间。 权值线段树定义 如图，这就是一个权值线段树，它对应的序列为${1,3,3,5,4,2}$。每个结点保存的信息有三个$[l,r],cnt$，意味着在原序列中，$cnt=\\sum_{i=1}^n [a_i \\in [l,r]]$。注意到两点： 权值线段树只保存数字的出现次数，不考虑序列的顺序。 一般来讲，权值线段树保存的序列值需要离散化（空间问题） 所以说，上面那颗线段树不开到$[1,6]$也没有关系，直接离散化（这个序列没必要）后开成$[1,5]$也可以。同样，如果序列是${1,2,5,4,3,3}$，权值线段树开成$[1,6]$，也会长成上图的样子。 找排名为$K$的数直接从根节点开始找，重复以下过程。 $K \\le now -&gt; LeftSon -&gt; cnt$$，说明这个数一定不超过当前区间最大值，那么$$now = now -&gt; LeftSon$$。 $K &gt; now -&gt; LeftSon -&gt; cnt$，说明这个数一定超过当前区间最大值，那么$K = K - now -&gt; LeftSon -&gt; cnt$，同时$now = now -&gt; RightSon$。 找到一个确定的数为止。 像$FHQ\\ TREAP$啊，还有一些数据结构都是这样找的。 权值线段树套区间差不多的东西，只是权值线段树里的东西从数变成了区间而已。内层套的区间，也就是每次加进来的值在那些地方。 标记永久化一个小小的技巧。因为结点都被拆开了，所以下传标记不太好办。怎么搞呢？不下传不就可以了吗，更新的时候一起更新，查询的时候不仅返回$sum$$，而且返回$$tag$$在区间的作用就可以了。没懂就看代码吧。 正题对于每个询问，先查找右边的总数$cnt$，如果右边总数大于等于$c$就在右子树查询第$c$大的，如果不够就在左子树查询第$c-cnt$大的。应该挺好懂的。最后，线段树动态开点。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#define REP(i, s, e) for (int i = s; i &lt;= e; i++)#define DREP(i, s, e) for (int i = s; i &gt;= e; i--)#define DEBUG fprintf(stderr, \"Passing [%s] in Line %d\\n\", __FUNCTION__, __LINE__)#define chkmax(a, b) a = max(a, b)#define chkmin(a, b) a = min(a, b)#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;template &lt;typename T&gt; T read(){ T ans = 0, p = 1; char c = getchar(); while (!isdigit(c)) { if (c == '-') p = -1; c = getchar(); } while (isdigit(c)) { ans = ans * 10 + c - 48; c = getchar(); } return ans * p;}#define mid (l + r &gt;&gt; 1)#define lson p -&gt; ls, l, mid#define rson p -&gt; rs, mid + 1, rint n, m;struct node_inside{ node_inside *ls, *rs; int sum, tag; node_inside() : sum(0), tag(0), ls(NULL), rs(NULL) {}};int query(node_inside *x, bool flag = 1) {return x != NULL ? x -&gt; sum * flag + x -&gt; tag * (flag ^ 1) : 0;}void update(node_inside *&amp;p, int l, int r, int L, int R){ if (p == NULL) p = new node_inside(); if (L == l &amp;&amp; r == R) p -&gt; tag++; else if (L &gt; mid) update(rson, L, R); else if (R &lt;= mid) update(lson, L, R); else { update(lson, L, mid); update(rson, mid + 1, R); } p -&gt; sum += R - L + 1;}int query(node_inside *&amp;p, int l, int r, int L, int R){ if (p == NULL) return 0; if (L == l &amp;&amp; r == R) return query(p); int res = (R - L + 1) * query(p, 0); if (R &lt;= mid) return query(lson, L, R) + res; else if (L &gt; mid) return query(rson, L, R) + res; else return query(lson, L, mid) + query(rson, mid + 1, R) + res;}struct node_outside{ node_inside *rt; node_outside *ls, *rs; node_outside() : ls(NULL), rs(NULL), rt(NULL){}};node_outside *T;void update(node_outside *&amp;p, int l, int r, int L, int R, int pos){ if (p == NULL) p = new node_outside(); update(p -&gt; rt, 1, n, L, R); if (l == r) return; if (pos &lt;= mid) update(lson, L, R, pos); else update(rson, L, R, pos);}int query(node_outside *&amp;p, int l, int r, int L, int R, int pos){ if (l == r) return l; int cnt = p -&gt; rs == NULL ? 0 : query(p -&gt; rs -&gt; rt, 1, n, L, R); if (cnt &gt;= pos) return query(rson, L, R, pos); else return query(lson, L, R, pos - cnt);}int main(){#ifdef CraZYali freopen(\"3110.in\", \"r\", stdin); freopen(\"3110.out\", \"w\", stdout);#endif cin &gt;&gt; n &gt;&gt; m; while (m --&gt; 0) { int opt(read&lt;int&gt;()), a(read&lt;int&gt;()), b(read&lt;int&gt;()), c(read&lt;int&gt;()); if (opt == 1) update(T, 1, n, a, b, c); else printf(\"%d\\n\", query(T, 1, n, a, b, c)); } return 0;}","link":"/2019/03/18/BZOJ-3110/"},{"title":"读入黑科技","text":"这里要Orz一下LK大佬~~ 很久以前，我听说过一个叫fread的东西 然而我并不会用！直到有一天，我打开大佬的博客 太强了！123456789101112131415161718#include&lt;****&gt;const int N=1&lt;&lt;27;//可以修改，表示输入文件不会超过的长度char buf[N],*inf=buf;int read(){//这是一个读不进负数的数字读入 int k=0; while(!isdigit(*inf))++inf; while(isdigit(*inf)){ k=k*10+(*inf-'0'); ++inf; } return k;}int main(){ //freopen(***); //开文件必须在fread前面 fread(buf, 1, N, stdin);//读入整个输入文件 ***** return 0;}","link":"/2017/01/01/读入黑科技/"}],"tags":[{"name":"容斥","slug":"容斥","link":"/tags/容斥/"},{"name":"树套树","slug":"树套树","link":"/tags/树套树/"},{"name":"高级数据结构","slug":"高级数据结构","link":"/tags/高级数据结构/"},{"name":"主席树","slug":"主席树","link":"/tags/主席树/"},{"name":"FFT、NTT","slug":"FFT、NTT","link":"/tags/FFT、NTT/"},{"name":"字符串","slug":"字符串","link":"/tags/字符串/"},{"name":"黑科技","slug":"黑科技","link":"/tags/黑科技/"},{"name":"WO YE BU HUI","slug":"WO-YE-BU-HUI","link":"/tags/WO-YE-BU-HUI/"},{"name":"技巧","slug":"技巧","link":"/tags/技巧/"},{"name":"网络流","slug":"网络流","link":"/tags/网络流/"},{"name":"二分图","slug":"二分图","link":"/tags/二分图/"},{"name":"Hash","slug":"Hash","link":"/tags/Hash/"},{"name":"平衡树","slug":"平衡树","link":"/tags/平衡树/"},{"name":"AC自动机","slug":"AC自动机","link":"/tags/AC自动机/"},{"name":"倍增","slug":"倍增","link":"/tags/倍增/"},{"name":"树上莫队","slug":"树上莫队","link":"/tags/树上莫队/"},{"name":"带修莫队","slug":"带修莫队","link":"/tags/带修莫队/"},{"name":"Kruskal重构树","slug":"Kruskal重构树","link":"/tags/Kruskal重构树/"},{"name":"SAM","slug":"SAM","link":"/tags/SAM/"},{"name":"数论","slug":"数论","link":"/tags/数论/"},{"name":"K-D Tree","slug":"K-D-Tree","link":"/tags/K-D-Tree/"},{"name":"卡常","slug":"卡常","link":"/tags/卡常/"},{"name":"坑","slug":"坑","link":"/tags/坑/"},{"name":"胡闹系列","slug":"胡闹系列","link":"/tags/胡闹系列/"},{"name":"计算几何","slug":"计算几何","link":"/tags/计算几何/"},{"name":"excrt","slug":"excrt","link":"/tags/excrt/"},{"name":"斜率优化","slug":"斜率优化","link":"/tags/斜率优化/"},{"name":"多项式","slug":"多项式","link":"/tags/多项式/"},{"name":"交互","slug":"交互","link":"/tags/交互/"},{"name":"生成函数","slug":"生成函数","link":"/tags/生成函数/"},{"name":"lct","slug":"lct","link":"/tags/lct/"},{"name":"套路","slug":"套路","link":"/tags/套路/"},{"name":"毒瘤计数","slug":"毒瘤计数","link":"/tags/毒瘤计数/"},{"name":"莫比乌斯反演","slug":"莫比乌斯反演","link":"/tags/莫比乌斯反演/"},{"name":"左偏树","slug":"左偏树","link":"/tags/左偏树/"},{"name":"可并堆","slug":"可并堆","link":"/tags/可并堆/"}],"categories":[{"name":"题解","slug":"题解","link":"/categories/题解/"},{"name":"口胡","slug":"题解/口胡","link":"/categories/题解/口胡/"},{"name":"杂项","slug":"杂项","link":"/categories/杂项/"},{"name":"模板","slug":"模板","link":"/categories/模板/"},{"name":"合集","slug":"题解/合集","link":"/categories/题解/合集/"}]}