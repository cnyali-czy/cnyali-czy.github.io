{"pages":[{"title":"å…³äºQAQ","text":"ä¼—æ‰€å‘¨çŸ¥å¾ˆèœçš„ä¸€ä¸ªOierã€‚ æˆ‘çš„é‚®ç®±æ˜¯yms-chenziyang@outlook.com æˆ‘çš„QQ?16830053325","link":"/about/index.html"}],"posts":[{"title":"Todo List","text":"å’•å’•å’•å’•å’• emmæˆ‘è§‰å¾—æˆ‘å›æ¥äº†ã€‚ç„¶åå—ï¼Œè®¡åˆ’ä»€ä¹ˆé‡æ–°æä¸€æå§ã€‚ä¸‹é¢å†æ˜¯ç»´(gu)æŒ(gu)ä¸(gu)å˜(gu)å§ã€‚ ä»Šå¤©çœ‹äº†ä¸€ä¸‹é»‘æ¿ï¼Œå¥½åƒåªæœ‰$22$å¤©çš„é€é¥æ—¥å­è¿‡äº†ã€‚èœæ­»äº†èœæ­»äº†ã€‚å¥½æ…Œå•Šï¼Œäºæ˜¯å®šä¸ªè®¡åˆ’ç®—äº†ã€‚ å…ˆæ˜¯è¿˜è¦å­¦çš„æ•°æ®ç»“æ„ å¹³è¡¡æ ‘ åŠ¨æ€æ ‘ ä¸»å¸­æ ‘ ç‚æœµè‰æ ‘ å¯æŒä¹…åŒ– ACè‡ªåŠ¨æœº å›æ–‡è‡ªåŠ¨æœº åç¼€è‡ªåŠ¨æœº æè¶…çº¿æ®µæ ‘ ZKWæ•°æ®ç»“æ„ çº¿æ®µæ ‘æ ‘å¥—çº¿æ®µæ ‘ çº¿æ®µæ ‘æ ‘å¥—å¹³è¡¡æ ‘ ç®—æ³• åˆ†å— è«é˜Ÿ ç‚¹åˆ†æ²» è¾¹åˆ†æ²» æ’å¤´dp CDQåˆ†æ²» æ¨¡æ‹Ÿé€€ç« æ•´ä½“äºŒåˆ† åº·æ‰˜å±•å¼€ manacher ç²’å­ç¾¤ä¼˜åŒ– é«˜çº§ç½‘ç»œæµ è®¡ç®—å‡ ä½• å‡¸åŒ… æ—‹è½¬å¡å£³ è§£æ ä¼˜åŒ– å•è°ƒé˜Ÿåˆ— æ–œç‡ä¼˜åŒ– å››è¾¹å½¢ä¸ç­‰å¼ æ•°å­¦ FFT NTT MTT FWT polya åšå¼ˆè®º æœæ•™ç­› å•çº¯å‹ å¾®ç§¯åˆ† æ–¯ç‰¹æ—æ•° è®¡ç®—å‡ ä½•åŸºç¡€ è«æ¯”ä¹Œæ–¯åæ¼”","link":"/2019/03/14/Todo-List/"},{"title":"èƒ¡é—¹ äº¤äº’ç¨‹åº","text":"æ¯’ç˜¤äº¤äº’ã€‚ é¢˜ç›®å¤§æ„æœ‰$N$ä¸ªç›’å­ï¼Œç¬¬$i$ä¸ªç›’å­é‡Œé¢æœ‰$p_i$ä¸ªçƒï¼Œä»ä¸€ä¸ªç›’å­ä¸­åªèƒ½æ‹¿ä¸€ä¸ªçƒå‡ºæ¥ã€‚æ±‚æ°å¥½æ‹¿å‡ºæ¥$M$ä¸ªçƒçš„æ–¹æ¡ˆæ•°ï¼Œå¯¹$998244353$å–æ¨¡ã€‚ ä½ ä¸çŸ¥é“$piâ€‹$çš„å…·ä½“çš„å€¼ï¼Œåªèƒ½æŒ‡å®šæ“ä½œã€‚ å…·ä½“æ¥è¯´ï¼Œä½ æœ‰ä¸€ä¸ªé•¿åº¦ä¸º$T$çš„æ•´å‹æ•°ç»„$A$ï¼Œå…¶ä¸­å‰$N$ä¸ªä½ç½®åˆå§‹å­˜çš„æ˜¯$p_1,p_2,â‹¯,p_N$ã€‚å…¶ä½™ä½ç½®çš„åˆå§‹å€¼ç”±ä½ é€šè¿‡Setæ“ä½œæ¥å†³å®šã€‚ åœ¨å†³å®šå®Œåˆå§‹å€¼ä¹‹åï¼Œä½ å°±åªèƒ½æŒ‡å®šæ“ä½œäº†ã€‚ä½ åªèƒ½æå‡ºï¼š $A_i=A_j+A_k$ $A_i=A_jâˆ’A_k$ $A_i=A_j\\times A_k$ï¼ˆæ‰€æœ‰è¿ç®—å‡åœ¨æ¨¡$998244353$æ„ä¹‰ä¸‹ï¼‰ è¿‡ç¨‹ä¸­ä¸å…è®¸ä½ ä¿®æ”¹å‰$N$ä¸ªä½ç½®çš„å€¼ã€‚ è¿‡ç¨‹ä¸­ä¸å…è®¸ä½¿ç”¨Setæ“ä½œèµ‹å€¼ã€‚ ä½ è¿˜éœ€è¦æŒ‡å‡º$A$ä¸­çš„å“ªä¸€ä¸ªæ•°æ˜¯ç­”æ¡ˆã€‚ æ•°æ®èŒƒå›´$1\\le M\\le N\\le 1000,T=1004$ è§£æç”±ç”Ÿæˆå‡½æ•°ï¼Œç­”æ¡ˆæ˜¾ç„¶ä¸ºï¼š$$Ans=\\prod_{i=1}^n (1+p_i\\times x) [x^{n-m}]$$ç„¶åæˆ‘ä»¬è€ƒè™‘ä¸€äº›äº‹æƒ…ï¼š æ“ä½œçš„å¤„ç†å½’é›¶ç›´æ¥æŠŠä¸€ä¸ªæ•°å‡å»è‡ªèº«å³å¯ã€‚ å½’ä¸€è´¹é©¬å°å®šç†å³å¯ã€‚$$a^{P-1}\\equiv1(\\bmod P)$$ å¤åˆ¶å…ˆå½’é›¶ï¼Œç„¶ååŠ èµ·æ¥å³å¯ã€‚ ï¼ˆè®¡ç®—ä¸­ï¼‰èµ‹å€¼åœ¨è®¡ç®—å‰ï¼Œå…ˆæä¸€ä¸ª$1$å‡ºæ¥ã€‚ æŠŠè¦èµ‹çš„å€¼äºŒè¿›åˆ¶åˆ†è§£èµ‹å€¼å³å¯ã€‚ ä¼˜åŒ–ç›´æ¥ææš´åŠ›å¤æ‚åº¦æœ‰ç‚¹çˆ†ç‚¸ã€‚ è€ƒè™‘ä¸€ä¸‹$IDFT$çš„è¿‡ç¨‹ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥æŠŠç­”æ¡ˆåŒ–æˆè¿™æ ·çš„å½¢å¼ï¼š$$Ans=\\frac{1}{N}\\times\\sum_{i=0}^{N-1}f(\\omega_N^i)\\times\\omega_N^{-i\\times m}$$è¿™ä¸ªæ—¶å€™æˆ‘ä»¬å°±å‘ç°$T=1004$ç»™æˆ‘ä»¬å‰©ä¸‹äº†å“ª$4$ä¸ªå˜é‡äº†ï¼š$$Ans,f(x),x,y=1$$ å®ç°æ—¶é¢„å¤„ç†å‡º$\\omega_N^i$å³å¯ã€‚ Noticeå“å‘€è¿™ä¸ªä¸œè¥¿æ—¶çœŸçš„å‘ã€‚ æˆ‘è¢«æˆ‘çš„å·¨å¤§å¸¸æ•°é€èµ°æ— æ•°æ¬¡ä¹‹åï¼Œå†³å¿ƒï¼š è®©å¸¸æ•°ä¼˜åŒ–æˆä¸ºä¹ æƒ¯ã€‚ ç„¶åæˆ‘å°±ç–¯ç‹‚åŠ inlineï¼Œç„¶åå°±ç–¯ç‹‚Complie Errorã€‚ è°ƒäº†å¥½ä¹…ï¼Œæœ€ååŸå› æ˜¯äº¤äº’åº“ä½ é‡Œé¢çš„å‡½æ•°æ²¡æœ‰inlineï¼Œè€Œæˆ‘åŠ äº†ã€‚ è¿™æ ·ä¼šå¯¼è‡´ä»€ä¹ˆå‘¢ï¼Ÿå¯¹ï¼Œäº¤äº’åº“çš„å‡½æ•°å°±æ²¡æœ‰å®šä¹‰äº†ã€‚ è€Œä¸”è¿™ä¸ªä¸œè¥¿ä¸ç”¨g++ -o %&lt; % grader.cppè¿˜æŸ¥ä¸å‡ºæ¥ã€‚ éš¾å—ğŸ˜”ã€‚ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#define REP(i, s, e) for (int i = s; i &lt;= e; i++)#include &lt;bits/stdc++.h&gt;#include \"polynomial.h\"using namespace std;const int maxn = 1000 + 30, g = 3, MOD = 998244353;int n, m, t, N = 1 &lt;&lt; 10;int ans, fx, w[maxn], t1, t2;inline int power_pow(int a, int b){ int ans = 1, base = a; while (b) { if (b &amp; 1) ans = 1ll * ans * base % MOD; base = 1ll * base * base % MOD; b &gt;&gt;= 1; } return ans;}void Init(int n, int m, int t){ ::n = n; ::m = n - m; N = 1024; Set(ans = n + 4, 0); Set(fx = n + 1, 0); Set(t1 = n + 2, 1); Set(t2 = n + 3, 1); w[0] = 1; w[1] = power_pow(3, (MOD - 1) / N); REP(i, 2, N - 1) w[i] = 1ll * w[i-1] * w[1] % MOD;}inline void Set_Zero(int x) {Minus(x, x, x);}inline void Copy(int i,int j){ Set_Zero(i); Plus(i, i, j);//i = i + j = 0 + j = j}inline void Power_pow(int base, int b){ bool first = 1; while (b) { if (b &amp; 1) if (first) { first = 0; Copy(t1, base); } else Multiply(t1, t1, base); Multiply(base, base, base); b &gt;&gt;= 1; } Copy(base, t1);}inline void Set_One(int x) {Power_pow(x, MOD - 1);/*a ^ (P-1) = 1 (MOD P)*/;}inline void Get(int x){ Set_One(t2); Set_Zero(t1); while (x) { if (x &amp; 1) Plus(t1, t1, t2); Plus(t2, t2, t2); x &gt;&gt;= 1; }}void Solve(){ REP(i, 0, N - 1) { Set_One(t2); Copy(fx, t2); Get(w[i]); REP(j, 1, n) { Plus(t1, t1, j); Multiply(fx, fx, t1); Minus(t1, t1, j); } Get(w[((-i * m % N) + N) % N]); Multiply(fx, fx, t1); Plus(ans, ans, fx); } Get(power_pow(N, MOD-2)); Multiply(ans, ans, t1); Answer(ans);}","link":"/2019/07/28/èƒ¡é—¹-äº¤äº’ç¨‹åº/"},{"title":"èƒ¡é—¹ ç»Ÿè®¡ä¸‰è§’å½¢","text":"é¢˜ç›®å¤§æ„ç»™ä½ å¹³é¢ä¸Š$n\\le3000$ä¸ªç‚¹ï¼Œæ¯ä¸ªç‚¹æœ‰ä¸€ä¸ªé¢œè‰²$c_i\\in[0,2]$ã€‚ å®šä¹‰ä¸€ä¸ªä¸‰è§’å½¢æ˜¯å¥½çš„ï¼Œå½“ä¸”ä»…å½“è¿™ä¸ªä¸‰è§’å½¢çš„ä¸‰ä¸ªå®šç‚¹é¢œè‰²ä¸åŒã€‚ å®šä¹‰ä¸€å¯¹ä¸‰è§’å½¢æ˜¯å¥½çš„ï¼Œå½“ä¸”ä»…å½“è¿™ä¸¤ä¸ªä¸‰è§’å½¢æ˜¯å¥½çš„å…¶è¿™ä¸¤ä¸ªä¸‰è§’å½¢æ²¡æœ‰äº¤é›†ã€‚ ä¸ºäº†é¿å…æ­§ä¹‰ï¼Œä¿è¯ç‚¹çš„åæ ‡äº’ä¸ç›¸åŒã€‚ ç»Ÿè®¡å¥½çš„ä¸‰è§’å½¢å¯¹æœ‰å¤šå°‘ã€‚ è§£æé¦–å…ˆï¼Œä¸¤ä¸ªä¸‰è§’å½¢æ²¡æœ‰äº¤é›†çš„çš„å……è¦æ¡ä»¶æ˜¯è¿™ä¸¤ä¸ªä¸‰è§’å½¢ä¹‹é—´å­˜åœ¨ä¸¤æ¡å†…å…¬åˆ‡çº¿ã€‚ é‚£ä¹ˆæˆ‘ä»¬å°±å¯ä»¥æšä¸¾å†…å…¬åˆ‡çº¿ã€‚ è¿™æ¡ç›´çº¿ä¼šæŠŠå¹³é¢åˆ†æˆä¸¤ä¸ªéƒ¨åˆ†ï¼Œç„¶åæœ‰è´¡çŒ®çš„ç‚¹å¯¹ä¸€å®šä¸€ä¸ªåœ¨è¿™æ¡ç›´çº¿å·¦è¾¹ï¼Œä¸€ä¸ªåœ¨è¿™æ¡ç›´çº¿å³è¾¹ã€‚ é‚£æˆ‘ä»¬å¯ä»¥å…ˆæšä¸¾ä¸€ä¸ªç‚¹ï¼Œç„¶åæŠŠå…¶ä»–çš„ç‚¹åšæè§’æ’åºã€‚æè§’æ’åºç”¨å‘é‡æ¯”è¾ƒéº»çƒ¦ï¼Œé‚£å°±ç›´æ¥ä¸‰è§’å‡½æ•°å§ã€‚ æŒ‰ç…§è¿™æ ·çš„é¡ºåºæšä¸¾ä¸¤ä¸ªç‚¹æ¥æšä¸¾å†…å…¬åˆ‡çº¿ï¼Œå°±å¯ä»¥ä¿è¯æ¯æ¬¡éƒ½åªä¼šæŠŠä¸€ä¸ªç‚¹ä»ä¸€è¾¹ä¸¢åˆ°å¦ä¸€è¾¹å»ã€‚ ç»Ÿè®¡çš„æ—¶å€™å¤§åŠ›è®¨è®ºä¸€ä¸‹é¢œè‰²å°±å¯ä»¥äº†ã€‚ Noticeå€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œå¦‚æœç®¡åæ ‡å¤§å°ç›´æ¥éšä¾¿æï¼Œç­”æ¡ˆä¼šæ˜¯çœŸæ­£çš„ç­”æ¡ˆçš„$4$å€ï¼Œè¦è®°å¾—æŠŠè¿™ä¸ªä¸œè¥¿ææ‰ã€‚ Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#define REP(i, s, e) for (int i = s; i &lt;= e; i++)#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;using namespace std;const int maxn = 3000 + 10;const double pi = acos(-1), inf = 1e20;int n;long long ans;int cnt[2][3];//cnt[0/1][x] åˆ†å‰²çº¿å·¦å³çš„cntbool app[maxn];//è¢«æè¿‡å»å‡ æ¬¡struct point{ int x, y, c, id; double k; bool operator &lt; (point B) const {return k &lt; B.k;}//æè§’æ’åº}P[maxn], p[maxn], O;int main(){#ifndef ONLINE_JUDGE freopen(\"B.in\", \"r\", stdin); freopen(\"B.out\", \"w\", stdout);#endif cin &gt;&gt; n; REP(i, 1, n) scanf(\"%d%d%d\", &amp;P[i].x, &amp;P[i].y, &amp;P[i].c), P[i].id = i; long long tmp; REP(i, 1, n) { O = P[i]; int k = O.c; copy(P + 1, P + 1 + n, p + 1); int cur(0); REP(j, 1, n) if (i ^ p[j].id) { p[++cur]=p[j]; p[cur].k = atan2(p[cur].y - O.y, p[cur].x - O.x); if (p[cur].k &lt;= 0) p[cur].k += pi; } sort(p + 1, p + n); memset(cnt, 0, sizeof(cnt)); memset(app, 0, sizeof(app)); REP(j, 1, cur) if (p[j].y &lt; O.y || p[j].y == O.y &amp;&amp; p[j].x &gt; O.x) ++cnt[0][p[j].c];//ä¸€å¼€å§‹ä¸‹é¢ else ++cnt[1][p[j].c], app[j] = 1; REP(j, 1, cur) { --cnt[app[j]][p[j].c]; tmp = 1ll * (k ? cnt[0][0] : 1) * (p[j].c ? cnt[1][0] : 1) * ((k ^ 1) ? cnt[0][1] : 1) * ((p[j].c ^ 1) ? cnt[1][1] : 1) * ((k ^ 2) ? cnt[0][2] : 1) * ((p[j].c ^ 2) ? cnt[1][2] : 1);//å¤§åŠ›ç»Ÿè®¡é¢œè‰² ans += tmp; tmp = 1ll * (k ? cnt[1][0] : 1) * (p[j].c ? cnt[0][0] : 1) * ((k ^ 1) ? cnt[1][1] : 1) * ((p[j].c ^ 1) ? cnt[0][1] : 1) * ((k ^ 2) ? cnt[1][2] : 1) * ((p[j].c ^ 2) ? cnt[0][2] : 1); ans += tmp; ++cnt[app[j] ^= 1][p[j].c]; } } cout &lt;&lt; ans / 4 &lt;&lt; endl; return 0;}","link":"/2019/07/28/èƒ¡é—¹-ç»Ÿè®¡ä¸‰è§’å½¢/"},{"title":"å£èƒ¡ æœ€å°Kè¦†ç›–åœ†","text":"è¿™ä¸ªä»€ä¹ˆâ€œæœ€å°$K$è¦†ç›–åœ†â€å…¶å®æ˜¯æˆ‘çæ•´çš„ä¸€ä¸ªå®šä¹‰ã€‚ é¢˜ç›®å¤§æ„ç»™å®šå¹³é¢ä¸Š$n\\le500$ä¸ªç‚¹$(x_i,y_i)$ï¼Œæ±‚å‡ºæœ€å°çš„ä¸€ä¸ªåŠå¾„$r$ä½¿å¾—æœ‰è‡³å°‘$k$ä¸ªç‚¹è¢«æŸä¸ªä»¥$r$ä¸ºåŠå¾„çš„åœ†è¦†ç›–ï¼ˆåŒ…å«è¾¹ç•Œï¼‰ã€‚ ç²¾ç¡®åˆ°$10^{-8}$ã€‚ è§£æè¿™æ˜¯ä¸€ä¸ªæ‚²ä¼¤çš„æ•…äº‹ã€‚å¦‚æœä¸é‚£ä¹ˆç²¾ç¡®ï¼Œæ¯”å¦‚è¯´ç²¾ç¡®åˆ°$10^5$ï¼Œé‚£ä»€ä¹ˆéšæœºç®—æ³•çˆ¬å±±å•Šã€é€€ç«å•Šã€ç²’å­ç¾¤å•Šéƒ½èƒ½è¿‡ è¿™æ˜¯ä¸€ä¸ªæ›´æ‚²ä¼¤çš„æ•…äº‹UOJçš„clock()å¥½åƒæ˜¯å‡çš„ï¼Œè¿™æ ·å°±é€ æˆäº†è–›å®šè°”çš„TLEã€‚ æˆ‘ä»¬è€ƒè™‘äºŒåˆ†ç­”æ¡ˆã€‚ æ˜¾ç„¶å¯ä»¥å…ˆæšä¸¾ä¸€ä¸ªå›ºå®šç‚¹ï¼Œç„¶åç¡®ä¿è¿™ä¸ªå›ºå®šç‚¹åœ¨åœ†çš„è¾¹ç•Œä¸Šã€‚ æ³¨æ„åˆ°æšä¸¾å›ºå®šç‚¹çš„æ—¶å€™ï¼ŒåŒ…å«ä¸€ä¸ªç‚¹çš„åœ†æ˜¯ä¸€æ®µåŒºé—´ã€‚ é‚£ä¹ˆæˆ‘ä»¬çš„é—®é¢˜å°±å˜æˆäº†äº†ç»™å‡ºè‹¥å¹²æ®µåŒºé—´ï¼Œé—®æœ‰æ²¡æœ‰ä¸€ä¸ªä½å­è¢«$kâˆ’1$ä¸ªåŒºé—´åŒ…å«ã€‚ æš´åŠ›äºŒåˆ†ç­”æ¡ˆçš„å¤æ‚åº¦æ˜¯$\\mathcal{O}(n^2log\\ n\\ log\\ ans)$çš„ï¼Œä¸å¤ªè¡Œã€‚ è€ƒè™‘ç¨å¾®å‰ªä¸€ä¸‹æã€‚å¦‚æœæˆ‘ä»¬å½“å‰ç‚¹å¯¹äºæœ€ä¼˜è§£ä¸åˆæ³•ï¼ˆæä¸å®šé‚£ä¹ˆå¤šä¸ªåŒºé—´ï¼‰ï¼Œå°±ç›´æ¥ä¸ç®¡äº†ã€‚ ç„¶årandom_shuffleä¸€ä¸‹ï¼Œå¤æ‚åº¦å°±å˜æˆäº†æœŸæœ›$\\mathcal{O}(nlog^2\\ nlog\\ ans)$äº†ã€‚ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586//modify to learn#define REP(i, s, e) for (int i = s; i &lt;= e; i++)#define dis(x1, y1, x2, y2) sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2))#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#define double long double#define point pair&lt;double, double&gt;#define x first#define y secondusing namespace std;const int maxn = 500 + 5;const double eps = 1e-9, inf = 1e20;int n, k;point a[maxn], b[maxn &lt;&lt; 1];double ans;inline double dist(point A, point B) {return dis(A.x, A.y, B.x, B.y);}inline int dcmp(double x) {return (x &gt; eps) - (x &lt; -eps);}bool same(double x, double y) {return fabs(x-y) &lt; eps;}inline bool cmp(point A, point B) {return A.x &lt; B.x || A.x == B.x &amp;&amp; A.y &lt; B.y;}point operator + (point A, point B) {return make_pair(A.x + B.x, A.y + B.y);}point operator - (point A, point B) {return make_pair(A.x - B.x, A.y - B.y);}point operator / (point A, double u) {return make_pair(A.x / u, A.y / u);}point operator * (point A, double u) {return make_pair(A.x * u, A.y * u);}inline void calc(point o1, point o2, double r, point&amp; x, point&amp; y){ double Dis = dist(o1, o2) / 2; point mid = (o1 + o2) / 2, p = (o2 - o1) / 2; p = make_pair(p.y, -p.x) / Dis * sqrt(r * r - Dis * Dis); x = mid + p, y = mid - p;}inline bool check(point o, double r){ int m = k - 1, p = 0; REP(i, 1, n) if (dcmp(dist(o, a[i])) &amp;&amp; dcmp(dist(o, a[i]) - 2 * r) &lt;= 0) { point x,y; calc(o, a[i], r, x, y); double ax = atan2(x.y - o.y, x.x - o.x), ay = atan2(y.y - o.y, y.x - o.x); b[++p] = make_pair(ax, -1); b[++p] = make_pair(ay, 1); if (ax &gt; ay) m--; } if (m &lt;= 0) return 1; sort(b + 1, b + p + 1, cmp); REP(i, 1, p) if ((m += b[i].y) &lt;= 0) return 1; return 0;}int main(){#ifndef ONLINE_JUDGE freopen(\"A.in\", \"r\", stdin); freopen(\"A.out\", \"w\", stdout);#endif srand(233); cin &gt;&gt; n &gt;&gt; k; REP(i, 1, n) scanf(\"%LF%LF\", &amp;a[i].x, &amp;a[i].y); random_shuffle(a + 1, a + n + 1); double L, R = inf; REP(i, 1, n) if (check(a[i], R)) { L = 0; while (R - L &gt; eps) { double MID = (L + R) / 2; if (check(a[i], MID)) R = MID; else L = MID; } } printf(\"%.8LF\\n\", R); return 0;}","link":"/2019/07/27/å£èƒ¡-æœ€å°Kè¦†ç›–åœ†/"},{"title":"å£èƒ¡ å­—ç¬¦ä¸²æœ€å°ç­‰ä»·ä¸²","text":"è¿™ç§ä¸œè¥¿è§è¿‡ä¸€ä¸¤æ¬¡äº†ï¼Œç¨å¾®å£èƒ¡ä¸€ä¸‹å§ã€‚ å®šä¹‰ä»€ä¹ˆæ˜¯æœ€å°ç­‰ä»·ä¸²ï¼Ÿ å¯ä»¥ç†è§£ä¸ºæŠŠä¸€ä¸ªå­—ç¬¦ä¸²ä¸­çš„å­—ç¬¦æŒ‰é¡ºåºé‡æ–°â€œç¼–å·â€ã€‚ æ¯”å¦‚è¯´ä¸€ä¸ªå­—ç¬¦ä¸²S=BBCBAï¼Œé‚£ä¹ˆå®ƒçš„æœ€å°è¡¨ç¤ºå°±æ˜¯T=AABACã€‚ é—®é¢˜å¿«é€Ÿåˆ¤æ–­ä¸¤ä¸ªä¸²æ˜¯å¦ç­‰ä»·ï¼ˆå³æœ€å°ç­‰ä»·ä¸²ç›¸åŒï¼‰ è§£ææˆ‘ä»¬å‘ç°é—®é¢˜å°±åœ¨äºè¿™ä¸ªå­—ç¬¦å¯ä»¥éšä¾¿æï¼Œè¿™æ ·éšä¾¿æ€æ ·éƒ½ä¼šæŒ‚ã€‚ æ€ä¹ˆåŠå‘¢ï¼Ÿèƒ½ä¸èƒ½åè¿‡æ¥åˆ©ç”¨è¿™ä¸ªä¸œè¥¿ï¼Ÿ æ³¨æ„åˆ°æˆ‘ä»¬ä¸å…³å¿ƒæ¯ä¸€ç§å­—ç¬¦å…·ä½“æ˜¯ä»€ä¹ˆï¼Œåªå…³å¿ƒå®ƒä»¬åœ¨å“ªé‡Œå‡ºç°äº†ã€‚ é‚£ä¹ˆæˆ‘ä»¬å¯ä»¥è€ƒè™‘è®°last[i]è¡¨ç¤ºå­—ç¬¦iä¸Šä¸€æ¬¡å‡ºç°çš„ä½ç½®ï¼Œç¬¬$1$æ¬¡å‡ºç°åˆ™è®°ä¸º$0$ã€‚ ä¸éš¾å‘ç°ï¼Œåªè¦ä¸¤ä¸ªå­—ç¬¦ä¸²å¯¹åº”çš„i-last[i]ç›¸åŒï¼Œå®ƒä»¬å°±æ˜¯ç­‰ä»·çš„ã€‚ æ¯”å¦‚è¯´å­—ç¬¦ä¸²S=BBCBAï¼š Source String B B C B A LAST 0 1 0 2 0 i-LAST 1 1 3 2 5 å­—ç¬¦ä¸²T=AABACï¼š Source String A A B A C LAST 0 1 0 2 0 i-LAST 1 1 3 2 5 è¯´æ˜Så’ŒTæ˜¯ç­‰ä»·çš„ã€‚ è€Œå¯¹äºSS=AAABCæ¥è¯´ï¼š source String A A A B C LAST 0 1 2 0 0 i-LAST 1 1 1 4 5 è¯´æ˜SSä¸S,Tæ˜¯ä¸ç­‰ä»·çš„ã€‚ å¯¹ä¸å¯¹ï¼ŸWO YE BU HUIã€‚","link":"/2019/07/26/å£èƒ¡-å­—ç¬¦ä¸²æœ€å°ç­‰ä»·ä¸²/"},{"title":"èƒ¡é—¹ å›æ–‡","text":"é¢˜ç›®å¤§æ„æ±‚$[0,n]$ä¸­æœ‰å‡ ä¸ª$n\\le10^6$ä½æ•°ï¼ˆè€ƒè™‘å‰å¯¼$0$ï¼‰æ»¡è¶³å¦‚ä¸‹æƒ…å†µï¼š è¿™ä¸ªæ•°æ˜¯ä¸€ä¸ªå›æ–‡æ•°ã€‚ è¿™ä¸ªæ•°å¥‡æ•°ä½ä¸Šçš„å’Œç­‰äºå¶æ•°ä½ä¸Šçš„å’Œã€‚ è§£æå‡è®¾$n$æ˜¯ä¸€ä¸ªå¶æ•°ï¼Œé‚£ä¹ˆç­”æ¡ˆæ˜¾ç„¶æ˜¯$10^\\frac{n}{2}$å¯¹å§ã€‚ ç„¶åå‡è®¾$n$æ˜¯ä¸€ä¸ªå¥‡æ•°ã€‚ $\\mathcal{O(n^2)}$ çš„$dp$åšæ³•æˆ‘ä»¬å¯ä»¥è®¾dp[i][j]â€‹ä¸ºé•¿åº¦ä¸ºiï¼ˆä¸è€ƒè™‘å‰å¯¼$0$ï¼‰ï¼Œå¥‡æ•°ä½ä¸å¶æ•°ä½çš„å·®ä¸ºjçš„æ•°çš„æ€»æ•°ã€‚ è¿™ä¸ªéšä¾¿è½¬ç§»ä¸€ä¸‹å°±å¥½äº†ã€‚ ä½†æ˜¯è¿™å¯èƒ½å‡ºç°è´Ÿæ•°ä¸‹æ ‡ï¼Œè¿™å¾ˆéš¾å—ï¼Œæœ‰ä¸¤ä¸ªè§£å†³æ–¹æ¡ˆï¼š #define Dp(i, j) dp[i][j+Min_Value] __gnu_pbds::gp_hash_table&lt;int, int&gt; ä½†æ˜¯å¦‚æœä½ å‚»é€¼å¦‚æˆ‘ï¼ˆä¸å¯èƒ½ï¼‰ç”¨äº†è¿™ç§ä¸œè¥¿ï¼šmap&lt;int, int&gt; é‚£ä¹ˆæ­å–œä½ ï¼Œè·å¾—ä¸€ä¸ª$log$çš„$debuffâ€‹$å¹¶ä¸”æŒ‚æˆæš´åŠ›ã€‚ æ­£ç¡®çš„å¤æ‚åº¦è¿™çœ‹ä¸Šå»æ˜¯ä¸€ä¸ªå®¹æ–¥ã€‚ ç„¶åæˆ‘ä»¬è€ƒè™‘æ€ä¹ˆä¸ªå®¹æ–¥æ³•ã€‚ å¯¹äºå½¢å¦‚$n=4k+1â€‹$çš„æ•°çš„è¯ï¼Œæˆ‘ä»¬æ¨ä¸€æ¨å¼å­ï¼š$$\\begin{align}2\\times(x_1 + x_3 + Â· Â· Â· + x_{2kâˆ’1}) + x_{2k+1} &amp;= 2 \\times (x_2 + x_4 + Â· Â· Â· + x_{2k})\\\\x_2+x_4+Â· Â· Â·+x_{2k}+(9âˆ’x_1)+(9âˆ’x_2)+Â· Â· Â·+(9âˆ’x_{2kâˆ’1})&amp;=9k+\\frac{x_{2k+1}}{2}\\end{align}$$é‚£ä¹ˆæˆ‘ä»¬è€ƒè™‘æšä¸¾ä¸€ä¸‹$\\frac{x_{2k+1}}{2}â€‹$ï¼Œè¿™å°±å˜æˆäº†ä¸€ä¸ªå®¹æ–¥ç„¶åéš”æ¿æ³•ï¼ˆåˆ«é—®æˆ‘ä¸ºä»€ä¹ˆï¼ŒWO YE BU HUIï¼‰ã€‚ å¯¹äºå½¢å¦‚$n=4k+3$çš„æ ·å­ï¼Œå¤šè€ƒè™‘ä¸€ä¸ªæ•°å°±å¯ä»¥äº†ï¼ˆWO YE BU HUIï¼‰ Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#define REP(i, s, e) for (register int i = s; i &lt;= e; i++)#define DREP(i, s, e) for (register int i = s; i &gt;= e; i--)#include &lt;bits/extc++.h&gt;#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int maxn = 1e7 + 10, MOD = 1e9 + 7;inline int power_pow(int a, int b){ int ans(1), base(a); while (b) { if (b &amp; 1) ans = ans * base % MOD; base = base * base % MOD; b &gt;&gt;= 1; } return (ans + MOD) % MOD;}#define inv(x) power_pow(x, MOD - 2)int n;int fac[maxn], Inv[maxn];inline int C(int n, int m) {return n &lt; m || m &lt; 0 ? 0 : fac[n] * Inv[n-m] % MOD * Inv[m] % MOD;}inline int solve(int S, int n){ int res(0), cur(-1); REP(i, 0, n) res += (cur *= -1) * C(n, i) * C(S - i * 10 + n - 1, n - 1) % MOD, res %= MOD; return (res + MOD) % MOD;}__gnu_pbds::gp_hash_table &lt;int,int&gt; cnt;__gnu_pbds::gp_hash_table &lt;int,int&gt; :: iterator it;signed main(){#ifndef ONLINE_JUDGE freopen(\"B.in\", \"r\", stdin); freopen(\"B.out\", \"w\", stdout);#endif Inv[0] = fac[0] = 1; REP(i, 1, 10000000) fac[i] = fac[i-1] * i % MOD; Inv[10000000] = inv(fac[10000000]); DREP(i, 9999999, 1) Inv[i] = Inv[i+1] * (i+1) % MOD; int T;cin &gt;&gt; T; while (T--) { scanf(\"%lld\", &amp;n); int ans = 0; if (n % 2 == 0) ans = power_pow(10, n &gt;&gt; 1); else if (n == 1) ans = 1; else if (n == 3) ans = 5; else if (n % 4 == 1) REP(i, 0, 4) ans += solve(i + 9 * (n &gt;&gt; 2), n &gt;&gt; 1) % MOD, ans %= MOD; else { cnt.clear(); REP(i, 0, 4) REP(j, 0, 9) cnt[i-j]++; for (it = cnt.begin(); it != cnt.end(); it++) ans += solve(it -&gt; first + 9 * (n &gt;&gt; 2), (n &gt;&gt; 1) - 1) * it -&gt; second % MOD, ans %= MOD; } printf(\"%lld\\n\", ans); } return 0;}","link":"/2019/07/25/èƒ¡é—¹-å›æ–‡/"},{"title":"èƒ¡é—¹ å¡«æ•°","text":"è¿™ç§é¢˜èƒ½åšï¼Ÿ æˆ‘ä¹Ÿå°±é ç€é‡æ„$std$è¿‡æ´»äº†ã€‚ é¢˜ç›®å¤§æ„ç»™ä½ ä¸€ä¸ª$n\\times m$çš„çŸ©é˜µè¦ä½ å¡«æ•°ã€‚å¡«çš„æ•°èŒƒå›´ä¸º$[1,k]$ã€‚ é—®ä½ æœ¬è´¨ä¸åŒçš„æ–¹æ¡ˆæœ‰å¤šå°‘ã€‚æœ¬è´¨ä¸åŒå®šä¹‰ä¸ºä»»æ„äº¤æ¢è¡Œåˆ—åæ— æ³•å…¨åŒã€‚ Noticeæ—¶é™$4s$ $1\\le n,m\\le45,1\\le k\\le10^9$ è§£æä¸€çœ‹å°±æ˜¯æˆ‘ä¸ä¼šçš„é¢˜ã€‚ è€ƒè™‘ä¸€ä¸‹$Brunside$å¼•ç†ï¼ˆå…¶å®å¤§æ¦‚æ˜¯$polya$?)ã€‚ç›´æ¥éšä¾¿æ•´æ•°åˆ’åˆ†æšä¸¾è¡Œåˆ—ç½®æ¢çš„å¾ªç¯é•¿åº¦ï¼Œè¿™ä¸ªå¤æ‚åº¦å¤§æ¦‚æ˜¯$\\mathcal{O(B_nB_m\\times n\\times m)}$çš„ã€‚ è¿™ä¸ªå¤æ‚åº¦ä¸å¤ªè¡Œï¼Œå¤§æ¦‚åªèƒ½å¡è¿‡$n,m\\le20$çš„æ•°æ®ã€‚ æ€ä¹ˆä¼˜åŒ–å‘¢ï¼Ÿ æˆ‘ä»¬å‘ç°å¦‚æœæˆ‘ä»¬æšä¸¾äº†è¡Œçš„æ•´æ•°åˆ’åˆ†ï¼Œæˆ‘ä»¬å…¶å®ä¸ç”¨ç®¡åˆ—çš„å…·ä½“æƒ…å†µï¼Œåªè¦ç®¡ä¸€ç®¡å®ƒçš„è´¡çŒ®å’Œã€‚ å…·ä½“æ¥è¯´å¯ä»¥æŠŠæ¯ä¸ªå¾ªç¯é•¿åº¦çš„è´¡çŒ®å…¨éƒ¨æèµ·æ¥$dp$ï¼Œå‘ç°è¿™æ˜¯ä¸€ä¸ªèƒŒåŒ…çš„å½¢å¼ï¼Œå¡å¡å¸¸å°±èƒ½ä½ç©ºé£è¿‡äº†ã€‚ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495//modify#define REP(i, s, e) for (register int i = s; i &lt;= e; i++)#define DREP(i, s, e) for (register int i = s; i &gt;= e; i--)#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;ctime&gt;using namespace std;const long long N = 150, maxn = N + 10, MOD = 1e9 + 7;inline long long power_pow(long long a, long long b){ long long ans = 1, base = a; while (b) { if (b &amp; 1) ans = ans * base % MOD; base = base * base % MOD; b &gt;&gt;= 1; } return ans;}#define inv(x) power_pow(x, MOD-2)int n, m, k;int fac[maxn], Inv[maxn], single[maxn], bin[maxn], dp[maxn];int v[maxn], p;int calc(){ int n = p; REP(i, 1, m) dp[i] = 0; dp[0] = 1; REP(i, 1, m) { long long coef = single[i]; REP(j, 1, n) coef = coef * bin[__gcd(v[j], i)] % MOD; DREP(j, m, 0) { long long cur = coef; for (int k = 1; j + i * k &lt;= m; k++) { dp[j + i * k] = (dp[j + i * k] + dp[j] * cur % MOD * Inv[k]) % MOD; cur = cur * coef % MOD; } } } int ans = dp[m], cnt = 0; REP(i, 1, n) { ans = ans * 1ll * single[v[i]] % MOD; if (i &gt; 1 &amp;&amp; v[i] ^ v[i - 1]) { ans = ans * 1ll * Inv[cnt] % MOD; cnt = 0; } cnt++; } return ans * 1ll * Inv[cnt] % MOD;}int dfs(int less, int last){ if (!less) return calc(); int res = 0; DREP(i, min(less, last), 1) { res = (0ll + res + dfs(less - i, v[++p] = i)) % MOD; --p; } return res;}signed main(){#ifndef ONLINE_JUDGE freopen(\"A.in\", \"r\", stdin); freopen(\"A.out\", \"w\", stdout);#endif cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; fac[0] = Inv[0] = bin[0] = 1; REP(i, 1, N) { fac[i] = 1ll * fac[i - 1] * i % MOD; single[i] = power_pow(i, MOD - 2); bin[i] = 1ll * bin[i - 1] * k % MOD; } Inv[N] = inv(fac[N]); DREP(i, N-1, 1) Inv[i] = 1ll * Inv[i+1] * (i+1) % MOD; cout &lt;&lt; dfs(n, n) &lt;&lt; endl;#ifndef ONLINE_JUDGE cerr&lt;&lt;clock()*1./CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;}","link":"/2019/07/25/èƒ¡é—¹-å¡«æ•°/"},{"title":"Luogu 4074 [WC2013 ç³–æœå…¬å›­]","text":"ä¼ é€é—¨ æ­£ç¡®æ€§ä»€ä¹ˆçš„å…ˆå’•å’•å’•ä¸€ä¸‹å§ï¼Œæˆ‘ä¹Ÿä¸å¤ªä¼šã€‚ é¢˜ç›®å¤§æ„æœ‰ä¸€ä¸ª$n\\le10^5$ä¸ªèŠ‚ç‚¹çš„æ ‘ï¼Œæ¯ä¸ªèŠ‚ç‚¹æœ‰ä¸€ä¸ªé¢œè‰²ã€‚ æ¯æ¬¡è¯¢é—®ï¼š$$\\sum_cval_c\\times\\sum_{i=1}^{cnt}w_i$$$val_c$è¡¨ç¤ºè¯¥é¢œè‰²çš„ä»·å€¼ $cnt$è¡¨ç¤ºé¢œè‰²å‡ºç°çš„æ¬¡æ•° $w_i$è¡¨ç¤ºè¯¥é¢œè‰²å‡ºç°$i$æ¬¡åçš„ä»·å€¼ å¸¦ä¿®æ”¹ã€‚ è§£æå¯ä»¥è€ƒè™‘ç”¨æ‹¬å·åºåˆ—æŠŠè¿™æ£µæ ‘æ‹å¹³ã€‚ ç»™å‡ºä¸€ä¸ªä¾‹å­ï¼š æ€ä¹ˆæ“ä½œå‘¢ï¼Ÿ æˆ‘ä»¬$dfs$çš„æ—¶å€™ï¼Œç¬¬ä¸€æ¬¡é‡åˆ°çš„æ—¶å€™$push\\_back$ä¸€æ¬¡ï¼Œå›æº¯çš„æ—¶å€™ä¹Ÿ$push\\_back$ä¸€æ¬¡ï¼Œè®°ä¸€ä¸‹å°±å¥½äº†ã€‚ ç„¶åæ ‘ä¸Šçš„é—®é¢˜å°±å˜æˆäº†åŒºé—´çš„é—®é¢˜å¯¹å§ã€‚ æ³¨æ„åˆ°å¦‚æœä¸€ä¸ªç‚¹ç¢°åˆ°äº†å®ƒçš„å·¦æ‹¬å·åˆç¢°åˆ°äº†å®ƒçš„å³æ‹¬å·ï¼Œè¿™ä¸ªç‚¹å°±æ˜¯è«å¾—è´¡çŒ®çš„ã€‚å°±è®°ä¸€ä¸ª$vis$æ¯æ¬¡ç¿»è½¬ä¸€ä¸‹$flag$å°±å¥½äº†ã€‚è¿™ä¸ªå°±å¯ä»¥è·‘è«é˜Ÿã€‚ ä»€ä¹ˆå¸¦ä¿®æ”¹ï¼ŸåŠ ä¸€ç»´æ—¶é—´å°±è¡Œã€‚ ä»€ä¹ˆè«é˜Ÿæ€ä¹ˆåˆ†å—ï¼Ÿç„å­¦è°ƒå‚å³å¯ä¸€èˆ¬æƒ…å†µå¼€ä¸€ä¸ª$\\mathcal{O}(n^\\frac{2}{3})$å°±è¡Œï¼Œæ€»å¤æ‚åº¦å¤§æ¦‚å°±æ˜¯$\\mathcal{O}(n^\\frac{5}{3})$ã€‚ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#define REP(i, s, e) for (int i = s; i &lt;= e; i++)#define DREP(i, s, e) for (int i = s; i &gt;= e; i--)#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100000 + 10, maxm = 100000 + 10, maxq = 100000 + 10, maxw = 1e6 + 10;int bg[maxn], ne[maxn &lt;&lt; 1], to[maxn &lt;&lt; 1], e;void add(int x, int y){ e++; to[e] = y; ne[e] = bg[x]; bg[x] = e;}int n, m, q;int v[maxm], w[maxn];int grand[maxn][20], LOG, depth[maxn], dfn[maxn], low[maxn], cur;int g[maxn &lt;&lt; 1];void dfs(int x){ REP(i, 1, LOG) grand[x][i] = grand[grand[x][i-1]][i-1]; g[dfn[x] = ++cur] = x; for (int i = bg[x]; i ; i = ne[i]) if (to[i] ^ grand[x][0]) { grand[to[i]][0] = x; depth[to[i]] = depth[x] + 1; dfs(to[i]); } g[low[x] = ++cur] = x;}int lca(int x, int y){ if (x == y) return x; if (dfn[x] &gt; dfn[y]) swap(x, y); DREP(i, LOG, 0) if (dfn[grand[y][i]] &gt; dfn[x]) y = grand[y][i]; return grand[y][0];}int col[maxn], last[maxn];int belong[maxn &lt;&lt; 1];struct query{ int l, r, t, id; bool operator &lt; (query b) const {return belong[l] &lt; belong[b.l] || belong[l] == belong[b.l] &amp;&amp; belong[r] &lt; belong[b.r] || belong[l] == belong[b.l] &amp;&amp; belong[r] == belong[b.r] &amp;&amp; t &lt; b.t;}}a[maxm], b[maxm];int cnt1, cnt2;bool vis[maxn &lt;&lt; 1];long long nowans, ans[maxm], cnt[maxw];void add(int x){ if (vis[x]) nowans -= 1ll * v[col[x]] * w[cnt[col[x]]--]; else nowans += 1ll * v[col[x]] * w[++cnt[col[x]]]; vis[x] ^= 1;}void modify(int x, int y){ if (vis[x]) { add(x); col[x] = y; add(x); } else col[x] = y;}int main(){#ifndef ONLINE_JUDGE freopen(\"4074.in\", \"r\", stdin); freopen(\"4074.out\", \"w\", stdout);#endif cin &gt;&gt; n &gt;&gt; m &gt;&gt; q; REP(i, 1, m) scanf(\"%d\", v + i); REP(i, 1, n) scanf(\"%d\", w + i); REP(i, 2, n) { int x, y; scanf(\"%d%d\", &amp;x, &amp;y); add(x, y);add(y, x); } LOG = log2(n); depth[1] = 1; dfs(1); REP(i, 1, n) scanf(\"%d\", col + i), last[i] = col[i]; int block_siz = pow(cur, 2. / 3); REP(i, 1, cur) belong[i] = (i-1) / block_siz; while (q--) { int opt, x, y; scanf(\"%d%d%d\", &amp;opt, &amp;x, &amp;y); if (!opt) { b[++cnt2] = (query){x, last[x], y}; last[x] = y; } else { if (dfn[x] &gt; dfn[y]) swap(x, y); a[++cnt1] = (query){lca(x, y) == x ? dfn[x] : low[x], dfn[y], cnt2, cnt1}; } } sort(a + 1, a + 1 + cnt1); int nowl(0), nowr(0), T(1); REP(i, 1, cnt1) { while (T &lt;= a[i].t) { modify(b[T].l, b[T].t); T++; } while (T &gt; a[i].t) { modify(b[T].l, b[T].r); T--; } while (nowl &lt; a[i].l) add(g[nowl++]); while (nowl &gt; a[i].l) add(g[--nowl]); while (nowr &lt; a[i].r) add(g[++nowr]); while (nowr &gt; a[i].r) add(g[nowr--]); int x(g[nowl]), y(g[nowr]), l(lca(x, y)); if (x ^ l &amp;&amp; y ^ l) { add(l); ans[a[i].id] = nowans; add(l); } else ans[a[i].id] = nowans; } REP(i, 1, cnt1) printf(\"%lld\\n\", ans[i]); return 0;}","link":"/2019/07/24/Luogu-4074-WC2013-ç³–æœå…¬å›­/"},{"title":"èƒ¡é—¹ tree","text":"é¢˜ç›®å¤§æ„ç»™ä½ ä¸€æ£µ$n\\le10^5$çš„æ ‘ï¼Œä½ åˆ†åˆ«æœ‰ç™½é“¾ã€é»‘é“¾$B,W\\le30000$æ¡ã€‚ ä½ è¦æŠŠæ ‘ä¸Šçš„ç‚¹æŸ“æˆé»‘ç™½ã€‚å¦‚æœä¸€æ¡ç™½é“¾é”åŒ…å«çš„ç‚¹éƒ½è¢«æŸ“æˆäº†ç™½è‰²ï¼Œé‚£ä½ ä¼šçš„å¾—åˆ°è¿™æ¡ç™½é“¾çš„å¥–åŠ±ï¼Œé»‘é“¾åŒç†ã€‚ æ±‚æœ€å¤§å¥–åŠ±ã€‚ è§£ææˆ‘ä»¬é¦–å…ˆå‡è®¾æ‰€æœ‰çš„é“¾éƒ½èƒ½é€‰ä¸Šå¹¶ä¸”ä¸å†²çªã€‚ é‚£ä¹ˆæˆ‘ä»¬åªè¦æœ€å°åŒ–æ¶ˆå»å†²çªçš„ä»£ä»·å°±å¯ä»¥äº†ã€‚ æ˜¯ä¸æ˜¯å¾ˆåƒæœ€å°å‰²ï¼Ÿ æˆ‘ä»¬æŠŠä¸€æ¡é“¾ä¸Šæ‰€åŒ…å«çš„ç‚¹å…¨éƒ¨è¿èµ·æ¥æ„æˆä¸€ä¸ªç½‘ç»œæµä¸Šçš„â€œå¤§ç‚¹â€ï¼Œç„¶åå°±æ˜¯åˆ†åˆ«å¤„ç†é»‘é“¾ã€ç™½é“¾ä¹‹é—´è¿è¾¹ï¼Œè·‘æœ€å°å‰²å°±å¯ä»¥äº†ã€‚ ä½†æ˜¯è¿™æ ·æ¯ä¸ªç‚¹ä¹‹é—´éƒ½å¯èƒ½ä¼šè¿ä¸€æ¡$inf$çš„è¾¹ï¼ˆè¡¨ç¤ºåœ¨éƒ½åœ¨ä¸€æ¡é“¾ä¸Šï¼Œå³æœ€å°å‰²éš”ä¸æ–­å®ƒï¼‰ï¼Œè¿™æ ·è¾¹æ•°å¯èƒ½ä¼šçˆ†ç‚¸ã€‚ æ€ä¹ˆåŠå‘¢ï¼Ÿè€ƒè™‘ä¼˜åŒ–è¿è¾¹ã€‚ ä¸€ç§å¯è¡Œçš„æ–¹æ³•æ˜¯ä¸Šçº¿æ®µæ ‘ ä¸€ä¸ªç®€å•çš„æ–¹æ³•æ˜¯å€å¢ï¼ŒæŠŠä¸€ä¸ªå¤§åŒºé—´å€å¢æˆå‡ ä¸ªå°åŒºé—´ï¼Œç„¶åå°åŒºé—´ä¹‹é—´è¿$inf$è¾¹æ¥æˆä¸ºå¤§åŒºé—´ï¼Œè€Œä¸æ˜¯ä¸€ä¸ªç‚¹ä¸€ä¸ªç‚¹åœ°è¿ã€‚ è¿™æ ·è¾¹æ•°å°±ä¼šæ˜¾è‘—å‡å°‘ï¼Œéšä¾¿æä¸€æå°±è¡Œäº†ã€‚ ä¼˜åŒ–æ—¶é™$10s$å¡å¸¸ï¼Ÿæ€ä¹ˆä¼˜åŒ–ï¼Ÿ ä¼˜åŒ–$lca$ï¼šåˆ©ç”¨$dfn$ï¼Œåªç”¨ä¸€æ¬¡å€å¢å°±å¯ä»¥æ±‚å‡º$lca$ã€‚è¿™ä¸ªç”¨å¤„ä¸å¤§ï¼Œå› ä¸ºè¿˜æœ‰æ›´å¥½çš„æ–¹æ³•æ±‚lca ä¼˜åŒ–$Dinic$ å½“å‰å¼§ä¼˜åŒ– åˆ†å±‚çš„æ—¶å€™ä»$T$å¼€å§‹åˆ†åˆ°$S$ï¼Œæˆ‘ä¹Ÿä¸çŸ¥é“ä¸ºä»€ä¹ˆè¿™æ ·ä¼šå¿«å¾ˆå¤šã€‚ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213//modify std//still learning#define REP(i, s, e) for (int i = s; i &lt;= e; i++)#define DREP(i, s, e) for (int i = s; i &gt;= e; i--)#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 10, inf = 1&lt;&lt;30;namespace dinic{ const int maxn = 4e6 + 10, maxm = 3e7 + 100; int bg[maxn], ne[maxm], to[maxm], w[maxm], e = 1; int S, T, dis[maxn], q[maxn], head, tail; int cur[maxn]; void add(int x, int y, int z) { e++; to[e] = y; ne[e] = bg[x]; bg[x] = e; w[e] = z; } void link(int a, int b, int c) {add(a, b, c);add(b, a, 0);} bool bfs() { REP(i, S, T) dis[i] = -1; dis[q[head = tail = 1] = T] = 0; while (head &lt;= tail) { int x = q[head++]; for (int i = bg[x]; i ;i = ne[i]) if (w[i ^ 1] &amp;&amp; dis[to[i]] == -1) dis[q[++tail] = to[i]] = dis[x] + 1; } return dis[S] != -1; } int dfs(int x, int y = inf) { if (x == T || !y) return y; int res = 0; for (int &amp;i = cur[x]; i ; i = ne[i]) if (w[i] &amp;&amp; dis[to[i]] == dis[x] - 1) { int temp = dfs(to[i], min(y, w[i])); if (temp &gt; 0) { res += temp; y -= temp; w[i] -= temp; w[i ^ 1] += temp; if (!y) break; } } return res; } void output() { REP(x, S, T) for (int i = bg[x];i;i=ne[i])printf(\"%d %d %d\\n\",x,to[i],w[i]); } int work() { int ans = 0; while (bfs()) { REP(i, S, T) cur[i] = bg[i]; ans += dfs(S); } return ans; }}int n, B, W, ans, LOG;int dfn[maxn], dfs_clock, grand[maxn][20], depth[maxn];namespace tree{ int bg[maxn], ne[maxn &lt;&lt; 1], to[maxn &lt;&lt; 1], e; void add(int x, int y) { e++; to[e] = y; ne[e] = bg[x]; bg[x] = e; } void dfs(int x) { dfn[x] = ++dfs_clock; REP(i, 1, LOG) grand[x][i] = grand[grand[x][i-1]][i-1]; for (int i = bg[x]; i ; i = ne[i]) if (to[i] ^ grand[x][0]) { grand[to[i]][0] = x; depth[to[i]] = depth[x] + 1; dfs(to[i]); } } void init() { LOG = log2(n); depth[1] = 1; dfs(1); } int lca(int x, int y) { if (x == y) return x; if (dfn[x] &gt; dfn[y]) swap(x, y); DREP(i, LOG, 0) if (dfn[grand[y][i]] &gt; dfn[x]) y = grand[y][i]; return grand[y][0]; }}using tree::add;using tree::lca;using dinic::link;int L[maxn][20], R[maxn][20];vector &lt;pair &lt;int, int&gt; &gt; E;int cur;void getl(int k, int t){ if (!L[k][t]) { L[k][t] = ++cur; getl(k, t - 1); getl(grand[k][t-1], t-1); link(L[k][t], L[k][t-1], inf); link(L[k][t], L[grand[k][t-1]][t-1], inf); }}int jump(int k, int d){ REP(i, 0, LOG) if (d &amp; (1 &lt;&lt; i)) k = grand[k][i]; return k;}void getr(int k, int t){ if (!R[k][t]) { R[k][t] = ++cur; getr(k, t - 1); getr(grand[k][t-1], t-1); link(R[k][t-1], R[k][t], inf); link(R[grand[k][t-1]][t-1], R[k][t], inf); }}void linkl(int k,int a,int c){ if (a==c) return; int t; for (t=0;(1&lt;&lt;(t+1))&lt;depth[a]-depth[c];t++); getl(a, t); link(k, L[a][t], inf); a = jump(a, depth[a]-depth[c]-(1&lt;&lt;t)); getl(a, t); link(k, L[a][t], inf);}void linkr(int k,int a,int c){ if (a==c) return; int t; for (t=0;(1&lt;&lt;(t+1))&lt;depth[a]-depth[c];t++); getr(a, t); link(R[a][t], k, inf); a = jump(a, depth[a]-depth[c]-(1&lt;&lt;t)); getr(a, t); link(R[a][t], k, inf);}int main(){#ifndef ONLINE_JUDGE freopen(\"B.in\",\"r\",stdin); freopen(\"B.out\",\"w\",stdout);#endif cin &gt;&gt; n &gt;&gt; B &gt;&gt; W;ans = n; REP(i, 2, n) { int x, y; scanf(\"%d%d\", &amp;x, &amp;y); add(x, y); } tree::init(); REP(i, 1, n) { L[i][0] = R[i][0] = ++cur; link(0, cur, 1); } while (B--) { int x, y, z, v; scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;v);z = lca(x, y); ++cur; ans += v; link(0, cur, v); linkl(cur, x, grand[z][0]); linkl(cur, y, z); } while (W--) { int x, y, z, v; scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;v);z = lca(x, y); ++cur; ans += v; E.push_back(make_pair(cur, v)); linkr(cur, x, grand[z][0]); linkr(cur, y, z); } dinic::T = ++cur; int siz = (int)E.size() - 1; REP(i, 0, siz) link(E[i].first, cur, E[i].second); REP(i, 1, n) link(i, cur, 1); cout &lt;&lt; ans - dinic::work() &lt;&lt; endl; return 0;}","link":"/2019/07/24/èƒ¡é—¹-tree/"},{"title":"èƒ¡é—¹ interval","text":"é¢˜ç›®å¤§æ„æœ‰ä¸€äº›å½¢å¦‚$[L,R]$çš„åŒºé—´ï¼Œä½ è¦é€‰å‡ºå°½å¯èƒ½å¤šçš„åŒºé—´ï¼Œå¹¶æ»¡è¶³åŒºé—´ä¸¤ä¸¤äº¤é›†ä¸ºç©ºï¼ˆæ³¨æ„$[X,X]$éç©ºï¼‰ã€‚ è¾“å‡ºå­—å…¸åºæœ€å°çš„æœ€ä¼˜æ–¹æ¡ˆã€‚ è§£æé¦–å…ˆå¯ä»¥æƒ³åˆ°ä¸€ä¸ªç®€å•çš„è´ªå¿ƒã€‚ æŠŠæ‰€æœ‰çš„åŒºé—´æŒ‰å³ç«¯ç‚¹æ’åºï¼Œèƒ½å–å°±å–ï¼Œè¿™æ ·ä¸€å®šæœ€ä¼˜ã€‚ å¦‚ä½•ç»´æŠ¤å­—å…¸åºæœ€å°ï¼Ÿ è€ƒè™‘äºŒåˆ†å†³ç­–ç‚¹ï¼Œç„¶åæš´åŠ›å¾€å›è·³ã€‚ ä¸ºä»€ä¹ˆæ˜¯å¯¹çš„ï¼ŸWO YE BU HUI Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#define REP(i, s, e) for (int i = s; i &lt;= e; i++)#define chkmin(a, b) a = min(a, b)#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;const int maxn = 200000 + 10;#define mid (l + r &gt;&gt; 1)int n, frm[maxn], last[maxn], dp[maxn], pos;struct line{ int l, r, id;}q[maxn];bool cmp(line A, line B) {return A.r &lt; B.r;}void jump(int x){ int a = x, b = last[x-1], mina(q[a].id), minb(q[b].id); while (frm[a] ^ frm[b]) { chkmin(mina, q[a].id), a = frm[a]; chkmin(minb, q[b].id), b = frm[b]; } chkmin(mina, q[a].id); chkmin(minb, q[b].id); if(mina &lt; minb) dp[x] = dp[pos] + 1, last[x] = x, frm[x] = last[pos]; else dp[x] = dp[x-1], last[x] = last[x-1], frm[x] = frm[x-1];}int stack[maxn], top;int main(){#ifndef ONLINE_JUDGE freopen(\"A.in\", \"r\", stdin); freopen(\"A.out\", \"w\", stdout);#endif cin &gt;&gt; n; REP(i, 1, n) scanf(\"%d%d\", &amp;q[i].l, &amp;q[i].r), q[i].id = i; sort(q + 1, q + 1 + n, cmp); REP(i, 1, n) { int l(0), r(i-1); pos = 0; while (l &lt;= r) if (q[mid].r &lt; q[i].l) { pos = mid; l = mid + 1; } else r = mid - 1; dp[i] = dp[pos] + 1; frm[i] = last[pos]; if (dp[i] &gt; dp[i-1]) dp[i] = dp[pos] + 1, last[i] = i; else if (dp[i] &lt; dp[i-1]) dp[i] = dp[i-1], last[i] = last[i-1]; else jump(i); } cout &lt;&lt; dp[n] &lt;&lt; endl; pos = last[n]; while(pos) stack[++top] = q[pos].id, pos = frm[pos]; sort(stack + 1, stack + 1 + top); REP(i, 1, top) printf(\"%d%c\", stack[i], i == top ? '\\n' : ' '); return 0;}","link":"/2019/07/23/èƒ¡é—¹-interval/"},{"title":"Luogu 2597 [ZJOI2012 ç¾éš¾]","text":"ä¼ é€é—¨ é¢˜ç›®å¤§æ„ä¸€ä¸ªé£Ÿç‰©ç½‘æœ‰$N$ä¸ªç‚¹ï¼Œä»£è¡¨$N$ç§ç”Ÿç‰©ï¼Œå¦‚æœç”Ÿç‰©$x$å¯ä»¥åƒç”Ÿç‰©$y$ï¼Œé‚£ä¹ˆä»$y$å‘$x$è¿ä¸€ä¸ªæœ‰å‘è¾¹ã€‚è¿™ä¸ªå›¾æ²¡æœ‰ç¯ã€‚ å›¾ä¸­æœ‰ä¸€äº›ç‚¹æ²¡æœ‰è¿å‡ºè¾¹ï¼Œè¿™äº›ç‚¹ä»£è¡¨çš„ç”Ÿç‰©éƒ½æ˜¯ç”Ÿäº§è€…ï¼Œå¯ä»¥é€šè¿‡å…‰åˆä½œç”¨æ¥ç”Ÿå­˜ï¼› è€Œæœ‰è¿å‡ºè¾¹çš„ç‚¹ä»£è¡¨çš„éƒ½æ˜¯æ¶ˆè´¹è€…ï¼Œå®ƒä»¬å¿…é¡»é€šè¿‡åƒå…¶ä»–ç”Ÿç‰©æ¥ç”Ÿå­˜ã€‚ å¦‚æœæŸä¸ªæ¶ˆè´¹è€…çš„æ‰€æœ‰é£Ÿç‰©éƒ½ç­ç»äº†ï¼Œå®ƒä¼šè·Ÿç€ç­ç»ã€‚ æˆ‘ä»¬å®šä¹‰ä¸€ä¸ªç”Ÿç‰©åœ¨é£Ÿç‰©ç½‘ä¸­çš„â€œç¾éš¾å€¼â€ä¸ºï¼Œå¦‚æœå®ƒçªç„¶ç­ç»ï¼Œé‚£ä¹ˆä¼šè·Ÿç€ä¸€èµ·ç­ç»çš„ç”Ÿç‰©çš„ç§æ•°ã€‚ ä¸¾ä¸ªä¾‹å­ï¼šåœ¨ä¸€ä¸ªè‰åœºä¸Šï¼Œç”Ÿç‰©ä¹‹é—´çš„å…³ç³»æ˜¯ï¼š å¦‚ å¦‚æœç¾Šéƒ½æ­»äº†ï¼Œé‚£ä¹ˆç‹¼ä¼šå› ä¸ºæ²¡æœ‰é£Ÿç‰©è€Œç­ç»ï¼Œè€Œå°å¼ºå¯ä»¥é€šè¿‡åƒç‰›ã€ç‰›å¯ä»¥é€šè¿‡åƒè‰æ¥ç”Ÿå­˜ä¸‹å»ã€‚æ‰€ä»¥ï¼Œç¾Šçš„ç¾éš¾å€¼æ˜¯$1$ã€‚ ä½†æ˜¯ï¼Œå¦‚æœè‰çªç„¶ç­ç»ï¼Œé‚£ä¹ˆæ•´ä¸ªè‰åŸä¸Šçš„$5$ç§ç”Ÿç‰©éƒ½æ— æ³•å¹¸å…ï¼Œæ‰€ä»¥ï¼Œè‰çš„ç¾éš¾å€¼æ˜¯$4$ã€‚ ç»™å®šä¸€ä¸ªé£Ÿç‰©ç½‘ï¼Œä½ è¦æ±‚å‡ºæ¯ä¸ªç”Ÿç‰©çš„ç¾éš¾å€¼ã€‚ è§£ææŠŠæ‰€æœ‰çš„è¾¹åå‘ï¼ŒæŒ‰æ—¶æ‹“æ‰‘åºå¤„ç†æŸä¸ªç‚¹ï¼Œè¿™æ ·å°±å¯ä»¥ä¿è¯å¤„ç†ä¸€ä¸ªç‚¹çš„æ—¶å€™ï¼Œè¿™ä¸ªç‚¹èƒ½åƒçš„ç‚¹éƒ½ä¼šè¢«åƒæ‰ã€‚ç°åœ¨æˆ‘ä»¬å‡è®¾å¤„ç†ä¸€ä¸ªç‚¹ä¹‹å‰ï¼Œå…¶ä»–çš„ç‚¹ç»Ÿç»Ÿéƒ½æ˜¯ä¸€æ£µæ ‘çš„å½¢æ€ã€‚ é‚£ä¹ˆè¿™ä¸ªç‚¹åƒçš„æ‰€æœ‰ï¼Œç­‰ä»·äºåƒåƒçš„æ‰€æœ‰çš„lcaã€‚ è¿™ä¸ªéšä¾¿ç»´æŠ¤ã€‚ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#define REP(i, s, e) for (int i = s; i &lt;= e; i++)#define DREP(i, s, e) for (int i = s; i &gt;= e; i--)#define DEBUG fprintf(stderr, \"Passing [%s] in Line %d\\n\", __FUNCTION__, __LINE__)#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cmath&gt;using namespace std;const int maxn = 70000 + 10, maxm = maxn;int bg[maxn], ne[maxn], to[maxn], e;void add(int x, int y){ e++; to[e] = y; ne[e] = bg[x]; bg[x] = e;}int n, k, depth[maxn], grand[maxn][20], LOG;int tcnt;vector &lt;int&gt; G[maxn], eat[maxn];int in[maxn], q[maxn], head, tail;int lca(int x, int y){ if (depth[x] &lt; depth[y]) swap(x, y); DREP(i, LOG, 0) if (depth[grand[x][i]] &gt;= depth[y]) x = grand[x][i]; if (x == y) return x; DREP(i, LOG, 0) if (grand[x][i] ^ grand[y][i]) x = grand[x][i], y = grand[y][i]; return grand[x][0];}int ans[maxn];void dfs(int x){ ans[x] = 1; for (int i = bg[x]; i ;i = ne[i]) { dfs(to[i]); ans[x] += ans[to[i]]; }}int main(){#ifndef ONLINE_JUDGE freopen(\"2597.in\", \"r\", stdin); freopen(\"2597.out\", \"w\", stdout);#endif cin &gt;&gt; n;LOG = log2(n); REP(i, 1, n) while (scanf(\"%d\", &amp;k), k) G[k].push_back(i), in[i]++, eat[i].push_back(k); REP(i, 1, n) if (!in[i]) depth[q[++tail] = i] = 1; while (head &lt;= tail) { int x = q[head++]; int siz = (int)G[x].size()-1; REP(i, 0, siz) if (!(--in[G[x][i]])) q[++tail] = G[x][i]; if (!eat[x].empty()) { siz = (int)eat[x].size() - 1; int l = eat[x][0]; REP(i, 1, siz) l = lca(l, eat[x][i]); grand[x][0] = l; depth[x] = depth[l] + 1; REP(j, 1, LOG) grand[x][j] = grand[grand[x][j-1]][j-1]; add(l, x); } } REP(i, 1, n) if(!ans[i])dfs(i); REP(i, 1, n) printf(\"%d\\n\", ans[i] - 1); return 0;}","link":"/2019/07/23/Luogu-2597-ZJOI2012-ç¾éš¾/"},{"title":"èƒ¡é—¹ reform","text":"é¢˜ç›®å¤§æ„ç»™ä½ ä¸¤ä¸ªé•¿åº¦åˆ†åˆ«ä¸º$n,m\\le10^6$çš„ä¸²$S,T$ã€‚ è¯¢é—®$S$ä¸­æœ‰å¤šå°‘å­ä¸²å¯ä»¥ç»è¿‡å˜æ¢å…¨ç­‰äº$T$ã€‚ å˜æ¢çš„å®šä¹‰æ˜¯äº¤æ¢æŸä¸ªå…ƒç´ ï¼Œå³æŠŠå…ƒç´ $x$ä¸å…ƒç´ $y$äº¤æ¢ã€‚ å¦‚$S=12321$ï¼Œ äº¤æ¢$1$å’Œ$2$å˜æˆ$S=21312$ äº¤æ¢$1$å’Œ$4$å˜æˆ$S=42324$ è§£æUPDï¼šåŠ äº†ä¸€ç‰‡å£èƒ¡ï¼Œå¯ä»¥searchä¸€ä¸‹ï¼ˆæ‡’å¾—æ”¾link)äº†ä¸ç”¨ç®¡å…·ä½“å…ƒç´ çš„å€¼ï¼Œåªéœ€è¦å…³å¿ƒä¸€ä¸‹ç¦»å®ƒæœ€è¿‘çš„ä¹‹å‰å‡ºç°çš„å®ƒå’Œä¹‹åå‡ºç°çš„å®ƒç¦»å®ƒçš„è·ç¦»ï¼ŒæŠŠè¿™ä¸ªè·ç¦»$Hash$ä¸€ä¸‹å°±å¯ä»¥äº†ã€‚ ç„¶åæ³¨æ„æåˆ°ç­”æ¡ˆçš„æ—¶å€™è¦åºŸæ‰åé¢çš„ä¸€äº›ä¸œè¥¿ï¼ˆå› ä¸ºç§»åŠ¨å­—ä¸²ç›¸å½“äºåˆ æ‰äº†ä¸²é¦–ï¼ŒåŠ å…¥äº†ä¸€ä¸ªæ–°å…ƒç´ ã€‚å¯¹äºä¸²é¦–åé¢çš„â€ä¹‹å‰å‡ºç°çš„â€è‡ªç„¶è¦æ›´æ–°ï¼Œä¹Ÿå°±æ˜¯è¦æ›´æ–°æœ€æ—©å‡ºç°çš„ä¹‹åçš„å®ƒï¼‰ è¯­æ–‡å¤ªèœï¼Œçœ‹Codeå§ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#define REP(i, s, e) for (int i = s; i &lt;= e ; i++)#define DREP(i, s, e) for (int i = s; i &gt;= e ; i--)#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;const int maxn = 1000000 + 10, maxm = 1000000 + 10;template &lt;typename T&gt; T read(){ T ans(0); char c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) { ans = ans * 10 + c - 48; c = getchar(); } return ans;}int n, m, a[maxn], b[maxm], c[maxn], s[maxn], t[maxm], temp[maxn + maxm &gt;&gt; 1];unsigned long long P = 131, bin[maxn], h, H;int ans, pos[maxn];int main(){#ifndef ONLINE_JUDGE freopen(\"A.in\", \"r\", stdin); freopen(\"A.out\", \"w\", stdout);#endif bin[0] = 1; REP(i, 1, 1e6) bin[i] = bin[i-1] * P; int Case(read&lt;int&gt;()), C(read&lt;int&gt;()); while (Case--) { n = read&lt;int&gt;();m = read&lt;int&gt;(); REP(i, 1, n) temp[i] = 0; REP(i, 1, n) s[i] = read&lt;int&gt;(), (a[i] = temp[s[i]] ? i - temp[s[i]] : m), temp[s[i]] = i; REP(i, 1, m) temp[i] = 0; REP(i, 1, m) t[i] = read&lt;int&gt;(), (b[i] = temp[t[i]] ? i - temp[t[i]] : m), temp[t[i]] = i; REP(i, 1, n) temp[i] = 0; DREP(i, n, 1) c[i] = temp[s[i]], temp[s[i]] = i; h = H = 0; REP(i, 1, m) H = H * P + b[i]; REP(i, 1, m) h = h * P + a[i]; ans = 0; if (h == H) pos[++ans] = 1; REP(i, 1, n - m) { h -= bin[m-1] * a[i]; if (c[i] &amp;&amp; c[i] &lt; i + m) h += bin[i-c[i]-1+m] * (m-a[c[i]]); a[c[i]] = m; h = h * P + a[i+m]; if (h == H) pos[++ans] = i + 1; } printf(\"%d\\n\", ans); REP(i, 1, ans) printf(\"%d%c\", pos[i], i == ans ? '\\n' : ' '); } return 0;}","link":"/2019/07/22/èƒ¡é—¹-reform/"},{"title":"èƒ¡é—¹ è€å›­ä¸ä¸å°å¸æœº","text":"é¢˜ç›®å¤§æ„ä½ æ˜¯ä¸€ä¸ªèµ„æœ¬å®¶ï¼Œä½ çš„èŠ±å›­ç»“æ„æ˜¯ä¸€æ£µ$n\\le3\\times10^5$ä¸ªèŠ‚ç‚¹çš„æ ‘ï¼Œæœ‰$m\\le 3\\times10^5$ä¸ªæ— äº§é˜¶çº§å¯ä»¥å¸®ä½ æ ‡è®°è·¯å¾„ï¼Œä½†åªèƒ½æ˜¯ä»ä¸€ä¸ªèŠ‚ç‚¹åˆ°å®ƒçš„æŸä¸€ä¸ªç¥–å…ˆã€‚ é›‡ä½£æŸä¸ªæ— äº§é˜¶çº§éœ€è¦å·¥èµ„ã€‚ä½ æƒ³çŸ¥é“è®©ä½ çš„èŠ±å›­é‡Œé¢æ‰€æœ‰çš„è¾¹éƒ½è¢«æ ‡è®°æ‰€éœ€è¦æ”¯ä»˜çš„æœ€å°å·¥èµ„ã€‚ å¦‚æœå…¨éƒ¨é›‡ä½£ä¹Ÿä¸å¤Ÿï¼Œä½ å°±ä¼šæ”¾ å¼ƒ æ€ è€ƒï¼Œè®¤ä¸ºéœ€è¦$-1$çš„å·¥èµ„ã€‚ è§£ææˆ‘ æ”¾ å¼ƒ äº† æ€ è€ƒã€‚ è€ƒè™‘æ ‘å½¢$dp$ï¼Œç”¨å·¦åæ ‘ç»´æŠ¤å†³ç­–ã€‚ å‘ç°å¯ä»¥ç»´æŠ¤æ— äº§é˜¶çº§æ·±åº¦æœ€é«˜ç‚¹ä¸ºå…³é”®å­—çš„å·¦åæ ‘æ¥ç»´æŠ¤å†³ç­–ï¼Œæ— è„‘ä¸Šä»£ç å³å¯ã€‚ æ³¨æ„æ‰“æ ‡è®°ã€‚ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#define REP(i, s, e) for (int i = s; i &lt;= e ; i++)#define DEBUG fprintf(stderr, \"Passing [%s] in Line %d\\n\", __FUNCTION__, __LINE__)#include &lt;iostream&gt;#include &lt;cstdio&gt;#define int long longusing namespace std;const int maxn = 300000 + 10, maxm = maxn, inf = 1ll &lt;&lt; 40;int bg[maxn], ne[maxm &lt;&lt; 1], to[maxm &lt;&lt; 1], e;void add(int x, int y){ e++; to[e] = y; ne[e] = bg[x]; bg[x] = e;}int depth[maxn];void dfs(int x, int fa = -1){ for (int i = bg[x]; i ; i = ne[i]) if (to[i] ^ fa) { depth[to[i]] = depth[x] + 1; dfs(to[i], x); }}struct worker{ int up, w, ne;}p[maxm &lt;&lt; 1];int cur = 300000;void insert(int x, int up, int w){ p[++cur] = (worker){up, w, p[x].ne}; p[x].ne = cur;}struct heap *null;heap* merge(heap *x, heap *y){};struct heap{ int up, f, Min, tag, dis; heap *l, *r; void pushdown() { if (tag) { f += tag; Min += tag; l -&gt; tag += tag; r -&gt; tag += tag; tag = 0; } } void pushup() { Min = min(f, min(l -&gt; Min + l -&gt; tag, r -&gt; Min + r -&gt; tag)); if (l -&gt; dis &lt; r -&gt; dis) swap(l, r); dis = r -&gt; dis + 1; } void pop() {*this = merge(l, r);}}pool[maxn], *now = pool, *root[maxn];heap* merge(heap *x, heap *y){ if (x == null) return y; if (y == null) return x; x -&gt; pushdown();y -&gt; pushdown(); if (x -&gt; up &lt;= y -&gt; up) swap(x, y); x -&gt; r = merge(x -&gt; r, y); x -&gt; pushup(); return x;}void solve(int x, int fa = -1){ int sum = 0; for (int i = bg[x]; i ; i = ne[i]) if (to[i] ^ fa) { solve(to[i], x); while (root[to[i]] -&gt; up &gt;= depth[to[i]]) root[to[i]].pop(); if (root[to[i]] == null) { cout &lt;&lt; -1 &lt;&lt; endl; exit(0); } sum += root[to[i]] -&gt; Min; } for (int i = p[x].ne; i ; i = p[i].ne) { *now = (heap) {p[i].up, sum + p[i].w, sum + p[i].w, 0, 1, null, null}; root[x] = merge(root[x], now++); } for (int i = bg[x]; i ; i = ne[i]) if (to[i] ^ fa) { int Min = root[to[i]] -&gt; Min; root[to[i]] -&gt; tag += sum - Min; root[x] = merge(root[x], root[to[i]]); } if (root[x] == null) { cout &lt;&lt; -1 &lt;&lt; endl; exit(0); }}int m, n, k;signed main(){#ifndef ONLINE_JUDGE freopen(\"A.in\", \"r\", stdin); freopen(\"A.out\", \"w\", stdout);#endif cin &gt;&gt; n &gt;&gt; m; REP(i, 2, n) { int x, y; scanf(\"%lld%lld\", &amp;x, &amp;y); add(x, y);add(y, x); } depth[1] = 1; dfs(1); REP(i, 1, m) { int u, v, w; scanf(\"%lld%lld%lld\", &amp;u, &amp;v, &amp;w); insert(u, depth[v], w); } null = new heap; null -&gt; l = null -&gt; r = null; null -&gt; Min = inf; REP(i, 1, n) root[i] = null; solve(1); printf(\"%lld\\n\", root[1] -&gt; Min + root[1] -&gt; tag); return 0;}","link":"/2019/07/21/èƒ¡é—¹-è€å›­ä¸ä¸å°å¸æœº/"},{"title":"èƒ¡é—¹ string","text":"é¢˜ç›®å¤§æ„å®šä¹‰ä¸¤ä¸ªå­—ç¬¦ä¸²åŒ¹é…ä¸ºå®ƒä»¬çš„æœ€å°å¾ªç¯è¡¨ç¤ºæ³•ç›¸åŒã€‚ç»™å®šä¸€ä¸ªæ¨¡å¼ä¸²å’Œ$n$ä¸ªä¸»ä¸²ï¼Œæ±‚æ¨¡å¼ä¸²å¯¹æ¯ä¸€ä¸ªä¸»ä¸²çš„æ¨¡å¼åŒ¹é…æ¬¡æ•°ã€‚ æœ€å°å¾ªç¯è¡¨ç¤ºæ³•ï¼šå¯¹ä¸€ä¸ªé•¿åº¦ä¸º$n$çš„å­—ç¬¦ä¸²åš$n$æ¬¡æ“ä½œï¼Œæ¯æ¬¡æŠŠç¬¬ä¸€ä¸ªå­—ç¬¦æ”¾åˆ°æœ€åã€‚è¿™$n$ä¸ªä¸²ä¸­å­—å…¸åºæœ€å°çš„ç§°ä¸ºæœ€å°å¾ªç¯è¡¨ç¤ºæ³• è§£æå¾ªç¯ä¸»ä¸²ä¸å¥½æï¼Œæˆ‘ä»¬å°±å¾ªç¯æ¨¡å¼ä¸²ã€‚ ç„¶åå¦‚æœå¾ªç¯åçš„æ¨¡å¼ä¸²åŒ¹é…ä¸Šäº†ï¼Œé‚£è¯´æ˜è¿™ä¸ªåŒ¹é…çš„åœ°æ–¹çš„æœ€å°è¡¨ç¤ºæ³•å’Œæ¨¡å¼ä¸²ä¸€å®šæ˜¯å¯ä»¥åŒ¹é…ä¸Šçš„ã€‚ ç›´æ¥ä¸€ä¸ª$Hash$èµ°äººã€‚ Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546#define REP(i, s, e) for (int i = s; i &lt;= e ; i++)#include &lt;bits/stdc++.h&gt;#define int unsigned long longusing namespace std;const int maxn = 100 + 5, maxlen = 1e6 + 10, P = 1e9 + 7;unordered_map &lt;int, bool&gt; cnt;int n, Hash[maxlen];char s[maxlen];int power_pow(int a, int b){ int ans = 1, base = a; while (b) { if (b &amp; 1) ans *= base; base *= base; b &gt;&gt;= 1; } return ans;}signed main(){#ifndef ONLINE_JUDGE freopen(\"B.in\", \"r\", stdin); freopen(\"B.out\", \"w\", stdout);#endif scanf(\"%s\", s + 1); int len = strlen(s + 1); REP(i, len + 1, len + len) s[i] = s[i-len]; REP(i, 1, len + len) Hash[i] = Hash[i-1] * P + s[i]; int PP = power_pow(P, len); REP(i, 1, len) cnt[Hash[i + len - 1] - Hash[i-1] * PP] = 1; cin &gt;&gt; n; while (n--) { scanf(\"%s\", s + 1); int Len = strlen(s + 1), ans(0); REP(i, 1, Len) Hash[i] = Hash[i-1] * P + s[i]; if (Len &gt;= len) REP(i, 1, Len - len + 1) ans += cnt[Hash[i + len - 1] - Hash[i-1] * PP]; printf(\"%llu\\n\", ans); } return 0;}","link":"/2019/07/21/èƒ¡é—¹-string/"},{"title":"èƒ¡é—¹ åºåˆ—","text":"é¢˜ç›®å¤§æ„ç»™å®šä¸€ä¸ªé•¿åº¦ä¸º$n\\le10^6$çš„åºåˆ—$x$ã€‚ ä½ éœ€è¦ä»åºåˆ—ä¸­é€‰å‡ºä¸€äº›ä½ç½®ã€‚å¯¹äºç¬¬$i$ä¸ªä½ç½®ï¼Œå¦‚æœå®ƒè¢«é€‰ä¸­ï¼Œä½ ä¼šè·å¾—$x_i$çš„æ”¶ç›Šï¼›å¦‚æœå®ƒæ²¡è¢«é€‰ä¸­ï¼Œæ‰¾åˆ°æœ€å°çš„$j$ä½¿å¾—ç¬¬$j$ä¸ªä½ç½®åˆ°ç¬¬$i$ä¸ªä½ç½®éƒ½æ²¡æœ‰è¢«é€‰ä¸­ï¼Œä½ éœ€è¦ä»˜å‡º$iâˆ’j+1$çš„ä»£ä»·ã€‚ æ­¤å¤–ï¼Œä½ é€‰å‡ºçš„ä½ç½®å¿…é¡»æ»¡è¶³$x_i$æ˜¯å•è°ƒä¸ä¸‹é™çš„ã€‚ æœ€å¤§åŒ–æ”¶ç›Šå‡å»ä»£ä»·çš„ç»“æœã€‚ è§£æå¯ä»¥å…ˆè€ƒè™‘ä¸€ä¸‹$x_i$å•è°ƒä¸é™çš„æƒ…å†µã€‚ è®¾$dp_i$è¡¨ç¤ºæœ€åä¸€ä¸ªé€‰çš„æ•°æ˜¯ç¬¬$i$ä¸ªçš„æœ€ä½³ç­”æ¡ˆï¼Œåˆ™ï¼š$$dp_i=x_i+max{dp_j+\\frac{(i-j)\\times(i-j-1)}{2}}$$è¿™ä¸ªä¸œè¥¿æ˜¯ä¸€ä¸ªéå¸¸æ¿å­çš„æ–œç‡ä¼˜åŒ–å¯¹å§ã€‚ ç„¶åæ€ä¹ˆè€ƒè™‘$x_i$æ— åºçš„æƒ…å†µå‘¢ï¼Ÿ æˆ‘ä»¬å‘ç°ï¼Œæˆ‘ä»¬é‡‡ç”¨çš„é¡ºåºæ˜¯å¯ä»¥æ¢çš„ã€‚ é‚£ä¹ˆæˆ‘ä»¬å¯¹$x_i$è¿›è¡Œåˆ†æ²»ï¼Œå°±æ˜¯æŠŠ$x_i$åˆ†æˆ$(l,r)$çš„åŒºé—´åˆ†åˆ«è®¡ç®—ç­”æ¡ˆï¼Œç„¶åå½’å¹¶ä¸€ä¸‹å°±å¥½äº†ã€‚ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586//for test ? why#define REP(i, s, e) for (int i = s; i &lt;= e ; i++)#include &lt;stdio.h&gt;#include &lt;algorithm&gt;typedef long long ll;namespace io { const int SIZE = (1 &lt;&lt; 21) + 1; char ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr; // getchar#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++) // print the remaining part inline void flush () { fwrite (obuf, 1, oS - obuf, stdout); oS = obuf; } // putchar inline void putc (char x) { *oS ++ = x; if (oS == oT) flush (); } // input a signed integer template &lt;class I&gt; inline void gi (I &amp;x) { for (f = 1, c = gc(); c &lt; '0' || c &gt; '9'; c = gc()) if (c == '-') f = -1; for (x = 0; c &lt;= '9' &amp;&amp; c &gt;= '0'; c = gc()) x = x * 10 + (c &amp; 15); x *= f; } // print a signed integer template &lt;class I&gt; inline void print (I &amp;x) { if (!x) putc ('0'); if (x &lt; 0) putc ('-'), x = -x; while (x) qu[++ qr] = x % 10 + '0', x /= 10; while (qr) putc (qu[qr --]); }}using io :: gi;using io :: putc;using io :: print;const int N = 1000005, G = 21;int n, a[N], id[N], rid[N], qu[N], ql, qr, pos[G][N], m; ll dp[N], ret;bool check (int x, int y, int z) { return (dp[z] - dp[y]) * (y - x) &gt;= (dp[y] - dp[x]) * (z - y); }void mergesort (int l, int r, int d) { if (l == r) return (void)(pos[d][l] = id[l]); int mi = (l + r) &gt;&gt; 1, i = l, j = mi + 1; mergesort (l, mi, d + 1); mergesort (mi + 1, r, d + 1); int *x = pos[d], *y = pos[d + 1], p = l; while (p &lt;= r) if (i &lt;= mi &amp;&amp; (y[i] &lt; y[j] || j &gt; r)) x[p ++] = y[i ++]; else x[p ++] = y[j ++];}void solve (int l, int r, int d) { if (l == r) { int u = id[l]; dp[u] += a[u] - (ll)u * u; return ; } int mi = (l + r) &gt;&gt; 1, i; solve (l, mi, d + 1); for (ql = 1, qr = 0, i = l; i &lt;= r; i ++) { int u = pos[d][i]; if (rid[u] &lt;= mi) { while (ql &lt; qr &amp;&amp; check (qu[qr - 1], qu[qr], u)) qr --; qu[++ qr] = u; } else { while (ql &lt; qr &amp;&amp; dp[qu[ql]] + (ll)u * qu[ql] &lt;= dp[qu[ql + 1]] + (ll)u * qu[ql + 1]) ql ++; if (ql &lt;= qr) dp[u] = std :: max (dp[u], dp[qu[ql]] + (ll)u * qu[ql]); } } solve (mi + 1, r, d + 1);}int main () { int i; for (gi (n), i = 1; i &lt;= n; i ++) gi (a[i]), id[i] = i, dp[i] = 0; std :: sort (id + 1, id + n + 1, [&amp;] (const int &amp;x, const int &amp;y) { return a[x] == a[y] ? x &lt; y : a[x] &lt; a[y]; }); for (i = 1; i &lt;= n; i ++) rid[id[i]] = i; ;mergesort (1, n, 0); solve (1, n, 0); for (ret = -(ll)n * (n + 1) / 2, i = 1; i &lt;= n; i ++) ret = std :: max (ret, dp[i] + (ll)i * (i + 1) / 2 - (ll)(n - i) * (n - i + 1) / 2); printf (\"%lld\\n\", ret); return 0;}","link":"/2019/07/20/èƒ¡é—¹-åºåˆ—/"},{"title":"èƒ¡é—¹ ä¸€è·¯ç•…é€š","text":"é¢˜ç›®å¤§æ„ç»™ä½ ä¸€ä¸ª$n\\le10^5$ä¸ªç‚¹ï¼Œ$m\\le2\\times10^5$çš„æ— å‘å›¾ï¼Œæ¯æ¡è¾¹æœ‰ä¸€ä¸ªæƒå€¼$a_i&lt;2^{31}$ã€‚ æ±‚ä¸€æ¡ä»$S$ç‚¹èµ°åˆ°$T$çš„è·¯å¾„ï¼Œè¿™æ¡è·¯å¾„ä¸Šçš„è¾¹æƒæœ€å¤§å€¼é™¤ä»¥è¾¹æƒæœ€å°å€¼åº”è¯¥å…¨å±€æœ€å°ï¼Œè¾“å‡ºè¿™ä¸ªå€¼ã€‚ è§£æè€ƒè™‘å…ˆæšä¸¾ä¸€ä¸ªä¸Šç•Œï¼Œç„¶åæˆ‘ä»¬è¦è®©è”é€šçš„ä¸‹ç•Œå°½é‡å¤§ã€‚ æ€ä¹ˆæšä¸¾ä¸Šç•Œå‘¢ï¼Ÿå¯ä»¥è€ƒè™‘æŠŠæ‰€æœ‰çš„è¾¹éƒ½æŒ‰è¾¹æƒä»å¤§åˆ°å°æ’åºï¼Œç„¶åç±»ä¼¼$Kruskal$çš„æ–¹æ³•æ¥åšã€‚ å¦‚æœæ–°åŠ å…¥ä¸€æ¡è¾¹ï¼Œè¿™æ¡è¾¹ä¸¤è¾¹æ˜¯ä¸è”é€šçš„ï¼Œé‚£å®ƒæ˜¾ç„¶æ˜¯è¦ä¿ç•™çš„ã€‚ ç„¶åå¦‚æœè¿™æ¡è¾¹ä¸¤è¾¹æ˜¯è”é€šçš„ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±åº”è¯¥æŠŠè¿™ä¸ªè”é€šå—ä¸­è¾¹æƒæœ€å°çš„è¾¹åˆ æ‰ï¼Œæ¢æˆç€ä¸€æ¡è¾¹ã€‚ å¯ä»¥å‘ç°ï¼Œè¿™ä¸ªè”é€šå—ä¸€å®šæ˜¯ä¸€æ£µæ ‘ã€‚ ç°åœ¨æˆ‘ä»¬è¦åšçš„äº‹æƒ…å˜æˆäº†ï¼š ç»´æŠ¤ä¸€ä¸ªæ£®æ— åŠ è¾¹ åˆ è¾¹ æŸ¥è¯¢æœ€å°å€¼ è¿™ä¸ªç”¨ä¸€ä¸ª$LCT$å°±å¯ä»¥ç»´æŠ¤å¥½äº†ã€‚ ç­”æ¡ˆæ€ä¹ˆè®¡ç®—ï¼Ÿéå¸¸ç®€å•ï¼Œå¤„ç†æ¯ä¸€æ¡è¾¹çš„æ—¶å€™éƒ½åº·åº·çœ‹çœ‹$S,T$æ˜¯å¦è”é€šï¼Œè”é€šçš„è¯å°±å°±æŸ¥è¯¢ä¸€ä¸‹æœ€å°å€¼å°±è¡Œäº†ï¼Œè¿™ä¸ªç›´æ¥ç”¨$Kruskal$é‡Œé¢çš„å¹¶æŸ¥é›†å°±å¯ä»¥ç»´æŠ¤äº†ã€‚ æ³¨æ„ä¸€ç‚¹ï¼Œè¾¹æƒéå¸¸å¤§ï¼Œ$inf$ä¸èƒ½å¼€å¤ªå¤§ï¼ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#define REP(i, s, e) for (int i = s; i &lt;= e; i++)#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;const int maxn = 100000 + 10, maxm = 200000 + 10, maxN = maxn + maxm;struct Edge{ int x, y, z;}E[maxN];bool cmp(Edge A, Edge B) {return A.z &gt; B.z;}int n, m, S, T;int f[maxN];int find(int x) {return f[x] == x ? f[x] : f[x] = find(f[x]);}void uni(int x, int y) {f[find(x)] = find(y);}int fa[maxN], ch[maxN][2], s[maxN];bool tag[maxN];#define ls(p) ch[p][0]#define rs(p) ch[p][1]#define get(x) (rs(fa[x]) == x)#define notroot(x) (ls(fa[x]) == x || rs(fa[x]) == x)void pushup(int x){ s[x] = x;s[0] = 0; if (E[s[x]].z &lt; E[s[ls(x)]].z) s[x] = s[ls(x)]; if (E[s[x]].z &lt; E[s[rs(x)]].z) s[x] = s[rs(x)];}void rotate(int x){ int y = fa[x], z = fa[y]; bool k = get(x); if (ch[x][k ^ 1]) fa[ch[x][k ^ 1]] = y; ch[y][k] = ch[x][k ^ 1]; if (notroot(y)) ch[z][get(y)] = x; fa[fa[y] = x] = z; ch[x][k ^ 1] = y; pushup(y);pushup(x);}void pushdown(int x){ if (!tag[x]) return; swap(ls(x), rs(x)); tag[ls(x)] ^= 1;tag[rs(x)] ^= 1; tag[x] = 0;}void pushall(int x){ if (notroot(x)) pushall(fa[x]); pushdown(x);}void splay(int x){ pushall(x); while (notroot(x)) { int y = fa[x]; if (notroot(y)) rotate(get(x) == get(y) ? y : x); rotate(x); }}void access(int x){ for (int t = 0; x; x = fa[t = x]) { splay(x); rs(x) = t; pushup(x); }}void makeroot(int x){ access(x); splay(x); tag[x] ^= 1;}void link(int x, int y){ makeroot(x); fa[x] = y;}void cut(int x, int y){ makeroot(x); access(y); splay(y); fa[x] = ls(y) = 0;}int query(int u, int v){ makeroot(u); access(v); splay(v); return s[v];}long long ansu = 1 &lt;&lt; 30, ansv = 1;int main(){#ifndef ONLINE_JUDGE freopen(\"B.in\", \"r\", stdin); freopen(\"B.out\", \"w\", stdout);#endif cin &gt;&gt; n &gt;&gt; m; REP(i, n + 1, n + m) scanf(\"%d%d%d\", &amp;E[i].x, &amp;E[i].y, &amp;E[i].z); cin &gt;&gt; S &gt;&gt; T; sort(E + n + 1, E + 1 + n + m, cmp); REP(i, 1, n) f[i] = i; REP(i, n + 1, n + m) { if (find(E[i].x) ^ find(E[i].y)) { uni(E[i].x, E[i].y); link(E[i].x, i); link(E[i].y, i); } else { int pos = query(E[i].x, E[i].y); if (E[pos].z &lt;= E[i].z) continue; cut(E[pos].x, pos); cut(E[pos].y, pos); link(E[i].x, i); link(E[i].y, i); } if (find(S) == find(T)) { int v = E[query(S, T)].z; if (ansu * E[i].z &gt;= ansv * v) ansu = v, ansv = E[i].z; } } if (ansu % ansv == 0) printf(\"%lld\\n\", ansu / ansv); else printf(\"%lld/%lld\\n\", ansu / __gcd(ansu, ansv), ansv / __gcd(ansu, ansv)); return 0;}","link":"/2019/07/19/èƒ¡é—¹-ä¸€è·¯ç•…é€š/"},{"title":"èƒ¡é—¹ å·ç§¯ç»ƒä¹ é¢˜","text":"é¢˜ç›®å¤§æ„ç»™å®šä¸¤ä¸ªé•¿åº¦ä¸º$n$çš„éè´Ÿæ•´æ•°æ•°ç»„$a,b$ï¼Œæ±‚$$\\sum_{i=1}^n\\sum_{j=1}^n\\lfloor\\sqrt{|a_i-b_j|}\\rfloor$$ Notes$1\\le n\\le 10^6$ï¼Œ$0\\le a_i,b_i\\le 3\\times 10^6$ï¼Œ$\\sum a_i,\\sum b_i\\le 10^7$ è§£æè¿™ä¸ªé¢˜ç›®å•Šï¼Œinterestingã€‚ æœ¬æ¥é¢˜ç›®åå­—å«åšâ€œå·ç§¯ç»ƒä¹ é¢˜â€ï¼Œä½†æ˜¯æ­£è§£å’Œå·ç§¯ä¸€ç‚¹å…³ç³»éƒ½æ²¡æœ‰ã€‚ ä¸€ä¸ªå¥—è·¯ï¼Œæˆ‘ä»¬æ³¨æ„åˆ°$0\\le a_i$å¹¶ä¸”$\\sum a_i\\le10^7$ï¼Œé‚£ä¹ˆæˆ‘ä»¬çŸ¥é“$a_i$çš„å–å€¼ä¸€å®šæ˜¯$O(\\sqrt{10^7})$çš„ï¼Ÿ ä¸ºä»€ä¹ˆå‘¢ï¼Ÿè€ƒè™‘æŠ½å±‰åŸç†ã€‚ä»$0$å¼€å§‹ï¼Œæ”¾$1,2,3,4â€¦$ï¼Œé‚£ä¹ˆæ”¾äº†$n$ä¸ªçš„æ—¶å€™ï¼Œå¿…ç„¶æœ‰$\\sum a_i\\ge\\frac{n\\times(n-1)}{2}$ã€‚ æ‰€ä»¥$a_i$å–å€¼ä¸€å®šæ˜¯$O(\\sqrt{10^7})$çš„ã€‚ æˆ‘ä»¬åˆæ³¨æ„åˆ°ï¼Œ$\\lfloor\\sqrt{|a_i-b_j|}\\rfloor\\le \\sqrt{10^7}â€‹$ã€‚ é‚£ä¹ˆå°±å¾ˆç®€å•äº†ï¼Œæšä¸¾$a$ä¸­æ¯ä¸€ä¸ªå‡ºç°çš„æ•°ï¼Œç„¶åæšä¸¾$\\lfloor\\sqrt{|a_i-b_j|}\\rfloor$ï¼Œ$b$ä¸­åˆæ³•çš„æ•°ä¸€å®šæ˜¯åœ¨ä¸¤ä¸ªåŒºé—´å†…ï¼Œç»Ÿè®¡çš„è¯ç›´æ¥åŠä¸€ä¸ªå‰ç¼€å’Œå°±å¥½äº†ã€‚ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#define REP(i, s, e) for (int i = s; i &lt;= e ;i++)#define chkmax(a, b) a = max(a, b)#define chkmin(a, b) a = min(a, b)#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#define double long double#define int long longusing namespace std;const int maxn = 1e6 + 10, maxL = 4200000;int n, ans, a[maxn], b[maxn], cnt[3000005];int s[3000005];signed main(){#ifndef ONLINE_JUDGE freopen(\"A.in\", \"r\", stdin); freopen(\"A.out\", \"w\", stdout);#endif cin &gt;&gt; n; REP(i, 1, n) scanf(\"%lld\", a + i), a[i]++; REP(i, 1, n) scanf(\"%lld\", b + i), b[i]++; if (n &lt;= 2000) { REP(i, 1, n) REP(j, 1, n) ans += floor(sqrt(abs(a[i] - b[j]))); } else { REP(i, 1, n) cnt[a[i]]++; REP(i, 1, n) s[b[i]]++; REP(i,1,3000001)s[i]+=s[i-1]; REP(A, 1, 3000001) if (cnt[A]) REP(C, 1, 1732) { int l, r; l = A - C * C - C * 2, r = A - C * C; if (max(l, 1ll) &lt;= min(r, 3000001ll)) { chkmax(l, 1ll);chkmin(l, 3000001ll); chkmax(r, 1ll);chkmin(r, 3000001ll); ans += C * cnt[A] * (s[r] - s[l-1]); } l = A + C * C, r = A + C * C + C * 2; if (max(l, 1ll) &lt;= min(r, 3000001ll)) { chkmax(l, 1ll);chkmin(l, 3000001ll); chkmax(r, 1ll);chkmin(r, 3000001ll); ans += C * cnt[A] * (s[r] - s[l-1]); } } } cout &lt;&lt; ans &lt;&lt; endl; return 0;}","link":"/2019/07/19/èƒ¡é—¹-å·ç§¯ç»ƒä¹ é¢˜/"},{"title":"èƒ¡é—¹ æ–æ³¢é‚£å¥‘","text":"é¢˜ç›®å¤§æ„æ±‚$$\\sum_{i=1}^n\\sum_{j=1}^mgcd(Fib_i,Fib_j)$$ æœ‰äººæå‡ºäº†ç¥å¥‡çš„è§£æ³•ã€‚ æ³¨æ„åˆ°ä¸€ä¸ªå¼å­ï¼š$$Fib_a\\times Fib_b+Fib_{a+1}\\times Fib_{b+1}=Fib_{a+b+1}$$é‚£ä¹ˆæˆ‘ä»¬å°±æœ‰ä¸€ä¸ªéå¸¸interestingçš„ç»“è®ºäº†ï¼š$$\\begin{align*}gcd(Fib_i,Fib_j)&amp;=gcd(Fib_j\\times Fib_{i-j+1}+Fib_{j-1}\\times Fib_{i-j},Fib_j)\\\\&amp;=gcd(Fib_{i-1}\\times Fib_{j-1},Fib_j)\\\\&amp;=Fib_{gcd(i,j)}\\end{align*}$$ ç„¶åæ€ä¹ˆåˆ©ç”¨è«æ¯”ä¹Œæ–¯åæ¼”å‘¢ï¼Ÿ è®°$f(k)â€‹$ä¸º$gcd(i,j)=kâ€‹$çš„$(i,j)â€‹$çš„å¯¹æ•°ï¼Œ$g(k)â€‹$è¡¨ç¤º$k|gcd(i,j)â€‹$çš„$i,jâ€‹$å¯¹æ•°ã€‚ ç„¶åæ¨å¼å­ï¼š$$\\begin{align*}Ans&amp;=\\sum_{k=1}^n f(k)\\times Fib_k\\\\&amp;=\\sum_{k=1}^n Fib_k\\times \\sum_{kâ€™|d}\\mu(\\frac{d}{kâ€™})\\times g(d)\\\\&amp;=\\sum_{k=1}^n Fib_k\\times \\sum_{kâ€™|d}\\mu(\\frac{d}{kâ€™})\\times \\lfloor\\frac{n}{d}\\rfloor\\lfloor\\frac{m}{d}\\rfloor\\end{align*}$$ç„¶åä¸Šæ¿å­å§ã€‚ latexæŒ‚äº†å¤§å®¶è‡ªæ±‚å¤šç¦å§ Code1234567891011121314151617181920212223242526272829303132333435363738394041#define REP(i, s, e) for (register int i = s; i &lt;= e ;i++)#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2e6 + 10, MOD = 1e9 + 7;int m, n, k;bitset &lt;maxn&gt; notprime;int p[maxn], x[maxn], p_cnt;int fib[maxn], u[maxn], ans;inline int mod(int x) {return x &gt;= MOD ? x - MOD : x;}int main(){#ifndef ONLINE_JUDGE freopen(\"B.in\", \"r\", stdin); freopen(\"B.out\", \"w\", stdout);#endif cin &gt;&gt; n &gt;&gt; m; REP(i, 2, n) { if (!notprime[i]) x[p[++p_cnt] = i] = i; REP(j, 1, p_cnt) { if (i * p[j] &gt; n) break; notprime[i * p[j]] = 1; x[i * p[j]] = p[j]; if (i % p[j] == 0) break; } } fib[1] = 1; REP(i, 2, n) fib[i] = mod(fib[i-1] + fib[i-2]); u[1] = 1; REP(i, 2, n) if (x[i] ^ x[i / x[i]]) u[i] = -u[i / x[i]]; REP(i, 1, n) for (register int j = 1; i * j &lt;= n; j++) ans += 1ll * u[j] * (n / i / j) * (m / i / j) % MOD * fib[i] % MOD, ans %= MOD; cout &lt;&lt; (ans + MOD) % MOD &lt;&lt; endl; return 0;}","link":"/2019/07/19/èƒ¡é—¹-æ–æ³¢é‚£å¥‘/"},{"title":"èƒ¡é—¹ æœ€å°è´¨å› æ•°","text":"é¢˜ç›®å¤§æ„æ±‚$[1,n]$ä¸­æ‰€æœ‰åˆæ•°çš„æœ€å°è´¨å› æ•°çš„$k$æ¬¡æ–¹å’Œï¼Œå¯¹$2^{64}$å–æ¨¡ã€‚ è§£æå­¦ä¹ äº†å­¦ä¹ äº†ï¼Œè¿™å¥½åƒæ˜¯ä¸€ä¸ªç»å…¸å¥—è·¯å§ã€‚ å°±æ˜¯è¯´æˆ‘ä»¬å…¶å®å¯¹äºæ¯ä¸€ä¸ªç´ æ•°$p$ï¼Œåªéœ€è¦ç®¡$[1,\\frac{n}{p}]$è¿™ä¸ªåŒºé—´ã€‚ é‚£æˆ‘ä»¬å°±å¯ä»¥è€ƒè™‘æŠŠæ‰€æœ‰çš„è´¨æ•°åˆ†æˆä¸¤éƒ¨åˆ†ã€‚ å°çš„éƒ¨åˆ†ç›´æ¥æš´åŠ›å®¹æ–¥ï¼ˆå¯ä»¥è®°å¿†åŒ–ä¸€ä¸‹ï¼Œå…·ä½“ç”¨$unordered\\_map$å½“å“ˆå¸Œè¡¨ï¼‰ã€‚ å¤§çš„éƒ¨åˆ†$\\frac{n}{p}$å°±æ¯”è¾ƒå°äº†ï¼Œå¯ä»¥ç›´æ¥ç­›ä¸€ä¸‹ã€‚ $pb\\_dsâ€‹$çš„$gp\\_hash\\_tableâ€‹$å¥½åƒæ˜¯å‡çš„ï¼Ÿ Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#define REP(i, s, e) for (int i = s; i &lt;= e ;i++)#include &lt;bits/stdc++.h&gt;#define ll long long#define ull unsigned llusing namespace std;const ll K = 170;ull power_pow(ull a, int b){ ull ans = 1, base = a; while (b) { if (b &amp; 1) ans *= base; base *= base; b &gt;&gt;= 1; } return ans;}ll p[38000], p_cnt;bitset &lt;450000&gt; notprime;void init(int N){ REP(i, 2, N) { if (!notprime[i]) p[++p_cnt] = i; REP(j, 1, p_cnt) { if (i * p[j] &gt; N) break; notprime[i * p[j]] = 1; if (i % p[j] == 0) break; } }}ll n, k;ull ans;unordered_map &lt;ll, ll&gt; rem;#define not_same_pos(x, y) ((x) * n + y)//make sure no å†²çªll dfs(int pos, ll cur, int flag){ if (rem[not_same_pos(pos, cur)]) return rem[not_same_pos(pos, cur)] * flag; if (!pos) return cur * flag; ll ret = dfs(pos-1, cur, flag); if (p[pos] &lt;= cur) ret += dfs(pos-1, cur / p[pos], -flag); rem[not_same_pos(pos, cur)] = ret * flag; return ret;}ll cnt, N;bitset &lt;200000000&gt; w;signed main(){#ifndef ONLINE_JUDGE freopen(\"A.in\", \"r\", stdin); freopen(\"A.out\", \"w\", stdout);#endif cin &gt;&gt; n &gt;&gt; k; init(sqrt(n) + 1); REP(i, 1, min(p_cnt, K)) ans += (dfs(i - 1, n / p[i], 1)-1) * power_pow(p[i], k); if (p_cnt &gt; K) { cnt = N = n / p[K+1]; REP(i, 1, K) for (int j = 1; p[i] * j &lt;= N; j++) if (!w[p[i] * j]) { w[p[i] * j] = 1; cnt--; } REP(i, K + 1, p_cnt) { ans += (cnt-1) * power_pow(p[i], k); if (i &lt; p_cnt) { N = n / p[i+1]; for (int j = n / p[i]; j &gt; N; j--) cnt -= !w[j]; for (int j = 1; p[i] * j &lt;= N; j++) if (!w[p[i] * j]) { w[p[i] * j] = 1; cnt--; } } } } cout &lt;&lt; ans &lt;&lt; endl; return 0;}","link":"/2019/07/18/èƒ¡é—¹-æœ€å°è´¨å› æ•°/"},{"title":"èƒ¡é—¹ æ–‡æœ¬ç¼–è¾‘å™¨","text":"é¢˜ç›®å¤§æ„ä½ è¦æ”¯æŒä»¥ä¸‹å‡ ç§æ“ä½œï¼š $I$ $x$ $a$ : åœ¨ç¬¬$x$ä¸ªå­—ç¬¦åé¢æ’å…¥å­—ç¬¦$a$ $D$ $x$ $y$ï¼šåˆ é™¤ä»$x$åˆ°$y$çš„è¿™ä¸€æ®µ $C$ $x$ $y$ $z$ ï¼šå¤åˆ¶ä»$x$åˆ°$y$è¿™ä¸€æ®µï¼Œç²˜è´´åˆ°ç¬¬$z$ä¸ªå­—ç¬¦åé¢ $P$ $x$ $y$ $z$ ï¼šæ‰“å°$x$æ¬¡ä¿®æ”¹æ“ä½œä¹‹å‰ï¼Œä»$y$åˆ°$z$è¿™ä¸€æ®µã€‚å…¶ä¸­ï¼Œ$x$ä¸è¶…è¿‡ä¸€ä¸ªç»™å®šçš„æ•°$M$ã€‚ ä¿è¯è¾“å…¥çš„æ‰€æœ‰æ•°åœ¨$int$èŒƒå›´å†…ã€‚ æ•°æ®è§„æ¨¡ä¸çº¦å®šå¯¹äº$40%$çš„æ•°æ®ï¼Œæ€»æ“ä½œæ•°å’Œä»»æ„æ—¶åˆ»å­—ç¬¦ä¸²çš„é•¿åº¦åœ¨$1000$ä»¥å†…ã€‚ å¯¹äº$100%$çš„æ•°æ®ï¼Œå­—ç¬¦ä¸²çš„å†…å®¹ä»…åŒ…å«å¤§å°å†™å­—æ¯å’Œæ•°å­—ï¼Œåˆå§‹å­—ç¬¦ä¸²çš„é•¿åº¦å’Œæ“ä½œæ•°ä¸è¶…è¿‡$100000$ ï¼Œ$M\\le 1000$ ã€‚ è§£æå°±æ˜¯è¯´ç”¨ä¸€ä¸ª$fhqâ€‹$æ¥ç»´æŠ¤ ç„¶åå¯æŒä¹…åŒ–ä¸€ä¸‹ï¼Œå°±æ˜¯$splitâ€‹$çš„æ—¶å€™æ–°å»ºç»“ç‚¹ã€‚ æœ‰ä»¥ä¸‹å¡å¸¸æŠ€å·§ï¼š æŒ‰ç§©åˆå¹¶ï¼ˆç„å­¦ï¼‰ $inlineï¼Œregisterâ€‹$ è¾“å‡ºçš„æ—¶å€™ä¸ä¸­åºéå†ï¼Œä¸€ä¸ªä¸€ä¸ªå¾€ä¸‹æ‰¾ï¼ˆç„å­¦ï¼‰ å°‘ä¼ å€ ç”¨è¿”å›$int$çš„$merge$è€Œä¸ç”¨ä¼ å€çš„$merge$ srand(å’•å’•å’•) Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#define REP(i, s, e) for (int i = s; i &lt;= e ;i++)#include &lt;bits/stdc++.h&gt;using namespace std;const int maxnode = 8e7 + 10;struct node{ int l, r, s; char c;}t[maxnode];int cur;inline int newnode(char c){ ++cur; t[cur].l = t[cur].r = 0; t[cur].c = c;t[cur].s = 1; return cur;}inline int copy(int x){ t[++cur] = t[x]; return cur;}inline void pushup(int x) {t[x].s = t[t[x].l].s + t[t[x].r].s + 1;}inline void split(int x, int &amp;a, int &amp;b, int siz){ if (!x) a = b = 0; else if (t[t[x].l].s &gt;= siz) { b = copy(x); split(t[b].l, a, t[b].l, siz); pushup(b); } else { a = copy(x); split(t[a].r, t[a].r, b, siz - t[t[x].l].s - 1); pushup(a); }}inline int merge(int a, int b){ if (!a || !b) return a ^ b; register int z; if (t[a].s &lt; t[b].s) z = b, t[z].l = merge(a, t[z].l); else z = a, t[z].r = merge(t[z].r, b); pushup(z); return z;}int rt[100000 + 10], now;int n, m;char c;inline int read(){ c = getchar(); while (!isdigit(c)) c = getchar(); int ans(0); while (isdigit(c)) ans = (ans &lt;&lt; 1) + (ans &lt;&lt; 3) + (c &amp; 15), c = getchar(); return ans;}inline void output(int _){ if (!_) return; output(t[_].l); putchar(t[_].c); output(t[_].r);}char ssr[10], s[100000 + 10];inline int build(int l, int r){ if (l &gt; r) return 0; int mid = l + r &gt;&gt; 1; int p = newnode(s[mid]); t[p].l = build(l, mid - 1); t[p].r = build(mid + 1, r); pushup(p); return p;}inline char query(int p, int k){ while (1) { if (t[t[p].l].s + 1 == k) return t[p].c; if (t[t[p].l].s + 1 &lt; k) k -= t[t[p].l].s + 1, p = t[p].r; else p = t[p].l; }}int pos, l, r, ccc, x, y, z;int main(){#ifndef ONLINE_JUDGE freopen(\"B.in\", \"r\", stdin); freopen(\"B.out\", \"w\", stdout);#endif t[0] = (node){0,0,0,'\\0'}; read(); scanf(\"%s\", s + 1); rt[0] = build(1, strlen(s + 1)); while (scanf(\"%s\", ssr) != EOF) if (ssr[0] == 'I') { pos = read(); scanf(\"%s\", ssr); ++now; x = y = 0; split(rt[now-1], x, y, pos); rt[now] = merge(merge(x, newnode(ssr[0])), y); } else if (ssr[0] == 'D') { l = read(), r = read(); ++now; x = y = z = 0; split(rt[now-1], x, y, l - 1); split(y, y, z, r - l + 1); rt[now] = merge(x, z); } else if (ssr[0] == 'C') { l = read(), r = read(), pos = read(); ++now; x = y = z = 0; split(rt[now-1], x, y, l - 1); split(y, y, z, r - l + 1); split(rt[now-1], x, z, pos); rt[now] = merge(merge(x, y), z); } else { ccc = read(), l = read(), r = read(); REP(i, l, r) putchar(query(rt[now-ccc], i)); putchar(10); } return 0;}","link":"/2019/07/17/èƒ¡é—¹-æ–‡æœ¬ç¼–è¾‘å™¨/"},{"title":"èƒ¡é—¹ å¤šé‡é›†åˆé—®é¢˜","text":"é¢˜ç›®å¤§æ„ç»´æŠ¤ä¸€é¢—æ ‘ï¼Œå…¹ç£ä»¥ä¸‹æ“ä½œï¼š å‘ä»¥$v$ä¸ºæ ¹çš„å­æ ‘çš„æ‰€æœ‰èŠ‚ç‚¹å„æ’å…¥$k$ä¸ªæ•°$z$ï¼ˆç›¸å½“äºæ¯ä¸ªèŠ‚ç‚¹å­˜äº†ä¸€äº›æ•°ï¼‰ è¯¢é—®æŸä¸ªèŠ‚ç‚¹$v$ä¸­æœ‰å¤šå°‘ä¸ªæ•°$x\\ xor\\ y\\le z$ï¼Œå…¶ä¸­$y,z$æ˜¯ç»™å‡ºçš„ æŠŠæ•´æ£µæ ‘çš„æ ¹æ¢æˆæŸä¸€ä¸ªèŠ‚ç‚¹$v$ $n,m\\le 140000$ è§£æé¦–å…ˆè€ƒè™‘æŸ¥è¯¢å‡è®¾æˆ‘ä»¬ç°åœ¨æœ‰ä¸€äº›æ•°ï¼Œç„¶åæŸ¥è¯¢æœ‰å¤šå°‘ä¸ªå¼‚æˆ–ä¸Š$y$ä¸å¤§äº$z$ æˆ‘ä»¬è€ƒè™‘æŠŠè¿™äº›æ•°å»ºä¸€ä¸ªäºŒè¿›åˆ¶çš„$Trie$ã€‚ è€ƒè™‘$z$çš„æœ€é«˜ä½ï¼Œå¦‚æœæ˜¯$1$ï¼Œé‚£ä¹ˆå°±å¯ä»¥æŠŠ$0$çš„$cnt$å…¨éƒ¨åŠ è¿›è´¡çŒ®ã€‚ å¦‚æœæ˜¯$0$ï¼Œåªèƒ½èµ°åˆ°$0$ã€‚ è¿™æ ·æ¯ä¸€ä½ç®—ä¸€ä¸‹å°±è¡Œã€‚ æ¥ç€è€ƒè™‘æ’å…¥å¯¹äºä¸€ä¸ªå­æ ‘çš„è¯ï¼Œå°±ç”¨æ ‘é“¾å‰–åˆ†çš„æ–¹æ³•å­˜$dfn$ï¼Œç„¶åæ˜ å°„å‡ºæ¥å°±æ˜¯ä¸€æ®µåŒºé—´ã€‚ è¿™æ ·çš„è¯ç›´æ¥$Trie$å’Œçº¿æ®µæ ‘å¥—ä¸€ä¸‹å°±å¯ä»¥äº†ã€‚ æœ€åè€ƒè™‘æ¢æ ¹æ¢æ ¹çš„è¯ï¼Œå½±å“çš„åªæ˜¯å­æ ‘çš„åŒºé—´ã€‚ åˆ¤ä¸€ä¸‹æ ¹åœ¨ä¸åœ¨åŒºé—´å†…å°±å¯ä»¥äº†ã€‚ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191#define REP(i, s, e) for (int i = s ; i &lt;= e; i++)#define DREP(i, s, e) for (int i = s ; i &gt;= e; i--)#define DEBUG fprintf(stderr, \"Passing [%s] in Line %d\\n\", __FUNCTION__, __LINE__)#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int maxn = 140000 + 10, maxm = 140000 + 10;int now = 1, root;int bg[maxn], ne[maxn &lt;&lt; 1], to[maxn &lt;&lt; 1], e = 1;void add(int x, int y){ e++; to[e] = y; ne[e] = bg[x]; bg[x] = e;}int fa[maxn], top[maxn], siz[maxn], depth[maxn], hvy[maxn];int dfn[maxn], bac[maxn], dfs_clock;void dfs1(int x){ siz[x] = 1; for (int i = bg[x]; i ; i = ne[i]) if (to[i] ^ fa[x]) { fa[to[i]] = x; depth[to[i]] = depth[x] + 1; dfs1(to[i]); siz[x] += siz[to[i]]; if (siz[to[i]] &gt; siz[hvy[x]]) hvy[x] = to[i]; }}void dfs2(int x, int y){ top[x] = y; dfn[x] = ++dfs_clock; if (hvy[x]) dfs2(hvy[x], y); for (int i = bg[x]; i ; i = ne[i]) if (to[i] ^ hvy[x] &amp;&amp; to[i] ^ fa[x]) dfs2(to[i], to[i]); bac[x] = dfs_clock;}int find(int x, int y){ while (1) { if (top[x] == top[y]) return hvy[y]; if (fa[top[x]] == y) return top[x]; x = fa[top[x]]; }}struct node{ int cnt; node *ls, *rs;}pool[55555555], *null, *node_cur = pool;node* newnode(){ node_cur -&gt; ls = node_cur -&gt; rs = null; return node_cur++;}#define mid (l + r &gt;&gt; 1)#define lson p -&gt; ls, l, mid#define rson p -&gt; rs, mid + 1, rvoid update(node *&amp;p, int l, int r, int pos, int val){ if (p == null) p = newnode(); p -&gt; cnt += val; if (l == r) return; if (pos &lt;= mid) update(lson, pos, val); else update(rson, pos, val);}int query(node *p, int l, int r, int pos){ if (p == null) return 0; if (l == r) return p -&gt; cnt; if (pos &gt; mid) return p -&gt; ls -&gt; cnt + query(rson, pos); else return query(lson, pos);}struct Trie{ node *t; Trie *ch[2];}t[4444444], *pt = t + 1;int ans[maxm];struct Query{ int id, y, z, ne; Query(){} Query(int _id, int _y, int _z, int _ne) : id(_id), y(_y), z(_z), ne(_ne) {} void query() { Trie* p = t; DREP(i, 29, 0) { if (z &gt;&gt; i &amp; 1) if (p -&gt; ch[((z^y)&gt;&gt;i&amp;1) ^ 1]) ans[id] += ::query(p -&gt; ch[((z^y)&gt;&gt;i&amp;1) ^ 1] -&gt; t, 1, now, id); p = p -&gt; ch[(z^y)&gt;&gt;i&amp;1]; if (!p) return; } ans[id] += ::query(p -&gt; t, 1, now, id); }}q[288888];int pq = 144444;void insert(int v, int id, int y, int z){ q[pq] = Query(id, y, z, q[v].ne); q[v].ne = pq++;}struct opt{ int t, k, x, v; opt(){} opt(int _t, int _k, int _x, int _v) : t(_t), k(_k), x(_x), v(_v) {} void modify() { Trie* p = ::t; DREP(l, 29, 0) { if (!p -&gt; ch[x &gt;&gt; l &amp; 1]) pt -&gt; t = newnode(), p -&gt; ch[x &gt;&gt; l &amp; 1] = pt++; p = p -&gt; ch[x &gt;&gt; l &amp; 1]; update(p -&gt; t, 1, now, t, k); } } bool operator &lt; (opt B) const {return v &lt; B.v;}}op[433333];int qcnt, Cur = 1;int m, n;signed main(){#ifndef ONLINE_JUDGE freopen(\"B.in\", \"r\", stdin); freopen(\"B.out\", \"w\", stdout);#endif cin &gt;&gt; n; REP(i, 2, n) { int x, y; scanf(\"%lld%lld\", &amp;x, &amp;y); add(x, y);add(y, x); } dfs1(1); dfs2(1, 1); null = pool + 55555500; t -&gt; t = newnode(); cin &gt;&gt; m; REP(i, 1, m) { int Opt;scanf(\"%lld\", &amp;Opt); if (Opt == 1) { int v, x, k; scanf(\"%lld%lld%lld\", &amp;v, &amp;x, &amp;k); if (dfn[v] &gt;= dfn[root] || dfn[root] &gt; bac[v]) if (v == root) op[++qcnt] = opt(now, k, x, 1); else { op[++qcnt] = opt(now, k, x, dfn[v]); op[++qcnt] = opt(now, -k, x, bac[v] + 1); } else { int temp = find(root, v); op[++qcnt] = opt(now, k, x, 1); op[++qcnt] = opt(now, -k, x, dfn[temp]); op[++qcnt] = opt(now, k, x, bac[temp] + 1); } } else if (Opt == 2) { int v, y, z; scanf(\"%lld%lld%lld\", &amp;v, &amp;y, &amp;z); insert(dfn[v], now++, y, z); } else scanf(\"%lld\", &amp;root); } sort(op + 1, op + qcnt + 1); REP(i, 1, n) { while (op[Cur].v == i) op[Cur++].modify(); for (int p = q[i].ne; p ; p = q[p].ne) q[p].query(); } REP(i, 1, now - 1) printf(\"%lld\\n\", ans[i]); return 0;}","link":"/2019/07/16/èƒ¡é—¹-å¤šé‡é›†åˆé—®é¢˜/"},{"title":"æ¨¡æ¿ ä¸‰ç»´ååº","text":"ä¼ é€é—¨ é¢˜ç›®å¤§æ„ç©ºé—´å†…æœ‰$n$ä¸ªç‚¹$(x_i,y_i,z_i)$ã€‚å®šä¹‰$f(i)=\\sum_{j=1}^n [x_j\\le x_i, y_j\\le x_j, z_j\\le z_i, i \\not=j]$ã€‚æ±‚$f(i),i\\in[0,n)$ã€‚ è§£æ³•é¦–å…ˆå¯ä»¥æŠŠæ‰€æœ‰çš„ç‚¹æŒ‰ç¬¬ä¸€ç»´æ’åºã€‚ç„¶åå¯¹äºç¬¬äºŒç»´ï¼Œå¯¹ä¸æ‰€æœ‰ç¬¬äºŒç»´å¤§äºç­‰äºè¿™ä¸ªç‚¹çš„ä½ç½®è®°å½•å­˜åœ¨ä¸€ä¸ªè¿™ä¸ªç‚¹çš„ç¬¬ä¸‰ç»´ã€‚ç„¶åå°±å¯ä»¥ç®€å•åœ°ç”¨å¹³è¡¡æ ‘ç»Ÿè®¡ç¬¬ä¸‰ç»´å¾—å‡ºç­”æ¡ˆäº†ã€‚ç¬¬äºŒç»´çš„è¯å°±å¯ä»¥ç®€å•çš„ç”¨ä¸€ä¸‹æ ‘çŠ¶æ•°ç»„æä¸€æã€‚ ç”±äºé¢˜ç›®ä¸­å¯ä»¥å¤§äºç­‰äºï¼Œé‚£ä¹ˆæˆ‘ä»¬æŠŠæ‰€æœ‰ç¬¬ä¸€ç»´ç›¸åŒçš„å…¨éƒ¨è®°å½•å®Œå†ç®—å®ƒä»¬çš„ç­”æ¡ˆã€‚å…·ä½“çœ‹ä»£ç å–½ã€‚ Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#define DREP(i, s, e) for(int i = s; i &gt;= e ;i--)#define REP(i, s, e) for(int i = s; i &lt;= e ;i++)#define DEBUG fprintf(stderr, \"Passing [%s] in Line %d\\n\", __FUNCTION__, __LINE__)#define chkmax(a, b) a = max(a, b)#define chkmin(a, b) a = min(a, b)#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1000000 + 10, maxk = 2000000;template &lt;typename T&gt; inline T read(){ T ans(0), p(1); char c = getchar(); while (!isdigit(c)) { if (c == '-') p = -1; c = getchar(); } while (isdigit(c)) { ans = ans * 10 + c - 48; c = getchar(); } return ans * p;}int n, k;struct flower{ int s, c, m, id; flower(){} flower(int _s, int _c, int _m, int _id) : s(_s), c(_c), m(_m), id(_id){}}f[maxn];bool cmp(flower A, flower B) {return A.s &lt; B.s;}vector &lt;int&gt; s[maxn];void update(int c, int m){ while (c &lt;= k) { s[c].insert(lower_bound(s[c].begin(), s[c].end(), m), m); c += c &amp; -c; } // REP(i, c, cmax)s[i].insert(lower_bound(s[i].begin(), s[i].end(), m), m);}int ans[maxn];int query(int c, int m){ int res = 0; while (c &gt; 0) { res += lower_bound(s[c].begin(), s[c].end(), m+1) - s[c].begin(); c -= c &amp; -c; } return res-1;}int cnt[maxn];int main(){#ifdef CraZYali freopen(\"B.in\", \"r\", stdin); freopen(\"B.out\", \"w\", stdout); freopen(\"B.err\", \"w\", stderr);#endif cin &gt;&gt; n &gt;&gt; k; REP(i, 1, n) { int s(read&lt;int&gt;()), c(read&lt;int&gt;()), m(read&lt;int&gt;()); f[i] = flower(s, c, m, i); } sort(f + 1, f + 1 + n, cmp); // REP(i, 1, n) printf(\"%d %d %d %d\\n\", f[i].s, f[i].c, f[i].m, f[i].id); int last = 1; REP(i, 1, n) { if (i &gt; 1 &amp;&amp; f[i].s ^ f[i-1].s) { REP(j, last, i-1) cnt[ans[f[j].id] = query(f[j].c, f[j].m)]++;//, puts(\"----\"), cerr &lt;&lt; f[i].id &lt;&lt; ' ' &lt;&lt; ans[f[i].id] &lt;&lt; endl; last = i; } update(f[i].c, f[i].m); } REP(i, last, n) cnt[ans[f[i].id] = query(f[i].c, f[i].m)]++;//, puts(\"----\"), cerr &lt;&lt; f[i].id &lt;&lt; ' ' &lt;&lt; ans[f[i].id] &lt;&lt; endl; REP(i, 0, n-1) printf(\"%d\\n\", cnt[i]); // REP(i, 1, n) fprintf(stderr, \"%d\\n\", ans[i]); return 0;}","link":"/2019/07/07/æ¨¡æ¿-ä¸‰ç»´ååº/"},{"title":"Luogu 2042 [NOI2005 ç»´æŠ¤æ•°åˆ—]","text":"ä¼ é€é—¨å·¥ä¸šé¢˜ï¼Œçˆ½æ­ªæ­ªã€‚ é¢˜ç›®å¤§æ„ è§£æ³•ç»´æŠ¤ä¸€ä¸‹åŒºé—´å’Œ$sum$ï¼Œä»å·¦ç«¯ç‚¹å¼€å§‹çš„æœ€å¤§å­æ®µå’Œ$lmax$ï¼Œä»¥å³ç«¯ç‚¹ç»“æŸçš„æœ€å¤§å­æ®µå’Œ$rmax$ã€‚$pushup$å¯èƒ½æŒºç®€å•çš„ã€‚ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240#define REP(i, s, e) for (int i = s; i &lt;= e; i++)#define DREP(i, s, e) for (int i = s; i &gt;= e; i--)#define DEBUG fprintf(stderr, \"Passing [%s] in Line %lld\\n\", __FUNCTION__, __LINE__)#define chkmax(a, b) a = max(a, (b))#define chkmin(a, b) a = min(a, (b))#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int maxn = 500000 + 10, inf = 1ll&lt;&lt;40;template &lt;typename T&gt; T read(){ T ans(0), flag(1); char c(getchar()); while (!isdigit(c)) { if (c == '-') flag = -1; c = getchar(); } while (isdigit(c)) { ans = ans * 10 + c - 48; c = getchar(); } return ans * flag;}void file(string s){ freopen((s + \".in\").c_str(), \"r\", stdin); freopen((s + \".out\").c_str(), \"w\", stdout); freopen((s + \".err\").c_str(), \"w\", stderr);}struct node{ int l, r, s, order, val, sum, lmax, rmax, max_sum, tag_reverse, tag_same; bool need; node() : l(0), r(0), s(0), order(0), val(0), sum(0), lmax(0), rmax(0), max_sum(0), tag_reverse(0), tag_same(0), need(0) {} node(int _val) : l(0), r(0), s(1), order(rand()), val(_val), sum(_val), lmax(_val), rmax(_val), max_sum(_val), tag_reverse(0), need(0){};}t[maxn];int s[maxn], top, root;int create(int val){ int id = s[top--]; t[id] = node(val); return id;}void recycle(int x) {s[++top] = x;}#define max3(x, y, z) max(max(x, y), z)void same(int x, int v){ if (!x) return; t[x].tag_same = v; t[x].need = 1; t[x].val = v; t[x].sum = v * t[x].s; if (v &gt;= 0) t[x].lmax = t[x].rmax = t[x].max_sum = t[x].sum; else t[x].lmax = t[x].rmax = t[x].max_sum = v;}void pushdown(int x){ if (!x) return; t[0].lmax=t[0].rmax=t[0].max_sum=-1e9; int &amp;l(t[x].l), &amp;r(t[x].r); if (t[x].tag_reverse) { t[x].tag_reverse = 0; t[l].tag_reverse ^= 1; t[r].tag_reverse ^= 1; swap(l, r); swap(t[x].lmax, t[x].rmax); } if (t[x].need) { if (l) same(l, t[x].tag_same); if (r) same(r, t[x].tag_same); t[x].need = 0; }}void pushup(int x){ if (!x) return; int l = t[x].l, r = t[x].r; if(l) pushdown(l); if(r) pushdown(r); t[x].s = t[l].s + t[r].s + 1; t[x].sum = t[l].sum + t[r].sum + t[x].val; t[x].lmax = max(t[l].lmax, t[l].sum + max(t[r].lmax, 0ll) + t[x].val); t[x].rmax = max(t[r].rmax, t[r].sum + max(t[l].rmax, 0ll) + t[x].val); t[x].max_sum = max3( t[l].max_sum, t[r].max_sum, max(t[l].rmax, 0ll) + t[x].val + max(t[r].lmax, 0ll));}void merge(int &amp;x, int a, int b){ if (!a || !b) x = a + b; else { if (t[a].order &gt; t[b].order) { pushdown(b); merge(t[x = b].l, a, t[b].l); } else { pushdown(a); merge(t[x = a].r, t[a].r, b); } pushup(x); }}void split(int x, int &amp;a, int &amp;b, int siz){ if (!x) a = b = 0; else { pushdown(x); if (t[t[x].l].s &gt;= siz) split(t[b = x].l, a, t[x].l, siz); else split(t[a = x].r, t[x].r, b, siz - t[t[x].l].s - 1); pushup(x); }}int GET(int pos){ int x(0), y(0), z(0); split(root, x, y, pos - 1); split(y, y, z, 1); int ans = t[y].val; merge(y, y, z); merge(root, x, y); return ans;}void INSERT(int pos, int a[], int len){ int x(0), y(0); split(root, x, y, pos); REP(i, 1, len) merge(x, x, create(a[i])); merge(root, x, y);}void del(int y){ if (!y) return; del(t[y].l); del(t[y].r); recycle(y);}void DELETE(int pos, int tot){ int x(0), y(0), z(0); split(root, x, y, pos - 1); split(y, y, z, tot); merge(root, x, z); del(y);}void MAKE_SAME(int pos, int tot, int c){ int x(0), y(0), z(0); split(root, x, y, pos - 1); split(y, y, z, tot); same(y, c); merge(y, y, z); merge(root, x, y);}void REVERSE(int pos, int tot){ int x(0), y(0), z(0); split(root, x, y, pos - 1); split(y, y, z, tot); t[y].tag_reverse ^= 1; merge(y, y, z); merge(root, x, y);}int GET_SUM(int pos, int tot){ int x(0), y(0), z(0); split(root, x, y, pos - 1); split(y, y, z, tot); int ans = t[y].sum; merge(y, y, z); merge(root, x, y); return ans;}void PUSH_BACK(int val){ int z(create(val)); merge(root, root, z);}int m, n, a[maxn];char ss[20];signed main(){#ifdef CraZYali file(\"2042\");#endif srand((unsigned long long)new char); top = 500000; REP(i, 1, top) s[i] = i; cin &gt;&gt; n &gt;&gt; m; REP(i, 1, n) PUSH_BACK(read&lt;int&gt;()); while (m--) { scanf(\"%s\", ss + 1); if (ss[1] == 'I') { int pos(read&lt;int&gt;()), tot(read&lt;int&gt;()); REP(i, 1, tot) a[i] = read&lt;int&gt;(); INSERT(pos, a, tot); n += tot; } else if (ss[1] == 'D') { int pos(read&lt;int&gt;()), tot(read&lt;int&gt;()); DELETE(pos, tot); n -= tot; } else if (ss[1] == 'M' &amp;&amp; ss[3] == 'K') { int pos(read&lt;int&gt;()), tot(read&lt;int&gt;()); MAKE_SAME(pos, tot, read&lt;int&gt;()); } else if (ss[1] == 'R') { int pos(read&lt;int&gt;()), tot(read&lt;int&gt;()); REVERSE(pos, tot); } else if (ss[1] == 'G') { int pos(read&lt;int&gt;()), tot(read&lt;int&gt;()); printf(\"%lld\\n\", GET_SUM(pos, tot)); } else printf(\"%lld\\n\", t[root].max_sum); // REP(i, 1, n) GET(i); } return 0;}","link":"/2019/07/07/Luogu-2042-NOI2005-ç»´æŠ¤æ•°åˆ—/"},{"title":"Luogu 4197 [ONTAK2010 Peaks]","text":"ä¼ é€é—¨åƒåœ¾BZOJï¼Œåˆè¿‡ä¸äº†æˆ‘çš„å¤§å¸¸æ•°ã€‚ é¢˜ç›®å¤§æ„ç»™ä½ ä¸€ä¸ª$N\\le 10^5$ä¸ªç‚¹$M\\le 5\\times 10^5$æ¡è¾¹çš„æ— å‘å›¾ï¼Œæ¯æ¡è¾¹æœ‰è¾¹æƒï¼Œæ¯ä¸ªç‚¹æœ‰ç‚¹æƒã€‚æ¯æ¬¡ç»™ä½ ä¸€ç»„$v,x,k$ï¼Œè¯¢é—®ä»$v$å¼€å§‹ç»è¿‡ä¸è¶…è¿‡$x$çš„è·¯å¯ä»¥èµ°åˆ°çš„æ‰€æœ‰ç‚¹ä¸­çš„ç¬¬$k$å¤§ã€‚æ— è§£è¾“å‡º$-1$ã€‚ è§£ææ˜¾ç„¶è¿™ä¸ªä¸œè¥¿æ˜¯åœ¨æœ€å°ç”Ÿæˆæ ‘ä¸Šè·‘ã€‚è¿™ä¸ªä¸è¶…è¿‡$x$çš„ä¸œè¥¿æœ‰ä¸€ç±»æ–¹æ³•ã€‚è¿™ä¸ªä¸œè¥¿å«åšKruskalé‡æ„æ ‘ã€‚ Kruskalé‡æ„æ ‘æˆ‘ä»¬è€ƒè™‘æŠŠè¾¹æ”¹æˆç‚¹ã€‚è¿˜æ˜¯Kruskalæ±‚æœ€å°ç”Ÿæˆæ ‘çš„è¿‡ç¨‹ï¼Œä½†æ˜¯æˆ‘ä»¬â€œä¸åŠ è¾¹â€ã€‚æ–¹ä¾¿è¡¨è¾¾ï¼Œä¸‹é¢è¯´çš„éƒ½æ˜¯ä»£è¡¨äº†è”é€šå—çš„èŠ‚ç‚¹ã€‚å…·ä½“æ¥è¯´ï¼Œå‡è®¾æˆ‘ä»¬ç°åœ¨è¦å§$u,v$ä¹‹é—´æƒå€¼ä¸º$w$çš„è¾¹å¼„åˆ°æœ€å°ç”Ÿæˆæ ‘ä¸­å»ã€‚é‚£ä¹ˆæˆ‘ä»¬å°±newä¸€ä¸ª$fa$ï¼Œè®©è¿™ä¸ª$fa$çš„æƒå€¼ä¸º$w$ï¼Œç„¶åè¿™ä¸ª$fa$å‘$u,v$è¿è¾¹ã€‚å®¹æ˜“å‘ç°ï¼Œè¿™æ ·æˆ‘ä»¬å°±ä¼šnewå‡ºä¸€é¢—æ–°æ ‘æ¥ï¼Œè¿™æ£µæ ‘å°±æ˜¯Kruskalé‡æ„æ ‘ã€‚ é‚£ä¹ˆè¿™æ£µæ ‘æœ‰ä¸¤ä¸ªéå¸¸å¥½çš„æ€§è´¨ï¼š åŸç”Ÿæˆæ ‘çš„èŠ‚ç‚¹éƒ½æ˜¯å¶å­èŠ‚ç‚¹ï¼ˆæ˜¾ç„¶ï¼‰ éå¶å­èŠ‚ç‚¹çš„æƒå€¼ä¸€å®šä¸è¶…è¿‡å…¶çˆ¶äº²çš„æƒå€¼ï¼ˆæŒ‰Kruskalçš„é¡ºåºåŠ è¾¹ï¼Œè‡ªç„¶åæ¥çš„è¾¹æƒå€¼ä¸å°äºå…ˆæ¥çš„è¾¹ï¼‰æ‰€ä»¥è¯´ï¼Œä»ä¸€ä¸ªç‚¹å‡ºå‘ï¼Œåªè¦æ‰¾åˆ°å®ƒçš„æƒå€¼ä¸è¶…è¿‡$x$æœ€è€ç¥–å…ˆï¼Œç„¶åä»¥å®ƒä¸ºæ ¹çš„å­æ ‘çš„æ‰€æœ‰å¶å­èŠ‚ç‚¹å°±éƒ½å¯ä»¥åˆ°äº†ã€‚ è¿™é¢˜è¦æ±‚$kth$ï¼Œå¥—ä¸€ä¸ªä¸»å¸­æ ‘å°±å¯ä»¥å•¦ã€‚ç»†èŠ‚ç¨å¾®æ³¨æ„ä¸€ä¸‹ã€‚ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169#define REP(i, s, e) for (int i = s; i &lt;= e; i++)#define DREP(i, s, e) for (int i = s; i &gt;= e; i--)#define DEBUG fprintf(stderr, \"Passing [%s] in Line %d\\n\", __FUNCTION__, __LINE__)#define chkmax(a, b) a = max(a, (b))#define chkmin(a, b) a = min(a, (b))#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;queue&gt;using namespace std;const int maxn = 1e5 + 10, maxm = 5e5 + 10, n_log_n = 3600000;int bg[maxn &lt;&lt; 1], to[maxm], ne[maxm], e;inline void add(int x, int y){ e++; to[e] = y; ne[e] = bg[x]; bg[x] = e;}int fa[maxn &lt;&lt; 1];int find(int x) {return fa[x] == x ? fa[x] : fa[x] = find(fa[x]);}void file(string s){ freopen((s + \".in\").c_str(), \"r\", stdin); freopen((s + \".out\").c_str(), \"w\", stdout);}int n, m, q, cur, M;int val[maxn &lt;&lt; 1];struct Edge{ int x, y, z; Edge() {} Edge(int _x, int _y, int _z) : x(_x), y(_y), z(_z) {}}E[maxm];bool cmp(Edge A, Edge B) {return A.z &lt; B.z;}int N, grand[maxn &lt;&lt; 1][25], LOG, Left[maxn &lt;&lt; 1], Right[maxn &lt;&lt; 1];int dfn[maxn], dfs_clock, vv[maxn];void prepare(int x){ if (x &lt;= n) vv[Left[x] = Right[x] = dfn[x] = ++dfs_clock] = val[x]; bool flag = 0; for (int i = bg[x]; i ; i = ne[i]) if (to[i] ^ grand[x][0]) { grand[to[i]][0] = x; prepare(to[i]); if (x &gt; n) if (!flag) {Left[x] = Left[to[i]];Right[x] = Right[to[i]];flag = 1;} else { chkmin(Left[x], Left[to[i]]); chkmax(Right[x], Right[to[i]]); } }}void output(int x){ for (int i = bg[x]; i ; i = ne[i]) if (to[i] ^ grand[x][0]) { printf(\"%d %d\\n\", x, to[i] &lt;= n&amp;&amp;0 ? dfn[to[i]] : to[i]); output(to[i]); }}int a[maxn], b[maxn];int rt[n_log_n], ls[n_log_n], rs[n_log_n], sum[n_log_n], nd_cur;#define mid (l + r &gt;&gt; 1)#define lson ls[p], l, mid#define rson rs[p], mid + 1, rvoid build(int pre, int &amp;p, int l, int r, int pos){ p = ++nd_cur; ls[p] = ls[pre]; rs[p] = rs[pre]; sum[p] = sum[pre] + 1; if (l == r) return; if (pos &lt;= mid) build(ls[pre], lson, pos); else build(rs[pre], rson, pos);}int query(int u, int v, int l, int r, int k){ if (l &gt;= r) return l; int x = sum[ls[v]] - sum[ls[u]]; if (x &lt; k) return query(rs[u], rs[v], mid + 1, r, k - x); else return query(ls[u], ls[v], l, mid, k);}int main(){#ifdef CraZYali file(\"4197\");#endif cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;cur = n; REP(i, 1, n) scanf(\"%d\", val + i); REP(i, 1, n * 2) fa[i] = i; REP(i, 1, m) { int x, y, z; scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;z); E[i] = Edge(x, y, z); } sort(E + 1, E + 1 + m, cmp); int cnt = 0; REP(i, 1, m) { int x(find(E[i].x)), y(find(E[i].y)); if (x ^ y) { val[++cur] = E[i].z; add(cur, x); add(cur, y); fa[x] = fa[y] = cur; if (++cnt == n - 1) break; } } N = n + n - 1; prepare(cur); LOG = log2(N); REP(j, 1, LOG) REP(i, 1, N) grand[i][j] = grand[grand[i][j-1]][j-1]; // REP(i, n+1, N) // printf(\"%d %d %d\\n\", i, Left[i], Right[i]);// output(cur); REP(i, 1, n) a[i] = b[i] = vv[i];// al[dfn[i]]; sort(b + 1, b + 1 + n); M = unique(b + 1, b + 1 + n) - b - 1; REP(i, 1, n) build(rt[i-1], rt[i], 1, M, lower_bound(b + 1, b + 1 + M, a[i]) - b);// REP(i, 1, n) printf(\"%d%c\", dfn[i], i == n ? '\\n' : ' ' );// REP(i, 1, n) printf(\"%d%c\", vv[i], i == n ? '\\n' : ' ' );// REP(i, 1, n) printf(\"%d%c\", a[i], i == n ? '\\n' : ' ' );// REP(i, 1, M) printf(\"%d%c\", b[i], i == M ? '\\n' : ' ' );// REP(i, 1, n) printf(\"%d%c\", lower_bound(b+1,b+1+M,a[i])-b, i == n ? '\\n' : ' ' );// REP(i, 1, n)// REP(j, i, n)// REP(k, 1, j - i + 1)// printf(\"%d %d %d %d\\n\", i, j, k, b[query(T[i-1], T[j], 1, M, k)]); while (q--) { int v, x, k; scanf(\"%d%d%d\", &amp;v, &amp;x, &amp;k);// cout &lt;&lt; v &lt;&lt; \" -&gt; \"; DREP(i, LOG, 0) if (!grand[v][i]) continue; else if (val[grand[v][i]] &lt;= x) v = grand[v][i];// cout &lt;&lt; v &lt;&lt; \"\\n\";// cout &lt;&lt; Left[v] &lt;&lt; ' ' &lt;&lt; Right[v] &lt;&lt; endl; int len = Right[v] - Left[v] + 1; printf(\"%d\\n\", k &gt; len ? - 1 : b[query(rt[Left[v]-1], rt[Right[v]], 1, M, len - k + 1)]); } return 0;}","link":"/2019/07/02/Luogu-4197-ONTAK2010-Peaks/"},{"title":"Luogu 2444 [POI2000 ç—…æ¯’]","text":"ä¼ é€é—¨è¿™é¢˜ç›®å¾ˆå¥½éª—åˆ†å•Šã€‚ é¢˜ç›®å¤§æ„æœ‰ä¸€äº›ç”±$0,1$æ„æˆçš„ç—…æ¯’ä»£ç ï¼Œè¯¢é—®å­˜ä¸å­˜åœ¨ä¸€ä¸ªæ— é™é•¿çš„$01$ä»£ç ä¸åŒ…å«ç—…æ¯’ä»£ç ã€‚ è§£æå»ºä¸€ä¸ªACè‡ªåŠ¨æœºå‡ºæ¥ã€‚è€ƒè™‘ä¸€ä¸ªæ™®é€šçš„æ–‡æœ¬ä¸²åŒ¹é…çš„æƒ…å†µï¼Œå¦‚æœåŒ¹é…ä¸ä¸Šçš„è¯å°±ä¸ä¼šåŒ…å«ç—…æ¯’ä»£ç ã€‚ä½†æ˜¯æ–‡æœ¬ä¸²æ˜¯æ— é™é•¿çš„ï¼Œé‚£åŒ¹é…ä¸ä¸Šå°±åªèƒ½æ˜¯æŒ‡é’ˆåœ¨ACè‡ªåŠ¨æœºä¸Šé¢çš„ä¸€ä¸ªç¯ä¸Šå¾ªç¯ã€‚æ‰€ä»¥æˆ‘ä»¬çŸ¥é“å­˜ä¸å­˜åœ¨ä¸€ä¸ªä¸åŒ…å«å±é™©ç»“ç‚¹çš„ç¯å°±å¯ä»¥å•¦ã€‚å±é™©ç»“ç‚¹å°±æ˜¯å¯ä»¥åŒ¹é…ä¸Šçš„ç»“ç‚¹ï¼Œé‚£ä¹ˆæ˜¾ç„¶æ‰€æœ‰failæŒ‡å‘å±é™©ç»“ç‚¹çš„ç»“ç‚¹å’ŒTrieä¸Šæœ‰ç»“æŸæ ‡è®°çš„ç»“ç‚¹éƒ½æ˜¯å±é™©ç»“ç‚¹ã€‚è¿™é‡Œæ‰¾ç¯å¾ˆå¥½æ‰¾ï¼Œç”±äºfailåªä¼šæŒ‡å‘æ¯”å½“å‰èŠ‚ç‚¹æ·±åº¦æµ…çš„ç»“ç‚¹ï¼Œæ‰€ä»¥ç›´æ¥ä¸€édfså°±å¯ä»¥äº†ã€‚ Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#define REP(i, s, e) for (int i = s; i &lt;= e; i++)#define DREP(i, s, e) for (int i = s; i &gt;= e; i--)#define DEBUG fprintf(stderr, \"Passing [%s] in Line %d\\n\", __FUNCTION__, __LINE__)#define chkmax(a, b) a = max(a, b)#define chkmin(a, b) a = min(a, b)#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;const int maxn = 2000 + 10, maxlen = 30000 + 10, sumS = maxlen;int ch[sumS][3], fail[sumS], rt, cur;bool End[sumS];void insert(char s[]){ int now = rt; for (int i = 1; s[i]; i++) now = !ch[now][s[i]] ? ch[now][s[i]] = ++cur : ch[now][s[i]]; End[now] = 1;}int q[sumS], head, tail;void build(){ head = 1; REP(i, 1, 2) if (ch[0][i]) q[++tail] = ch[0][i]; while (head &lt;= tail) { int x = q[head++]; if (End[fail[x]]) End[x] = 1; REP(i, 1, 2) if (ch[x][i]) fail[q[++tail] = ch[x][i]] = ch[fail[x]][i]; else ch[x][i] = ch[fail[x]][i]; }}bool vis[sumS], ins[sumS];void dfs(int x = rt){ if (ins[x]) {puts(\"TAK\");exit(0);} if (vis[x] || End[x]) return; vis[x] = ins[x] = 1; REP(i, 1, 2) if (ch[x][i]) dfs(ch[x][i]); ins[x] = 0;}int n;char s[maxlen];int main(){#ifdef CraZYali freopen(\"2444.in\", \"r\", stdin); freopen(\"2444.out\", \"w\", stdout);#endif cin &gt;&gt; n; while (n--) { scanf(\"%s\", s + 1); for (int i = 1; s[i]; i++) s[i] -= '0'-1; insert(s); } build();#ifdef CraZYali REP(i, 1, cur) printf(\"%d%c\", (int)fail[i], i == cur ? '\\n' : ' '); REP(i, 1, cur) printf(\"%d%c\", (int)End[i], i == cur ? '\\n' : ' ');#endif dfs(); puts(\"NIE\"); return 0;}","link":"/2019/04/02/Luogu-2444/"},{"title":"åˆé›† æ–œç‡ä¼˜åŒ–","text":"æ˜¨å¤©æ™šä¸Šè‚äº†å‡ é“æ–œç‡ä¼˜åŒ–çš„é¢˜ï¼Œè¿™é‡Œä¸€èµ·æŠŠé¢˜è§£å†™äº†å§ã€‚ BZOJ 1096é¢˜ç›®å¤§æ„æœ‰$n\\le 10^6$ä¸ªå·¥å‚ï¼Œæ¯ä¸ªå·¥å‚çš„ä½ç½®åœ¨$x_i$ï¼Œæœ‰$p_i$ä¸ªå­˜è´§ã€‚å¯ä»¥åœ¨å·¥å‚å¤„å»ºé€ ä»“åº“ï¼Œåœ¨ç¬¬$i$ä¸ªå·¥å‚å»ºé€ ä»“åº“çš„èŠ±è´¹æ˜¯$c_i$ã€‚æ¯ä¸ªå·¥å‚çš„å­˜è´§ä¸èƒ½å¾€ç¼–å·å°çš„ä»“åº“è¿ä¸œè¥¿ã€‚ä¸€ä¸ªå•ä½è´§ç‰©è¿é€ä¸€ä¸ªå•ä½é•¿åº¦éœ€è¦ä¸€ä¸ªèŠ±è´¹ã€‚æ±‚æœ€å°çš„æ€»è´¹ç”¨ã€‚ è§£æè€ƒè™‘dpã€‚è®¾$s1_i=\\sum_{k\\in[1,i]} p_k$ï¼Œ$s2_i=\\sum_{k\\in[1,i]} p_k\\times x_k$ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥æ¨å‡ºè¿™ä¸ªæ–¹ç¨‹ï¼š$$dp_i=min(dp_j + c_i + \\sum_{k\\in[j+1,i]}(x_i-x_j)\\times p_j)=min(dp_j+c_i-(s2_i-s2_j)+x_i\\times(s1_i-s1_j))$$å¥—è·¯ä¸€æ³¢ï¼Œå‡è®¾$k$æ¯”$j$ä¼˜ç§€ï¼ˆ$k&gt;j$ï¼‰ï¼Œé‚£ä¹ˆï¼š$$dp_k+c_i-(s2_i-s2_k)+x_i\\times(s1_i-s1_k)&lt;dp_j+c_i-(s2_i-s2_j)+x_i\\times(s1_i-s1_j)$$éšä¾¿æ¨ä¸€ä¸‹å¼å­ï¼Œåº”è¯¥å°±å¯ä»¥å‘ç°ï¼š$$dp_k-dp_j+s2_k-s2_j&lt;x_i\\times(s1_k-s1_j)$$$$\\frac{dp_k-dp_j+s2_k-s2_j}{s1_k-s1_j}&lt;x_i$$é‚£ä¹ˆæ–œç‡å°±å‡ºæ¥äº†ï¼Œç›´æ¥ä¸Šå¥—è·¯æ¿å­å°±å¯ä»¥äº†ã€‚æ—¶é—´å¤æ‚åº¦$O(n)$ã€‚ Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#define DREP(i, s, e) for(int i = s; i &gt;= e ;i--)#define REP(i, s, e) for(int i = s; i &lt;= e ;i++)#define DEBUG fprintf(stderr, \"Passing [%s] in Line %d\\n\", __FUNCTION__, __LINE__)#define chkmax(a, b) a = max(a, b)#define chkmin(a, b) a = min(a, b)#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;#define int long longconst int maxn = 1e6 + 10;template &lt;typename T&gt; inline T read(){ T ans(0), p(1); char c = getchar(); while (!isdigit(c)) { if (c == '-') p = -1; c = getchar(); } while (isdigit(c)) { ans = ans * 10 + c - 48; c = getchar(); } return ans * p;}int n, x[maxn], p[maxn], c[maxn], dp[maxn], s1[maxn], s2[maxn];int q[maxn], head, tail;double K(int k, int j) {return (s2[j] - s2[k] + dp[j] - dp[k]) * 1. / (s1[j] - s1[k]);}signed main(){#ifdef CraZYali freopen(\"1096.in\", \"r\", stdin); freopen(\"1096.out\", \"w\", stdout);#endif cin &gt;&gt; n; REP(i, 1, n) x[i] = read&lt;int&gt;(), p[i] = read&lt;int&gt;(), c[i] = read&lt;int&gt;(); REP(i, 1, n) s1[i] = s1[i-1] + p[i], s2[i] = s2[i-1] + x[i] * p[i]; REP(i, 1, n) { while (head &lt; tail &amp;&amp; K(q[head + 1], q[head]) &lt; x[i]) head++; dp[i] = dp[q[head]] + c[i] + x[i] * (s1[i-1] - s1[q[head]]) - (s2[i-1] - s2[q[head]]); while (head &lt; tail &amp;&amp; K(q[tail - 1], i) &lt; K(q[tail], q[tail - 1])) tail--; q[++tail] = i; } cout &lt;&lt; dp[n] &lt;&lt; endl; return 0;} BZOJ 1911é¢˜ç›®å¤§æ„ä¸€ä¸ªéƒ¨é˜Ÿä¸­æœ‰$n\\le 10^6$ä¸ªäººï¼Œæ¯ä¸ªäººçš„æˆ˜æ–—åŠ›ä¸º$x_i$ã€‚å‡è®¾ä¸€å¨äººçš„æˆ˜æ–—åŠ›æ€»å’Œä¸º$x$ï¼Œé‚£ä¹ˆä»–ä»¬æœ€ç»ˆçš„æˆ˜æ–—åŠ›ä¸º$ax^2+bx+c$ã€‚ä¸€å¨äººçš„ç¼–å·è¦è¿ç»­ï¼Œæœ€å¤§åŒ–æœ€ç»ˆçš„æˆ˜æ–—åŠ›ã€‚ è§£æè®¾$s_i=\\sum_{k\\in[1,i]} x_k$ï¼Œåˆ™ï¼š$$dp_i=max(dp_j+a\\times(s_i-s_j)^2+b\\times(s_i-s_j)+c)$$å¥—è·¯ï¼š$$dp_k-dp_j&lt;a\\times(s_k-s_j)\\times(2s_i-s_k-s_j)+b(s_k-s_j)$$$$\\frac{\\frac{dp_k-dp_j}{s_k-s_j}-b}{a}+s_k+s_j&lt;2s_i$$ç„¶åä¸Šæ¿å­ Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#define DREP(i, s, e) for(int i = s; i &gt;= e ;i--)#define REP(i, s, e) for(int i = s; i &lt;= e ;i++)#define DEBUG fprintf(stderr, \"Passing [%s] in Line %d\\n\", __FUNCTION__, __LINE__)#define chkmax(a, b) a = max(a, b)#define chkmin(a, b) a = min(a, b)#include &lt;iostream&gt;#include &lt;cstdio&gt;#define int long longusing namespace std;const int maxn = 1e6 + 10;template &lt;typename T&gt; inline T read(){ T ans(0), p(1); char c = getchar(); while (!isdigit(c)) { if (c == '-') p = -1; c = getchar(); } while (isdigit(c)) { ans = ans * 10 + c - 48; c = getchar(); } return ans * p;}int n, a, b, c, s[maxn], dp[maxn];int q[maxn], head, tail;double K(int k, int j) {return ((dp[k] - dp[j]) * 1. / (s[k] - s[j]) - b) / a + s[k] + s[j];}signed main(){#ifdef CraZYali freopen(\"1911.in\", \"r\", stdin); freopen(\"1911.out\", \"w\", stdout);#endif cin &gt;&gt; n &gt;&gt; a &gt;&gt; b &gt;&gt; c; REP(i, 1, n) { s[i] = s[i-1] + read&lt;int&gt;(); while (head &lt; tail &amp;&amp; K(q[head+1], q[head]) &lt; 2 * s[i]) head++; int ret = s[i] - s[q[head]]; dp[i] = dp[q[head]] + a * ret * ret + b * ret + c; while (head &lt; tail &amp;&amp; K(q[tail-1], i) &lt; K(q[tail-1], q[tail])) tail--; q[++tail] = i; } cout &lt;&lt; dp[n] &lt;&lt; endl; return 0;} BZOJ 4518é¢˜ç›®å¤§æ„ç”±$n\\le 3000$æ¡è·¯$L_i$ï¼Œåˆ†æˆ$m$å¤©èµ°ï¼Œæœ€å°åŒ–æ¯å¤©èµ°çš„è·¯ç¨‹çš„æ–¹å·®ã€‚è®¾æ–¹å·®ä¸º$v$ï¼Œè¾“å‡º$v\\times m^2$ã€‚ è§£ææˆ‘ä»¬è®¾æ€»è·¯ç¨‹ä¸º$sum$ï¼Œç¬¬$i$å¤©èµ°çš„è·¯ç¨‹ä¸º$l_i$ï¼Œé‚£ä¹ˆæˆ‘ä»¬æ¨ä¸€ä¸‹æ–¹å·®ï¼šè¦æœ€å°åŒ–ç­”æ¡ˆï¼Œåªè¦æœ€å°åŒ–$W=\\sum_{i\\in[1,m]}l_i^2$å°±å¯ä»¥äº†ã€‚è®¾$dp_{i,cur}$è¡¨ç¤ºå·²ç»$cur$å¤©èµ°äº†$i$æ®µè·¯çš„æœ€å°$W$ï¼Œè®°$s_i=\\sum_{k\\in[1,m]}L_k$ï¼Œæˆ‘ä»¬å¯ä»¥å†™å‡ºå¦‚ä¸‹æ–¹ç¨‹ï¼š$$dp_{i,cur}=min(dp_{j,cur-1}+(s_i-s_j)^2)$$å¥—è·¯ä¸€æ³¢ï¼Œè®¾$a(x)=dp_{x,cur-1}$ï¼Œç„¶åè®¾$k&gt;j$æ¯”$j$ä¼˜ç§€ï¼Œé‚£ä¹ˆï¼š$$a(k)+(s_i-s_k)^2&lt;a(j)+(s_i-s_j)^2$$$$a(k)-a(j)&lt;(2s_i-s_j-s_k)\\times(s_k-s_j)$$$$\\frac{a(k)-a(j)}{s_k-s_j}+s_j+s_k&lt;2s_i$$ç„¶åå°±å¯ä»¥å¥—è·¯ä¸Šæ¿å­äº†ã€‚æ—¶é—´å¤æ‚åº¦$O(n\\times m)$ã€‚ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#define DREP(i, s, e) for(int i = s; i &gt;= e ;i--)#define REP(i, s, e) for(int i = s; i &lt;= e ;i++)#define DEBUG fprintf(stderr, \"Passing [%s] in Line %d\\n\", __FUNCTION__, __LINE__)#define chkmax(a, b) a = max(a, b)#define chkmin(a, b) a = min(a, b)#include &lt;iostream&gt;#include &lt;cstdio&gt;#define int long longusing namespace std;const int maxn = 3000 + 10, inf = 2e9;template &lt;typename T&gt; inline T read(){ T ans(0), p(1); char c = getchar(); while (!isdigit(c)) { if (c == '-') p = -1; c = getchar(); } while (isdigit(c)) { ans = ans * 10 + c - 48; c = getchar(); } return ans * p;}int n, m, l[maxn], s[maxn], a[maxn];int q[maxn], head, tail;int dp[maxn][2];bool cur;int A(int x) {return dp[x][cur ^ 1];}double K(int j, int k) {return (A(j) - A(k)) * 1. / (s[j] - s[k]) + s[j] + s[k];}signed main(){#ifdef CraZYali freopen(\"4518.in\", \"r\", stdin); freopen(\"4518.out\", \"w\", stdout);#endif cin &gt;&gt; n &gt;&gt; m; REP(i, 1, n) s[i] = s[i-1] + (a[i] = read&lt;int&gt;()); REP(i, 1, n) dp[i][cur ^ 1] = s[i] * s[i]; REP(L, 2, m) { q[head = tail = 1] = 0; REP(i, 1, n) { while (head &lt; tail &amp;&amp; K(q[head + 1], q[head]) &lt; 2 * s[i]) head++; dp[i][cur] = dp[q[head]][cur ^ 1] + (s[i] - s[q[head]]) * (s[i] - s[q[head]]); while (head &lt; tail &amp;&amp; K(i, q[tail - 1]) &lt; K(q[tail-1], q[tail])) tail--; q[++tail] = i; } cur ^= 1; } cout &lt;&lt; m * dp[n][cur ^ 1] - s[n] * s[n]; return 0;}","link":"/2019/03/30/åˆé›†-æ–œç‡ä¼˜åŒ–/"},{"title":"æ¨¡æ¿ exCRT","text":"ä¼ é€é—¨Orz å°æ˜Š é¢˜ç›®å¤§æ„æ±‚åŒä½™æ–¹ç¨‹ç»„çš„æœ€å°éè´Ÿæ•´æ•°è§£ã€‚$$x\\equiv a_i(mod\\ b_i)$$ è§£æè¿™ä¸ªä¸œè¥¿çš„å…³é”®æ˜¯åˆå¹¶åŒä½™æ–¹ç¨‹ã€‚è€ƒè™‘ä¸¤ä¸ªæ–¹ç¨‹ï¼š$$x\\equiv a_1(mod\\ b_1)$$$$x\\equiv a_2(mod\\ b_2)$$åˆ™å¯ä»¥è®¾ï¼š$$x=k_1b_1+a_1=k_2b_2+a_2$$æ¨å¯¼ä¸€ä¸‹ï¼š$$b_1k_1+b_2\\times(-k_2)=a_2-a_1$$é‚£ä¹ˆè¿™å°±æˆäº†ä¸€ä¸ªexgcdçš„å½¢å¼äº†ï¼Œæ˜¾ç„¶æœ‰è§£çš„å……è¦æ¡ä»¶æ˜¯$a_2-a_1\\mid gcd(b_1,b_2)$ã€‚ç„¶åæˆ‘ä»¬æƒŠå¥‡çš„å‘ç°ï¼Œåˆå¹¶ä¹‹åæ±‚å‡º$k_1$ï¼Œåªè¦$x\\equiv k_1b_1+a_1(mod\\ lcm(b_1, b_2))$ï¼Œå°±å¯ä»¥æ»¡è¶³ä¸Šé¢ä¸¤ä¸ªå¼å­äº†ã€‚ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#define REP(i, s, e) for (int i = s; i &lt;= e; i++)#define DREP(i, s, e) for (int i = s; i &gt;= e; i--)#define DEBUG fprintf(stderr, \"Passing [%s] in Line %d\\n\", __FUNCTION__, __LINE__)#define chkmax(a, b) a = max(a, b)#define chkmin(a, b) a = min(a, b)#include &lt;iostream&gt;#include &lt;cstdio&gt;#define int __int128using namespace std;template &lt;typename T&gt; T read(){ T ans = 0, p = 1; char c = getchar(); while (!isdigit(c)) { if (c == '-') p = -1; c = getchar(); } while (isdigit(c)) { ans = ans * 10 + c - 48; c = getchar(); } return ans * p;}void write(int x){ if (x &lt; 0) {putchar('-');write(-x);return;} if (x / 10) write(x / 10); putchar(x % 10 + '0');}int n, a1, b1, a2, b2, x;int exgcd(int a, int b, int &amp;x, int &amp;y){ if (!b) { x = 1; y = 0; return a; } int ans = exgcd(b, a % b, y, x); y -= a / b * x; return ans;}signed main(){#ifdef CraZYali freopen(\"4777-new-new.in\", \"r\", stdin); freopen(\"4777-new-new.out\", \"w\", stdout);#endif int n = read&lt;int&gt;(), b1 = read&lt;int&gt;(), a1 = read&lt;int&gt;(), lcm; x = a1; while (--n) { b2 = read&lt;int&gt;();a2 = read&lt;int&gt;(); int k, temp, g(exgcd(b1, b2, k, temp)); k *= (a2 - a1) / g; lcm = b1 * b2 / g; x = a1 = (b1 * k + a1) % lcm; b1 = lcm; } write((x + lcm) % lcm); return 0;}","link":"/2019/03/29/æ¨¡æ¿-exCRT/"},{"title":"BZOJ 4503 [ä¸¤ä¸ªä¸²]","text":"ä¼ é€é—¨è¿™çœŸçš„æ˜¯ä¸ªé»‘ç§‘æŠ€äº†ã€‚ä»¥åå¿˜äº†æ€ä¹ˆå†™KMPå°±å†™FFTäº†ã€‚ é¢˜ç›®å¤§æ„ç»™å‡ºä¸¤ä¸ªé•¿åº¦ä¸è¶…è¿‡$10^5$çš„ç”±å°å†™è‹±æ–‡å­—ç¬¦æ„æˆçš„å­—ç¬¦ä¸²$S,T$ï¼Œè¯¢é—®$T$åœ¨$S$ä¸­å‡ºç°äº†å¤šå°‘æ¬¡åŠæ¯æ¬¡å‡ºç°çš„ä½ç½®ï¼ˆä¸‹æ ‡ä»$0$å¼€å§‹ï¼‰ã€‚$T$ä¸­å¯èƒ½å­˜åœ¨?é€šé…ç¬¦ï¼Œå¯ä»¥åŒ¹é…ä»»ä½•è‹±æ–‡å­—ç¬¦ã€‚ è§£æç”±äºå­˜åœ¨é€šé…ç¬¦ï¼Œæ™®é€šçš„KMPä»€ä¹ˆçš„æ˜¯è‚¯å®šä¸è¡Œäº†ã€‚è€ƒè™‘ä»¥ä¸‹å·ç§¯ï¼š$$C_k=\\sum_{i+j=k}(S_i-T_j)^2\\times T_j$$å¦‚æœ$C_k=0$ï¼Œé‚£ä¹ˆåªå¯èƒ½æ˜¯å¯¹äºæ¯ä¸€ä¸ª$j\\in[1,k-1]$ï¼Œåªæœ‰å¯èƒ½æ˜¯$T_j=0$æˆ–è€…$S_{k-j}=T_k$ã€‚æ‰€ä»¥æˆ‘ä»¬æŠŠ$T$ä¸²ç¿»è½¬è¿‡æ¥ï¼Œå¹¶ä¸”å°†?çš„ä½ç½®è®¾ä¸º$0$ï¼Œå†åšä¸€ä¸‹å·ç§¯ã€‚è¿™ä¸ªæ—¶å€™ï¼Œå¦‚æœå­˜åœ¨ä¸€ä¸ª$k\\ge m$å¹¶ä¸”$C_k=0$ï¼Œé‚£ä¹ˆ$k-m$å°±æ˜¯ä¸€ä¸ªåŒ¹é…ä¸Šçš„ä½ç½®äº†ã€‚æ€ä¹ˆåšå·ç§¯å‘¢ï¼Ÿæˆ‘ä»¬æ‹†ä¸€äº›å¼å­ï¼Œå‘ç°æœ€ç»ˆ$C_k$å˜æˆäº†è¿™ä¸ªä¸œè¥¿ï¼š$$C_k=\\sum_{i+j=k}(S_i^2)\\times T_j + \\sum_{i\\in[1,k]}T_j^3 -2\\sum_{i+j=k}S_i\\times(T_j^2)$$å‰ä¸€éƒ¨åˆ†å’Œæœ€åä¸€ä¸ªéƒ¨åˆ†ç›´æ¥æ˜¯å·ç§¯ï¼Œä¸­é—´ä¸€ä¸ªå‰ç¼€å’Œã€‚æ—¶é—´å¤æ‚åº¦$O(n log_2n)$ï¼Œè™½ç„¶æ¯”KMPæ…¢è›®å¤šï¼Œä½†æ˜¯é€‚ç”¨æ€§æ›´å¹¿ï¼Œä¸ªäººè§‰å¾—ä¹ŸæŒºå¥½ç†è§£çš„ã€‚æ³¨æ„FFTç²¾åº¦æ‰çš„ä¸å°‘ï¼Œ$eps$å¼€åˆ°äº†$10^{-2}$ã€‚ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#define DREP(i, s, e) for(int i = s; i &gt;= e ;i--)#define REP(i, s, e) for(int i = s; i &lt;= e ;i++)#define DEBUG fprintf(stderr, \"Passing [%s] in Line %d\\n\", __FUNCTION__, __LINE__)#define chkmax(a, b) a = max(a, b)#define chkmin(a, b) a = min(a, b)#include &lt;iostream&gt;#include &lt;complex&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#define double long doubleusing namespace std;const int maxn = 1e5 + 10, maxN = (1&lt;&lt;18) + 10;const double pi = acos(-1), eps = 1e-2;char s[maxn], t[maxn];int n, m, S[maxn], S2[maxn], T[maxn], T2[maxn], T3[maxn], sum[maxn];struct Complex{ double a, b; Complex(double _a = 0, double _b = 0) : a(_a), b(_b) {} Complex operator + (Complex B) {return Complex(a + B.a, b + B.b);} Complex operator - (Complex B) {return Complex(a - B.a, b - B.b);} Complex operator * (Complex B) {return Complex(a * B.a - b * B.b, a * B.b + b * B.a);} Complex operator *= (Complex B) {return *this = *this * B;}};int L, len, R[maxN];Complex F1[maxN], F2[maxN];void FFT(Complex a[], int flag){ REP(i, 0, len - 1) if (i &lt; R[i]) swap(a[i], a[R[i]]); for (int i = 1; i &lt; len; i &lt;&lt;= 1) { Complex T(cos(pi / i), flag * sin(pi / i)); for (int k = 0; k &lt; len; k += (i &lt;&lt; 1)) { Complex t(1, 0); for (int l = 0; l &lt; i; l++, t *= T) { Complex x(a[k+l]), y(t * a[k+l+i]); a[k + l] = x + y; a[k + l + i] = x - y; } } } if (flag &lt; 0) REP(i, 0, len - 1) a[i].a /= 4*len;}int ans[maxn];signed main(){#ifdef CraZYali freopen(\"4503.in\", \"r\", stdin); freopen(\"4503.out\", \"w\", stdout);#endif scanf(\"%s\\n%s\", s + 1, t + 1); n = strlen(s + 1); m = strlen(t + 1); REP(i, 1, n) { S[i] = s[i] - 'a' + 1; S2[i] = S[i] * S[i]; } REP(i, 1, m) { T[i] = t[m - i + 1] == '?' ? 0 : t[m - i + 1] - 'a' + 1; T2[i] = T[i] * T[i]; T3[i] = T2[i] * T[i]; sum[i] = sum[i-1] + T3[i]; } REP(i, m + 1, n) sum[i] = sum[i-1]; len = 1; while (len &lt;= n + n) len &lt;&lt;= 1; L = log2(len); REP(i, 0, len) R[i] = (R[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; L - 1); REP(i, 1, n) F1[i] = Complex(S2[i] + T[i], S2[i] - T[i]); REP(i, 1, n) F2[i] = Complex(S[i] + T2[i], S[i] - T2[i]); FFT(F1, 1);FFT(F2, 1); REP(i, 0, len-1) F1[i] *= F1[i], F2[i] *= F2[i]; FFT(F1, -1);FFT(F2, -1); REP(k, 1, n) { double c = F1[k+1].a + sum[k] - 2. * F2[k+1].a; if (k-m &gt;= 0 &amp;&amp; fabs(c)&lt;eps) ans[++ans[0]] = k-m; } cout &lt;&lt; ans[0] &lt;&lt; endl; REP(i, 1, ans[0])printf(\"%d\\n\", ans[i]); return 0;}","link":"/2019/03/29/BZOJ-4503/"},{"title":"BZOJ 3527 [ZJOI2014 åŠ›]","text":"ä¼ é€é—¨ç®€ç›´å°±æ˜¯ä¸‡æœ‰å¼•åŠ›å§ã€‚ é¢˜ç›®å¤§æ„ç»™å‡º$n$ä¸ªæ•°$q_i$ï¼Œå®šä¹‰ï¼š $F_i={j&lt;i}\\frac{q_iq_j}{(i-j)^2}-{j&gt;i}\\frac{q_iq_j}{(i-j)^2}$ $$E_i=\\frac{F_i}{q_i}â€‹$$æ±‚$E_iâ€‹$ è§£æå…ˆæ¨ä¸€æ¨å¼å­ã€‚æ˜¾ç„¶ï¼š $$E_i=\\sum_{j&lt;i}\\frac{q_j}{(i-j)^2}-\\sum_{j&gt;i}\\frac{q_j}{(i-j)^2}$$ è®¾$F[i]=q_iâ€‹$ï¼Œ$G[i]=\\frac{1}{i^2}â€‹$ï¼Œ$GG[i]=G[n-i+1]â€‹$ï¼Œåˆ™ï¼š$$E_i=\\sum_{j&lt;i}F[j]G[i-j]-\\sum_{j&gt;i}F[j]G[j-i]=\\sum_{j&lt;i}F[j]G[i-j]-\\sum_{j&gt;i}F[j]GG[n-j+i+1]â€‹$$ã€‚é‚£è¿™åé¢å°±æ˜¯ä¸¤ä¸ªæ ‡å‡†çš„å·ç§¯å‡ä¸€ä¸‹äº†ï¼ŒFFTå³å¯ã€‚ Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#define REP(i, s, e) for(int i = s; i &lt;= e ;i++)#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#define double long doubleusing namespace std;const int maxn = 100000 + 10;const double pi = acos(-1);struct Complex{ double a, b; Complex(double _a = 0, double _b = 0) : a(_a), b(_b) {} Complex operator + (Complex B) {return Complex(a + B.a, b + B.b);} Complex operator += (Complex B) {return *this = *this + B;} Complex operator - (Complex B) {return Complex(a - B.a, b - B.b);} Complex operator -= (Complex B) {return *this = *this - B;} Complex operator * (Complex B) {return Complex(a * B.a - b * B.b, a * B.b + b * B.a);} Complex operator *= (Complex B) {return *this = *this * B;}}F[maxn &lt;&lt; 2], G[maxn &lt;&lt; 2], GG[maxn &lt;&lt; 2];int n;double q[maxn];int len, L, R[maxn &lt;&lt; 2];void FFT(Complex a[], int flag){ REP(i, 1, len - 1) if (i &lt; R[i]) swap(a[i], a[R[i]]); for (int i = 1; i &lt; len; i &lt;&lt;= 1) { Complex T(cos(pi / i), flag * sin(pi / i)); for (int k = 0; k &lt; len; k += (i &lt;&lt; 1)) { Complex t(1); for (int l = 0; l &lt; i; l++, t *= T) { Complex x(a[k + l]), y(t * a[k + l + i]); a[k + l] = x + y; a[k + l + i] = x - y; } } } if (flag &lt; 0) REP(i, 0, len - 1) a[i].a /= len;}int main(){#ifdef CraZYali freopen(\"3527-new.in\", \"r\", stdin); freopen(\"3527-new.out\", \"w\", stdout);#endif cin &gt;&gt; n; REP(i, 1, n) scanf(\"%LF\", q + i); REP(i, 1, n) { F[i].a = q[i]; G[i].a = GG[n - i + 1].a = 1. / i / i; } len = 1; while (len &lt;= n + n) len &lt;&lt;= 1; L = log2(len); REP(i, 1, len) R[i] = (R[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; L - 1); FFT(F, 1);FFT(G, 1);FFT(GG, 1); REP(i, 0, len-1) G[i] *= F[i]; REP(i, 0, len-1) GG[i] *= F[i]; FFT(G, -1);FFT(GG, -1); REP(i, 1, n) printf(\"%.3LF\\n\", G[i].a - GG[n + i + 1].a); return 0;}","link":"/2019/03/28/BZOJ-3527/"},{"title":"BZOJ 4827 [HNOI2017 ç¤¼ç‰©]","text":"ä¼ é€é—¨æˆ‘ä¸€å®šæ˜¯è„‘å­çƒ§åäº†ï¼ŒFFTéƒ½å†™ä¸å¯¹ã€‚ é¢˜ç›®å¤§æ„ç»™ä½ ä¸¤ä¸ªé•¿åº¦ä¸º$n$çš„åºåˆ—$a,b$ï¼Œæ»¡è¶³$a_i,b_i\\in [1,m]$ï¼Œ$a,b$ä¸­çš„æ•°ç»„å¯ä»¥å¾ªç¯ï¼ˆå³å¯ä»¥æŠŠå¼€å¤´æ”¾åˆ°ç»“å°¾ï¼Œç»“å°¾æ”¾åˆ°å¼€å¤´ï¼‰ã€‚ å®šä¹‰$a,b$ä¹‹é—´çš„å·®å¼‚å€¼ä¸º$$\\sum_{i\\in[1,n]} (a_i-b_i)^2$$ã€‚ä½ å¯ä»¥é€‰æ‹©ä¸€ä¸ªå¸¸æ•°$c$ï¼Œä½¿å¾—$a$æˆ–$b$ä¸­çš„æ¯ä¸ªæ•°åŠ ä¸Š$c$ã€‚ æ±‚æœ€å°å·®å¼‚å€¼ã€‚$n\\le 50000,m\\le 100$ è§£ææ˜¾ç„¶å¯ä»¥å…ˆç¡®å®š$c\\in[-m,m]$ã€‚ ç„¶åä¸¤ä¸ªåºåˆ—ä¸€èµ·å¾ªç¯æ˜¯æ²¡æœ‰æ„ä¹‰çš„ï¼Œåªè¦å¾ªç¯ä¸€ä¸ªå°±å¯ä»¥äº†ã€‚ è®¡å·®å¼‚å€¼ä¸º$D$ï¼Œæˆ‘ä»¬æŠŠå¼å­æ‹†ä¸€ä¸‹ã€‚ ä»¤ï¼š åˆ™ï¼š æ‰€ä»¥ï¼Œå¦‚æœæˆ‘ä»¬è¦è®©$D$å°½é‡å°çš„è¯ï¼Œå°±è¦å°½é‡è®©$k=\\sum_{i\\in[1,n]}a_ib_i$å¤§ã€‚ ç­‰ä¸€ä¸‹ã€‚ æŠŠ$b$åè½¬ä¸€ä¸‹ï¼Œ$k$å°±å˜æˆ$\\sum_{i\\in[1,n]}a_ib_{n-i+1}$ï¼Œè¿™ä¸å°±æ˜¯ä¸€ä¸ªå·ç§¯å½¢å¼å—ï¼Ÿ é‚£æŠŠ$a$å€é•¿ï¼ˆæŠŠé“¾å˜æˆç¯ï¼‰ï¼Œå†å’Œ$b$åšä¸€ä¸‹$FFT$ï¼Œå†æšä¸¾ä¸€ä¸‹æœ€å¤§å€¼å°±å¯ä»¥äº†ã€‚ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#define REP(i, s, e) for (int i = s; i &lt;= e; i++)#define DREP(i, s, e) for (int i = s; i &gt;= e; i--)#define DEBUG fprintf(stderr, \"Passing [%s] in Line %d\\n\", __FUNCTION__, __LINE__)#define chkmax(a, b) a = max(a, b)#define chkmin(a, b) a = min(a, b)#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#define double long double#define int long longusing namespace std;const int maxn = 50000 + 10 &lt;&lt; 1, inf = 1ll &lt;&lt; 60;const double pi = acos(-1);template &lt;typename T&gt; T read(){ T ans = 0, p = 1; char c = getchar(); while (!isdigit(c)) { if (c == '-') p = -1; c = getchar(); } while (isdigit(c)) { ans = ans * 10 + c - 48; c = getchar(); } return ans * p;}struct Complex{ double x, y; Complex(double _x = 0, double _y = 0) : x(_x), y(_y){} Complex operator + (Complex B) {return Complex(x + B.x, y + B.y);} Complex operator += (Complex B) {return *this = *this + B;} Complex operator - (Complex B) {return Complex(x - B.x, y - B.y);} Complex operator -= (Complex B) {return *this = *this - B;} Complex operator * (Complex B) {return Complex(x * B.x - y * B.y, x * B.y + y * B.x);} Complex operator *= (Complex B) {return *this = *this * B;}}F[3 * maxn], G[3 * maxn];int n, m, a[maxn], b[maxn];int R[maxn * 3], len, L;int static_sum, all_sum, ans = inf;void FFT(Complex *a, int flag){ REP(i, 0, len - 1) if (i &lt; R[i]) swap(a[i], a[R[i]]); for (int i = 1; i &lt; len; i &lt;&lt;= 1) { Complex T(cos(pi / i), flag * sin(pi / i)); for (int k = 0; k &lt; len; k += (i &lt;&lt; 1)) { Complex t(1, 0); for (int l = 0; l &lt; i; l++, t *= T) { Complex x = a[k + l], y = t * a[k + l + i]; a[k + l] = x + y; a[k + l + i] = x - y; } } } if (flag &lt; 0) REP(i, 0, len - 1) a[i].x = (int)(a[i].x / len + 0.5);}signed main(){#ifdef CraZYali freopen(\"4827.in\", \"r\", stdin); freopen(\"4827.out\", \"w\", stdout);#endif cin &gt;&gt; n &gt;&gt; m; REP(i, 1, n) a[i] = read&lt;int&gt;(); REP(i, 1, n) b[i] = read&lt;int&gt;(); REP(i, 1, n) static_sum += a[i] * a[i] + b[i] * b[i], all_sum += a[i] - b[i]; len = 1; while (len &lt;= n + n + n) len &lt;&lt;= 1; L = log2(len); REP(i, 0, len) R[i] = (R[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; L - 1); int l(1), r(n); while (l &lt; r) swap(b[l++], b[r--]); REP(i, 1, n) F[i].x = F[i + n].x = a[i]; REP(i, 1, n) G[i].x = b[i]; FFT(F, 1); FFT(G, 1); REP(i, 0, len) F[i] *= G[i]; FFT(F, -1); REP(i, 1, n) REP(c, -m, m) chkmin(ans, static_sum + n * c * c + 2 * c * all_sum - 2 * (int)F[i+n].x); cout &lt;&lt; ans &lt;&lt; endl; return 0;}","link":"/2019/03/26/BZOJ-4827/"},{"title":"Luogu 3157 [CQOI2011 åŠ¨æ€é€†åºå¯¹]","text":"ä¼ é€é—¨åƒåœ¾BZOJï¼Œç¡¬æ˜¯è¿‡ä¸äº†æˆ‘çš„å¤§å¸¸æ•°ã€‚ é¢˜ç›®å¤§æ„ç»™å‡ºä¸€ä¸ª$1$åˆ°$n$çš„æ’åˆ—$P$ï¼Œä¾æ¬¡åˆ é™¤$m$ä¸ªæ•°ï¼Œé—®æ¯æ¬¡åˆ é™¤å‰æ•´ä¸ªåºåˆ—çš„é€†åºå¯¹æ•°ã€‚ è§£ææ™®é€šä¸å¸¦åˆ é™¤çš„è°éƒ½ä¼šå†™å§ï¼Œä¸€æ£µæ ‘çŠ¶æ•°ç»„å®Œäº‹ã€‚å¾…åˆ é™¤çš„ï¼Ÿæˆ‘ä»¬åˆå‘ç°ï¼Œåªè¦ç»´æŠ¤åŒºé—´å†…æ•°å­—å‡ºç°çš„æ¬¡æ•°å°±å¯ä»¥äº†ã€‚ç›´æ¥ä¸Šä¸€æ£µæ ‘çŠ¶æ•°ç»„å¥—æƒå€¼çº¿æ®µæ ‘ï¼Œå®Œäº‹ã€‚å•æ¬¡æ“ä½œ$O(log_2^2n)$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#define REP(i, s, e) for (int i = s; i &lt;= e; i++)#define DREP(i, s, e) for (int i = s; i &gt;= e; i--)#define DEBUG fprintf(stderr, \"Passing [%s] in Line %d\\n\", __FUNCTION__, __LINE__)#define chkmax(a, b) a = max(a, b)#define chkmin(a, b) a = min(a, b)#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;const int maxn = 100000 + 10;template &lt;typename T&gt; T read(){ T ans = 0, p = 1; char c = getchar(); while (!isdigit(c)) { if (c == '-') p = -1; c = getchar(); } while (isdigit(c)) { ans = ans * 10 + c - 48; c = getchar(); } return ans * p;}struct node *null;const int maxnode = 28000000;int rt[maxnode], ls[maxnode], rs[maxnode], sum[maxnode], cur, LL[30], RR[30];#define mid (l + r &gt;&gt; 1)#define lson ls[p], l, mid#define rson rs[p], mid + 1, rvoid update(int &amp;p, int l, int r, int pos, int num){ if (!p) p = ++cur; sum[p] += num; if (l == r) return; else if (pos &lt;= mid) update(lson, pos, num); else update(rson, pos, num);}int n, m, a[maxn], pos[maxn];long long ans;int query(int l, int r, int val, bool mode){ int lsz(0), rsz(0), s(0); for (int i = l-1; i &gt; 0; i -= i &amp; -i) LL[++lsz] = rt[i]; for (int i = r ; i &gt; 0; i -= i &amp; -i) RR[++rsz] = rt[i]; l = 1, r = n; while (l &lt; r) if (val &gt; mid) { if (mode) { REP(i, 1, lsz) s -= sum[ls[LL[i]]]; REP(i, 1, rsz) s += sum[ls[RR[i]]]; } REP(i, 1, lsz) LL[i] = rs[LL[i]]; REP(i, 1, rsz) RR[i] = rs[RR[i]]; l = mid + 1; } else { if (!mode) { REP(i, 1, lsz) s -= sum[rs[LL[i]]]; REP(i, 1, rsz) s += sum[rs[RR[i]]]; } REP(i, 1, lsz) LL[i] = ls[LL[i]]; REP(i, 1, rsz) RR[i] = ls[RR[i]]; r = mid ; } return s;}int main(){#ifdef CraZYali freopen(\"3157.in\", \"r\", stdin); freopen(\"3157.out\", \"w\", stdout);#endif cin &gt;&gt; n &gt;&gt; m; REP(i, 1, n) { pos[a[i] = read&lt;int&gt;()] = i; ans += 1ll * query(1, i-1, a[i], 0); for (int j = i; j &lt;= n; j += j &amp; -j) update(rt[j], 1, n, a[i], 1); } while (m --&gt; 0) { printf(\"%lld\\n\", ans); int x = read&lt;int&gt;(), p = pos[x]; ans -= query(1, p - 1, x, 0); ans -= query(p + 1, n, x, 1); for (int i = p; i &lt;= n; i += i &amp; -i) update(rt[i], 1, n, x, -1); } return 0;} P.Så†…å­˜é™åˆ¶128MBæ˜¯çœŸçš„å‘ã€‚ä¹‹å‰ç”¨æŒ‡é’ˆï¼Œç›´æ¥newç»“ç‚¹ç»“æœMLEã€‚åæ¥é¢„å…ˆåˆ†é…å†…å­˜æ± ï¼ŒMLEã€‚å†åæ¥æŠŠå†…å­˜æ± æ”¹å°ï¼ŒREã€‚æˆ‘å¯å»æ‚¨çš„å§ï¼Œä¸€æ°”ä¹‹ä¸‹å§æŒ‡é’ˆæ”¹æˆæ™®é€šæ•°ç»„ï¼Œè¿‡äº†ï¼Ÿåƒåœ¾é¢˜ç›®ï¼Œæ¯æˆ‘é’æ˜¥ã€‚","link":"/2019/03/23/Luogu-3157/"},{"title":"BZOJ 1901ï¼ˆåŠ¨æ€åŒºé—´ç¬¬Kå°ï¼‰","text":"ä¼ é€é—¨æ ‘å¥—æ ‘ä»€ä¹ˆçš„çœŸçš„å¤´æ™•æ­»äº†ã€‚ é¢˜ç›®å¤§æ„ç»™ä½ ä¸€ä¸ªåºåˆ—$a_{i\\in [1,n]}$ï¼Œè¦æ±‚å•ç‚¹ä¿®æ”¹ï¼ŒåŒºé—´è¯¢é—®ç¬¬$k$å°å€¼ã€‚ è§£æå¦‚ä¸æ²¡æœ‰ä¿®æ”¹ï¼Œç›´æ¥ä¸€æ£µä¸»å¸­æ ‘å°±å¯ä»¥äº†ã€‚æœ‰ä¿®æ”¹ä¹Ÿæ²¡å…³ç³»ï¼Œæ•´ä½“äºŒåˆ†å°±å¯ä»¥äº†ã€‚æœ‰ä¿®æ”¹çš„è¯ï¼Œä¸»å¸­æ ‘è‚¯å®šæ²¡åŠæ³•äº†ï¼Œå› ä¸ºå®ƒå­˜çš„æ˜¯å‰ç¼€ï¼Œä¿®æ”¹çš„è¯æ—¶é—´ç›´æ¥GGã€‚ä½†æ˜¯æˆ‘ä»¬ä»ç„¶å¯ä»¥è¿ç”¨ä¸»å¸­æ ‘çš„æ€æƒ³ã€‚æˆ‘ä»¬è¦åšçš„ï¼Œå…¶å®å°±æ˜¯ç»´æŠ¤ä¸€ä¸ªåŒºé—´å†…çš„$cnt=[a_{i\\in [l,r]} \\le val]$ï¼Œå°±å¯ä»¥æŸ¥è¯¢æ’åã€æ‰¾åˆ°$k$å¤§å€¼äº†ã€‚é‚£å¦‚æœæˆ‘ä»¬è¿˜æ˜¯å»ºå‡ºæ¥$n$æ£µæƒå€¼çº¿æ®µæ ‘ï¼Œæ¯æ¬¡å¯¹æ“ä½œæš´åŠ›$O(n\\ log_2n)$çš„æ›´æ–°ï¼Œå°±å¯ä»¥ç»´æŠ¤ï¼Œä½†æ˜¯æ˜¾ç„¶æ—¶é—´GGã€‚ä½†æ˜¯æˆ‘ä»¬æ³¨æ„åˆ°ä¸€ä¸ªäº‹æƒ…ï¼Œæˆ‘ä»¬è¦åšçš„ä¸œè¥¿ç±»ä¼¼ä¸‹é¢çš„æ“ä½œï¼š 12345678910void update(int l, int r){ for (int i = l ; i &lt;= r; i++) tree_add(i);}int query(int l, int r){ int res = 0; for (int i = l ; i &lt;= r; i++) res += get_sum(i); return res;} è¿™ä¸ªä¸œè¥¿å¯ä»¥ç”¨ä»€ä¹ˆæ“ä½œï¼Ÿæ ‘çŠ¶æ•°ç»„ï¼å¦‚æœæˆ‘ä»¬é‡‡ç”¨ç±»ä¼¼ä¸»å¸­æ ‘çš„æ–¹æ³•ï¼Œåªæ˜¯åœ¨æƒå€¼çº¿æ®µæ ‘å¤–é¢å¥—ä¸€å±‚æ ‘çŠ¶æ•°ç»„ï¼Œé‚£æˆ‘ä»¬å•æ¬¡æ“ä½œçš„å¤æ‚åº¦å°±æˆåŠŸæˆ$O(n\\ log_2n)$é™ä½åˆ°äº†å¯ä»¥æ¥å—çš„$O(log_2^2n)$äº†ã€‚ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#define DREP(i, s, e) for(int i = s; i &gt;= e ;i--)#define REP(i, s, e) for(int i = s; i &lt;= e ;i++)#define DEBUG fprintf(stderr, \"Passing [%s] in Line %d\\n\", __FUNCTION__, __LINE__)#define chkmax(a, b) a = max(a, b)#define chkmin(a, b) a = min(a, b)#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e4 + 10, maxq = 1e4 + 10;template &lt;typename T&gt; inline T read(){ T ans(0), p(1); char c = getchar(); while (!isdigit(c)) { if (c == '-') p = -1; c = getchar(); } while (isdigit(c)) { ans = ans * 10 + c - 48; c = getchar(); } return ans * p;}int n, m, q, a[maxn], b[maxn + maxq];int to(int val) {return lower_bound(b + 1, b + 1 + m, val) - b;}bool type[maxq];int x[maxq], y[maxq], z[maxq];struct node *null;struct node{ node *ls, *rs; int sum; node() : ls(null), rs(null), sum(0) {}}*c[maxn];#define mid (l + r &gt;&gt; 1)void update(node *pre, node *&amp;p, int l, int r, int pos, int num){ node temp = *pre; p = new node(); p -&gt; ls = temp.ls; p -&gt; rs = temp.rs; p -&gt; sum = temp.sum + num; if (l == r) return; else if (pos &lt;= mid) update(temp.ls, p -&gt; ls, l, mid, pos, num); else update(temp.rs, p -&gt; rs, mid + 1, r, pos, num);}void add(int x, int pos, int num = 1){ while (x &lt;= n) { if (c[x] == NULL) c[x] = new node(); update(c[x], c[x], 1, m, pos, num); x += x &amp; -x; }}void update(int l, int r, int pos, int num = 1) {add(l, pos, num);add(r + 1, pos, num * -1);}int lsz, rsz;node *LLL[maxn], *RRR[maxn];int query(int l, int r, int k){ if (l == r) return l; int x = 0; REP(i, 1, rsz) x += RRR[i] -&gt; ls -&gt; sum; REP(i, 1, lsz) x -= LLL[i] -&gt; ls -&gt; sum; if (x &gt;= k) { REP(i, 1, lsz) LLL[i] = LLL[i] -&gt; ls; REP(i, 1, rsz) RRR[i] = RRR[i] -&gt; ls; return query(l, mid, k); } else { REP(i, 1, lsz) LLL[i] = LLL[i] -&gt; rs; REP(i, 1, rsz) RRR[i] = RRR[i] -&gt; rs; return query(mid + 1, r, k - x); }}int main(){#ifdef CraZYali freopen(\"1901-new.in\", \"r\", stdin); freopen(\"1901-new.out\", \"w\", stdout);#endif null = new node(); null -&gt; ls = null -&gt; rs = null;null -&gt; sum = 0; cin &gt;&gt; n &gt;&gt; q; REP(i, 1, n) a[i] = b[++m] = read&lt;int&gt;(); REP(i, 1, q) { char cc = getchar(); while (cc != 'Q' &amp;&amp; cc != 'C') cc = getchar(); x[i] = read&lt;int&gt;();y[i] = read&lt;int&gt;(); if (cc == 'Q') type[i] = 1, z[i] = read&lt;int&gt;(); else b[++m] = y[i]; } sort(b + 1, b + 1 + m); m = unique(b + 1, b + 1 + m) - b - 1; REP(i, 1, n) add(i, to(a[i])); REP(i, 1, q) if (type[i]) { lsz = rsz = 0; for (int now = x[i]-1; now &gt; 0;now -= (now &amp; -now)) LLL[++lsz] = c[now]; for (int now = y[i]; now &gt; 0;now -= (now &amp; -now)) RRR[++rsz] = c[now]; //æå‰æå–éœ€è¦æŸ¥è¯¢çš„æ ‘çŠ¶æ•°ç»„çš„ç»“ç‚¹ printf(\"%d\\n\", b[query(1, m, z[i])]); } else { add(x[i], to(a[x[i]]), -1); add(x[i], to(a[x[i]] = y[i])); } return 0;} P.Såšé¢˜éƒ½åšå¾—æ„Ÿè§‰è„‘å­æœ‰é—®é¢˜äº†ã€‚å¯¹äºè¿™ç§ä¼šè®©äººè„‘å­æœ‰é—®é¢˜çš„ä¸œè¥¿ï¼Œæœ‰çš„æ—¶å€™ä¸è¦æƒ³å¤ªå¤šï¼Œç›´æ¥æŠŠä¸€äº›ä¸œè¥¿å½“æˆå·¥å…·å°±å¥½ï¼Œä¸ç„¶çœŸçš„å¤´ç–¼ã€‚","link":"/2019/03/22/BZOJ-1901ï¼ˆåŠ¨æ€åŒºé—´ç¬¬Kå°ï¼‰/"},{"title":"æ¨¡æ¿ é™æ€åŒºé—´ç¬¬Kå°ï¼ˆä¸»å¸­æ ‘ï¼‰","text":"ä¼ é€é—¨å•Šï¼Œæ¨äº†ä¸€æ™šä¸Šï¼Œå¤§æ¦‚æå®šäº†å§ã€‚ é¢˜ç›®å¤§æ„ç»™å®šä¸€ä¸ªåºåˆ—$a_{k\\in [1,n]}$ï¼Œ$q$æ¬¡è¯¢é—®ï¼Œæ¯æ¬¡è¯¢é—®$[l,r]$ä¸­ç¬¬$K$å°çš„æ•°ã€‚ è§£æä¸»å¸­æ ‘å®šä¹‰æœ‰äººè¯´è¿™å°±æ˜¯å¯æŒä¹…åŒ–çº¿æ®µæ ‘ï¼Œæ²¡æ€ä¹ˆæ‡‚è¿™ç§è¯´æ³•ã€‚ä¸»å¸­æ ‘å…¶å®å°±æ˜¯ä¸€å †æƒå€¼çº¿æ®µæ ‘ï¼Œç¬¬$i$æ£µè¡¨ç¤ºçš„æ˜¯åºåˆ—$a_{k\\in [1,i]}$çš„æƒå€¼çº¿æ®µæ ‘ã€‚é‚£è¿™æ ·ä¸ä¼šè¶…ç©ºé—´å—ï¼Ÿå…¶å®ä¸ä¼šï¼Œå› ä¸ºç¬¬$i$æ£µå’Œç¬¬$i+1$æ£µæƒå€¼çº¿æ®µæ ‘ä¹‹é—´å¯èƒ½æœ‰å¾ˆå¤šå…¬å…±ç»“ç‚¹ã€‚æ¯”å¦‚è¯´${3,1,2,4,5}$è¿™ä¸ªä¸»å¸­æ ‘ï¼Œå»ºå‡ºæ¥æ˜¯è¿™æ ·çš„ã€‚ å‘ç°ä»ç¬¬$i-1$æ£µåŠ åˆ°ç¬¬$i$æ£µæ—¶ï¼Œåªè¦ç®¡æ–°åŠ å…¥çš„æ•°$val$æ˜¯åº”è¯¥åˆ’åˆ†åˆ°$[l,mid]$è¿˜æ˜¯$[mid+1,r]$è¿™ä¸ªåŒºé—´å°±å¥½äº†ã€‚å¦‚æœ$val\\in [l,mid]$ï¼Œé‚£ä¹ˆå½“å‰ç»“ç‚¹çš„å³å„¿å­å°±å’Œå‰ä¸€æ£µçš„å³å„¿å­å®Œå…¨ç›¸åŒï¼Œè¿™æ—¶å€™é€’å½’å¤„ç†å®ƒä»¬çš„å·¦å„¿å­å°±è¡Œäº†ã€‚åä¹‹ï¼Œå¦‚æœ$val\\in [mid+1,r]$ï¼Œé‚£ä¹ˆå·¦å„¿å­å®Œå…¨ç›¸åŒï¼Œé€’å½’å³å„¿å­å°±å¯ä»¥äº†ã€‚è¿™æ ·å°±å¯ä»¥å…±ç”¨ç»“ç‚¹äº†ï¼Œé‚£ä¹ˆåŠ¨æ€å¼€ç‚¹å°±å¯ä»¥äº†ã€‚ æ€§è´¨ç”±äºä¿å­˜çš„æ˜¯åŒºé—´çš„æƒå€¼çº¿æ®µæ ‘ï¼Œä¸»å¸­æ ‘ä¸Šçš„æ•°å€¼å…·æœ‰åŒºé—´å¯åŠ æ€§ï¼è¿™æ˜¯ä¸€ä¸ªéå¸¸å¥½çš„æ€§è´¨ï¼Œç”¨ä¸¤æ£µæƒå€¼çº¿æ®µæ ‘çš„$query$å€¼ç›¸å‡å°±å¯ä»¥æ–¹ä¾¿æˆ‘ä»¬åœ¨$O(log_2n)$çš„æ—¶é—´å†…æŸ¥è¯¢ä¸€ä¸ª$cnt=\\sum_{i\\in [l,r]} [a_i \\le val]$ï¼Œæ–¹ä¾¿æŸ¥è¯¢ä¸€ä¸ªæ•°åœ¨åŒºé—´å†…çš„æ’åï¼ˆå¯èƒ½è¿˜è¦ç¨å¾®ä¿®æ”¹ä¸€ä¸‹ï¼Œé—®é¢˜ä¸å¤§ï¼‰ã€‚è¿™å°±å·®ä¸å¤šäº†ã€‚æ—¶é—´å¤æ‚åº¦åº”è¯¥æ˜¯$O(n\\ log_2n)$çš„ï¼Œç©ºé—´å¤æ‚åº¦åŠ¨æ€å¼€ç‚¹ã€‚ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#define DREP(i, s, e) for(int i = s; i &gt;= e ;i--)#define REP(i, s, e) for(int i = s; i &lt;= e ;i++)#define DEBUG fprintf(stderr, \"Passing [%s] in Line %d\\n\", __FUNCTION__, __LINE__)#define chkmax(a, b) a = max(a, b)#define chkmin(a, b) a = min(a, b)#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2e5 + 10;template &lt;typename T&gt; inline T read(){ T ans(0), p(1); char c = getchar(); while (!isdigit(c)) { if (c == '-') p = -1; c = getchar(); } while (isdigit(c)) { ans = ans * 10 + c - 48; c = getchar(); } return ans * p;}int a[maxn], b[maxn], n, m, q;#define mid (l + r &gt;&gt; 1)#define lson p -&gt; ls, l, mid#define rson p -&gt; rs, mid + 1, rstruct node *null;struct node{ node *ls, *rs;int sum; node() : ls(null), rs(null), sum(0){}}*rt[maxn];void build(node *pre, node *&amp;p, int l, int r, int val){ p = new node(); p -&gt; ls = pre -&gt; ls; p -&gt; rs = pre -&gt; rs; p -&gt; sum = pre -&gt; sum + 1; if (l &gt;= r) return; else if (val &lt;= mid) build(pre -&gt; ls, lson, val); else build(pre -&gt; rs, rson, val);}int query(node *u, node *v, int l, int r, int k){ if (l &gt;= r) return l; int x = v -&gt; ls -&gt; sum - u -&gt; ls -&gt; sum; if (x &lt; k) return query(u -&gt; rs, v -&gt; rs, mid + 1, r, k - x); else return query(u -&gt; ls, v -&gt; ls, l, mid, k);}int main(){#ifdef CraZYali freopen(\"3834-new-new.in\", \"r\", stdin); freopen(\"3834-new-new.out\", \"w\", stdout);#endif cin &gt;&gt; n &gt;&gt; q; REP(i, 1, n) b[i] = a[i] = read&lt;int&gt;(); sort(b + 1, b + 1 + n); m = unique(b + 1, b + 1 + n) - b - 1; rt[0] = null = new node(); null -&gt; ls = null;null -&gt; rs = null;null -&gt; sum = 0; REP(i, 1, n) { rt[i] = null; build(rt[i-1], rt[i], 1, m, lower_bound(b + 1, b + 1 + m, a[i]) - b); } while (q --&gt; 0) { int L = read&lt;int&gt;(), R = read&lt;int&gt;(), k = read&lt;int&gt;(); printf(\"%d\\n\", b[query(rt[L-1], rt[R], 1, m, k)]); } return 0;}","link":"/2019/03/21/æ¨¡æ¿-é™æ€åŒºé—´ç¬¬Kå°ï¼ˆä¸»å¸­æ ‘ï¼‰/"},{"title":"BZOJ 3110 [ZJOI2013 Kå¤§æ•°æŸ¥è¯¢]","text":"ä¼ é€é—¨å“å‘€è¿™é¢˜åˆšäº†ä¸€ä¸Šåˆæ²¡åˆšå‡ºæ¥ï¼Œä¸‹åˆå‘ç°å°‘å†™$5$ä¸ªå­—ç¬¦ï¼Œæµ‘èº«éš¾å—ã€‚ é¢˜ç›®å¤§æ„æœ‰$N$ä¸ªä½ç½®ï¼Œ$M$ä¸ªæ“ä½œã€‚æ“ä½œæœ‰$2$ç§ï¼š $1\\ a\\ b\\ c$ åœ¨ç¬¬$a$ä¸ªä½ç½®åˆ°ç¬¬$b$ä¸ªä½ç½®ï¼Œæ¯ä¸ªä½ç½®åŠ å…¥ä¸€ä¸ªæ•°$c$ã€‚ $2\\ a\\ b\\ c$ è¯¢é—®ä»ç¬¬$a$ä¸ªä½ç½®åˆ°ç¬¬$b$ä¸ªä½ç½®ï¼Œç¬¬$c$å¤§çš„æ•°æ˜¯å¤šå°‘ã€‚ è§£ææ•´ä½“äºŒåˆ†ï¼Ÿæ—©å°±å¼ƒå‘äº†ã€‚æˆ‘è®°å¾—æˆ‘ä¹‹å‰çš„è®¡åˆ’ä¸­æœ‰ä¸€ä¸ªçº¿æ®µæ ‘å¥—çº¿æ®µæ ‘æ¥ç€ï¼Œè¿™ä¸ªé¢˜å°±æ˜¯ä¸€ä¸ªæ ‘å¥—æ ‘ã€‚å¤–å±‚æä¸€ä¸ªæƒå€¼çº¿æ®µæ ‘ï¼Œå†…å±‚å¥—ä¸€ä¸ªåŒºé—´ã€‚ æƒå€¼çº¿æ®µæ ‘å®šä¹‰ å¦‚å›¾ï¼Œè¿™å°±æ˜¯ä¸€ä¸ªæƒå€¼çº¿æ®µæ ‘ï¼Œå®ƒå¯¹åº”çš„åºåˆ—ä¸º${1,3,3,5,4,2}$ã€‚æ¯ä¸ªç»“ç‚¹ä¿å­˜çš„ä¿¡æ¯æœ‰ä¸‰ä¸ª$[l,r],cnt$ï¼Œæ„å‘³ç€åœ¨åŸåºåˆ—ä¸­ï¼Œ$cnt=\\sum_{i=1}^n [a_i \\in [l,r]]$ã€‚æ³¨æ„åˆ°ä¸¤ç‚¹ï¼š æƒå€¼çº¿æ®µæ ‘åªä¿å­˜æ•°å­—çš„å‡ºç°æ¬¡æ•°ï¼Œä¸è€ƒè™‘åºåˆ—çš„é¡ºåºã€‚ ä¸€èˆ¬æ¥è®²ï¼Œæƒå€¼çº¿æ®µæ ‘ä¿å­˜çš„åºåˆ—å€¼éœ€è¦ç¦»æ•£åŒ–ï¼ˆç©ºé—´é—®é¢˜ï¼‰ æ‰€ä»¥è¯´ï¼Œä¸Šé¢é‚£é¢—çº¿æ®µæ ‘ä¸å¼€åˆ°$[1,6]$ä¹Ÿæ²¡æœ‰å…³ç³»ï¼Œç›´æ¥ç¦»æ•£åŒ–ï¼ˆè¿™ä¸ªåºåˆ—æ²¡å¿…è¦ï¼‰åå¼€æˆ$[1,5]$ä¹Ÿå¯ä»¥ã€‚åŒæ ·ï¼Œå¦‚æœåºåˆ—æ˜¯${1,2,5,4,3,3}$ï¼Œæƒå€¼çº¿æ®µæ ‘å¼€æˆ$[1,6]$ï¼Œä¹Ÿä¼šé•¿æˆä¸Šå›¾çš„æ ·å­ã€‚ æ‰¾æ’åä¸º$K$çš„æ•°ç›´æ¥ä»æ ¹èŠ‚ç‚¹å¼€å§‹æ‰¾ï¼Œé‡å¤ä»¥ä¸‹è¿‡ç¨‹ã€‚ $K \\le now -&gt; LeftSon -&gt; cnt$$ï¼Œè¯´æ˜è¿™ä¸ªæ•°ä¸€å®šä¸è¶…è¿‡å½“å‰åŒºé—´æœ€å¤§å€¼ï¼Œé‚£ä¹ˆ$$now = now -&gt; LeftSon$$ã€‚ $K &gt; now -&gt; LeftSon -&gt; cnt$ï¼Œè¯´æ˜è¿™ä¸ªæ•°ä¸€å®šè¶…è¿‡å½“å‰åŒºé—´æœ€å¤§å€¼ï¼Œé‚£ä¹ˆ$K = K - now -&gt; LeftSon -&gt; cnt$ï¼ŒåŒæ—¶$now = now -&gt; RightSon$ã€‚ æ‰¾åˆ°ä¸€ä¸ªç¡®å®šçš„æ•°ä¸ºæ­¢ã€‚ åƒ$FHQ\\ TREAP$å•Šï¼Œè¿˜æœ‰ä¸€äº›æ•°æ®ç»“æ„éƒ½æ˜¯è¿™æ ·æ‰¾çš„ã€‚ æƒå€¼çº¿æ®µæ ‘å¥—åŒºé—´å·®ä¸å¤šçš„ä¸œè¥¿ï¼Œåªæ˜¯æƒå€¼çº¿æ®µæ ‘é‡Œçš„ä¸œè¥¿ä»æ•°å˜æˆäº†åŒºé—´è€Œå·²ã€‚å†…å±‚å¥—çš„åŒºé—´ï¼Œä¹Ÿå°±æ˜¯æ¯æ¬¡åŠ è¿›æ¥çš„å€¼åœ¨é‚£äº›åœ°æ–¹ã€‚ æ ‡è®°æ°¸ä¹…åŒ–ä¸€ä¸ªå°å°çš„æŠ€å·§ã€‚å› ä¸ºç»“ç‚¹éƒ½è¢«æ‹†å¼€äº†ï¼Œæ‰€ä»¥ä¸‹ä¼ æ ‡è®°ä¸å¤ªå¥½åŠã€‚æ€ä¹ˆæå‘¢ï¼Ÿä¸ä¸‹ä¼ ä¸å°±å¯ä»¥äº†å—ï¼Œæ›´æ–°çš„æ—¶å€™ä¸€èµ·æ›´æ–°ï¼ŒæŸ¥è¯¢çš„æ—¶å€™ä¸ä»…è¿”å›$sum$$ï¼Œè€Œä¸”è¿”å›$$tag$$åœ¨åŒºé—´çš„ä½œç”¨å°±å¯ä»¥äº†ã€‚æ²¡æ‡‚å°±çœ‹ä»£ç å§ã€‚ æ­£é¢˜å¯¹äºæ¯ä¸ªè¯¢é—®ï¼Œå…ˆæŸ¥æ‰¾å³è¾¹çš„æ€»æ•°$cnt$ï¼Œå¦‚æœå³è¾¹æ€»æ•°å¤§äºç­‰äº$c$å°±åœ¨å³å­æ ‘æŸ¥è¯¢ç¬¬$c$å¤§çš„ï¼Œå¦‚æœä¸å¤Ÿå°±åœ¨å·¦å­æ ‘æŸ¥è¯¢ç¬¬$c-cnt$å¤§çš„ã€‚åº”è¯¥æŒºå¥½æ‡‚çš„ã€‚æœ€åï¼Œçº¿æ®µæ ‘åŠ¨æ€å¼€ç‚¹ã€‚ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#define REP(i, s, e) for (int i = s; i &lt;= e; i++)#define DREP(i, s, e) for (int i = s; i &gt;= e; i--)#define DEBUG fprintf(stderr, \"Passing [%s] in Line %d\\n\", __FUNCTION__, __LINE__)#define chkmax(a, b) a = max(a, b)#define chkmin(a, b) a = min(a, b)#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;template &lt;typename T&gt; T read(){ T ans = 0, p = 1; char c = getchar(); while (!isdigit(c)) { if (c == '-') p = -1; c = getchar(); } while (isdigit(c)) { ans = ans * 10 + c - 48; c = getchar(); } return ans * p;}#define mid (l + r &gt;&gt; 1)#define lson p -&gt; ls, l, mid#define rson p -&gt; rs, mid + 1, rint n, m;struct node_inside{ node_inside *ls, *rs; int sum, tag; node_inside() : sum(0), tag(0), ls(NULL), rs(NULL) {}};int query(node_inside *x, bool flag = 1) {return x != NULL ? x -&gt; sum * flag + x -&gt; tag * (flag ^ 1) : 0;}void update(node_inside *&amp;p, int l, int r, int L, int R){ if (p == NULL) p = new node_inside(); if (L == l &amp;&amp; r == R) p -&gt; tag++; else if (L &gt; mid) update(rson, L, R); else if (R &lt;= mid) update(lson, L, R); else { update(lson, L, mid); update(rson, mid + 1, R); } p -&gt; sum += R - L + 1;}int query(node_inside *&amp;p, int l, int r, int L, int R){ if (p == NULL) return 0; if (L == l &amp;&amp; r == R) return query(p); int res = (R - L + 1) * query(p, 0); if (R &lt;= mid) return query(lson, L, R) + res; else if (L &gt; mid) return query(rson, L, R) + res; else return query(lson, L, mid) + query(rson, mid + 1, R) + res;}struct node_outside{ node_inside *rt; node_outside *ls, *rs; node_outside() : ls(NULL), rs(NULL), rt(NULL){}};node_outside *T;void update(node_outside *&amp;p, int l, int r, int L, int R, int pos){ if (p == NULL) p = new node_outside(); update(p -&gt; rt, 1, n, L, R); if (l == r) return; if (pos &lt;= mid) update(lson, L, R, pos); else update(rson, L, R, pos);}int query(node_outside *&amp;p, int l, int r, int L, int R, int pos){ if (l == r) return l; int cnt = p -&gt; rs == NULL ? 0 : query(p -&gt; rs -&gt; rt, 1, n, L, R); if (cnt &gt;= pos) return query(rson, L, R, pos); else return query(lson, L, R, pos - cnt);}int main(){#ifdef CraZYali freopen(\"3110.in\", \"r\", stdin); freopen(\"3110.out\", \"w\", stdout);#endif cin &gt;&gt; n &gt;&gt; m; while (m --&gt; 0) { int opt(read&lt;int&gt;()), a(read&lt;int&gt;()), b(read&lt;int&gt;()), c(read&lt;int&gt;()); if (opt == 1) update(T, 1, n, a, b, c); else printf(\"%d\\n\", query(T, 1, n, a, b, c)); } return 0;}","link":"/2019/03/18/BZOJ-3110/"},{"title":"è¯»å…¥é»‘ç§‘æŠ€","text":"è¿™é‡Œè¦Orzä¸€ä¸‹LKå¤§ä½¬~~ å¾ˆä¹…ä»¥å‰ï¼Œæˆ‘å¬è¯´è¿‡ä¸€ä¸ªå«freadçš„ä¸œè¥¿ ç„¶è€Œæˆ‘å¹¶ä¸ä¼šç”¨ï¼ç›´åˆ°æœ‰ä¸€å¤©ï¼Œæˆ‘æ‰“å¼€å¤§ä½¬çš„åšå®¢ å¤ªå¼ºäº†ï¼123456789101112131415161718#include&lt;****&gt;const int N=1&lt;&lt;27;//å¯ä»¥ä¿®æ”¹ï¼Œè¡¨ç¤ºè¾“å…¥æ–‡ä»¶ä¸ä¼šè¶…è¿‡çš„é•¿åº¦char buf[N],*inf=buf;int read(){//è¿™æ˜¯ä¸€ä¸ªè¯»ä¸è¿›è´Ÿæ•°çš„æ•°å­—è¯»å…¥ int k=0; while(!isdigit(*inf))++inf; while(isdigit(*inf)){ k=k*10+(*inf-'0'); ++inf; } return k;}int main(){ //freopen(***); //å¼€æ–‡ä»¶å¿…é¡»åœ¨freadå‰é¢ fread(buf, 1, N, stdin);//è¯»å…¥æ•´ä¸ªè¾“å…¥æ–‡ä»¶ ***** return 0;}","link":"/2017/01/01/è¯»å…¥é»‘ç§‘æŠ€/"}],"tags":[{"name":"æ ‘å¥—æ ‘","slug":"æ ‘å¥—æ ‘","link":"/tags/æ ‘å¥—æ ‘/"},{"name":"é«˜çº§æ•°æ®ç»“æ„","slug":"é«˜çº§æ•°æ®ç»“æ„","link":"/tags/é«˜çº§æ•°æ®ç»“æ„/"},{"name":"ä¸»å¸­æ ‘","slug":"ä¸»å¸­æ ‘","link":"/tags/ä¸»å¸­æ ‘/"},{"name":"FFTã€NTT","slug":"FFTã€NTT","link":"/tags/FFTã€NTT/"},{"name":"å­—ç¬¦ä¸²","slug":"å­—ç¬¦ä¸²","link":"/tags/å­—ç¬¦ä¸²/"},{"name":"é»‘ç§‘æŠ€","slug":"é»‘ç§‘æŠ€","link":"/tags/é»‘ç§‘æŠ€/"},{"name":"å¹³è¡¡æ ‘","slug":"å¹³è¡¡æ ‘","link":"/tags/å¹³è¡¡æ ‘/"},{"name":"ACè‡ªåŠ¨æœº","slug":"ACè‡ªåŠ¨æœº","link":"/tags/ACè‡ªåŠ¨æœº/"},{"name":"æŠ€å·§","slug":"æŠ€å·§","link":"/tags/æŠ€å·§/"},{"name":"å€å¢","slug":"å€å¢","link":"/tags/å€å¢/"},{"name":"æ ‘ä¸Šè«é˜Ÿ","slug":"æ ‘ä¸Šè«é˜Ÿ","link":"/tags/æ ‘ä¸Šè«é˜Ÿ/"},{"name":"å‘","slug":"å‘","link":"/tags/å‘/"},{"name":"Kruskalé‡æ„æ ‘","slug":"Kruskalé‡æ„æ ‘","link":"/tags/Kruskalé‡æ„æ ‘/"},{"name":"å£èƒ¡ç³»åˆ—","slug":"å£èƒ¡ç³»åˆ—","link":"/tags/å£èƒ¡ç³»åˆ—/"},{"name":"èƒ¡é—¹ç³»åˆ—","slug":"èƒ¡é—¹ç³»åˆ—","link":"/tags/èƒ¡é—¹ç³»åˆ—/"},{"name":"è®¡ç®—å‡ ä½•","slug":"è®¡ç®—å‡ ä½•","link":"/tags/è®¡ç®—å‡ ä½•/"},{"name":"æ–œç‡ä¼˜åŒ–","slug":"æ–œç‡ä¼˜åŒ–","link":"/tags/æ–œç‡ä¼˜åŒ–/"},{"name":"excrt","slug":"excrt","link":"/tags/excrt/"},{"name":"WO YE BU HUI","slug":"WO-YE-BU-HUI","link":"/tags/WO-YE-BU-HUI/"},{"name":"Hash","slug":"Hash","link":"/tags/Hash/"},{"name":"lct","slug":"lct","link":"/tags/lct/"},{"name":"ç½‘ç»œæµ","slug":"ç½‘ç»œæµ","link":"/tags/ç½‘ç»œæµ/"},{"name":"äº¤äº’","slug":"äº¤äº’","link":"/tags/äº¤äº’/"},{"name":"ç”Ÿæˆå‡½æ•°","slug":"ç”Ÿæˆå‡½æ•°","link":"/tags/ç”Ÿæˆå‡½æ•°/"},{"name":"å¥—è·¯","slug":"å¥—è·¯","link":"/tags/å¥—è·¯/"},{"name":"èƒ¡é—¹","slug":"èƒ¡é—¹","link":"/tags/èƒ¡é—¹/"},{"name":"æ¯’ç˜¤è®¡æ•°","slug":"æ¯’ç˜¤è®¡æ•°","link":"/tags/æ¯’ç˜¤è®¡æ•°/"},{"name":"å¡å¸¸","slug":"å¡å¸¸","link":"/tags/å¡å¸¸/"},{"name":"æ•°è®º","slug":"æ•°è®º","link":"/tags/æ•°è®º/"},{"name":"è«æ¯”ä¹Œæ–¯åæ¼”","slug":"è«æ¯”ä¹Œæ–¯åæ¼”","link":"/tags/è«æ¯”ä¹Œæ–¯åæ¼”/"},{"name":"å®¹æ–¥","slug":"å®¹æ–¥","link":"/tags/å®¹æ–¥/"},{"name":"å·¦åæ ‘","slug":"å·¦åæ ‘","link":"/tags/å·¦åæ ‘/"},{"name":"å¯å¹¶å †","slug":"å¯å¹¶å †","link":"/tags/å¯å¹¶å †/"}],"categories":[{"name":"é¢˜è§£","slug":"é¢˜è§£","link":"/categories/é¢˜è§£/"},{"name":"æ‚é¡¹","slug":"æ‚é¡¹","link":"/categories/æ‚é¡¹/"},{"name":"é¢˜è§£ï¼ˆå£èƒ¡ï¼‰","slug":"é¢˜è§£ï¼ˆå£èƒ¡ï¼‰","link":"/categories/é¢˜è§£ï¼ˆå£èƒ¡ï¼‰/"},{"name":"åˆé›†","slug":"é¢˜è§£/åˆé›†","link":"/categories/é¢˜è§£/åˆé›†/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","link":"/categories/æ¨¡æ¿/"}]}