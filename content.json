{"pages":[{"title":"关于QAQ","text":"众所周知很菜的一个Oier。 我的邮箱是yms-chenziyang@outlook.com 我的QQ?16830053325","link":"/about/index.html"}],"posts":[{"title":"Todo List","text":"咕咕咕咕咕 emm我觉得我回来了。然后吗，计划什么重新搞一搞吧。下面再是维(gu)持(gu)不(gu)变(gu)吧。 今天看了一下黑板，好像只有$22$天的逍遥日子过了。菜死了菜死了。好慌啊，于是定个计划算了。 先是还要学的数据结构 平衡树 动态树 主席树 珂朵莉树 可持久化 AC自动机 回文自动机 后缀自动机 李超线段树 ZKW数据结构 线段树树套线段树 线段树树套平衡树 算法 分块 莫队 点分治 边分治 插头dp CDQ分治 模拟退火 整体二分 康托展开 manacher 粒子群优化 高级网络流 计算几何 凸包 旋转卡壳 解析 优化 单调队列 斜率优化 四边形不等式 数学 FFT NTT MTT FWT polya 博弈论 杜教筛 单纯型 微积分 斯特林数 计算几何基础 莫比乌斯反演","link":"/2019/03/14/Todo-List/"},{"title":"胡闹 交互程序","text":"毒瘤交互。 题目大意有$N$个盒子，第$i$个盒子里面有$p_i$个球，从一个盒子中只能拿一个球出来。求恰好拿出来$M$个球的方案数，对$998244353$取模。 你不知道$pi​$的具体的值，只能指定操作。 具体来说，你有一个长度为$T$的整型数组$A$，其中前$N$个位置初始存的是$p_1,p_2,⋯,p_N$。其余位置的初始值由你通过Set操作来决定。 在决定完初始值之后，你就只能指定操作了。你只能提出： $A_i=A_j+A_k$ $A_i=A_j−A_k$ $A_i=A_j\\times A_k$（所有运算均在模$998244353$意义下） 过程中不允许你修改前$N$个位置的值。 过程中不允许使用Set操作赋值。 你还需要指出$A$中的哪一个数是答案。 数据范围$1\\le M\\le N\\le 1000,T=1004$ 解析由生成函数，答案显然为：$$Ans=\\prod_{i=1}^n (1+p_i\\times x) [x^{n-m}]$$然后我们考虑一些事情： 操作的处理归零直接把一个数减去自身即可。 归一费马小定理即可。$$a^{P-1}\\equiv1(\\bmod P)$$ 复制先归零，然后加起来即可。 （计算中）赋值在计算前，先搞一个$1$出来。 把要赋的值二进制分解赋值即可。 优化直接搞暴力复杂度有点爆炸。 考虑一下$IDFT$的过程，那么我们可以把答案化成这样的形式：$$Ans=\\frac{1}{N}\\times\\sum_{i=0}^{N-1}f(\\omega_N^i)\\times\\omega_N^{-i\\times m}$$这个时候我们就发现$T=1004$给我们剩下了哪$4$个变量了：$$Ans,f(x),x,y=1$$ 实现时预处理出$\\omega_N^i$即可。 Notice哎呀这个东西时真的坑。 我被我的巨大常数送走无数次之后，决心： 让常数优化成为习惯。 然后我就疯狂加inline，然后就疯狂Complie Error。 调了好久，最后原因是交互库你里面的函数没有inline，而我加了。 这样会导致什么呢？对，交互库的函数就没有定义了。 而且这个东西不用g++ -o %&lt; % grader.cpp还查不出来。 难受😔。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#define REP(i, s, e) for (int i = s; i &lt;= e; i++)#include &lt;bits/stdc++.h&gt;#include \"polynomial.h\"using namespace std;const int maxn = 1000 + 30, g = 3, MOD = 998244353;int n, m, t, N = 1 &lt;&lt; 10;int ans, fx, w[maxn], t1, t2;inline int power_pow(int a, int b){ int ans = 1, base = a; while (b) { if (b &amp; 1) ans = 1ll * ans * base % MOD; base = 1ll * base * base % MOD; b &gt;&gt;= 1; } return ans;}void Init(int n, int m, int t){ ::n = n; ::m = n - m; N = 1024; Set(ans = n + 4, 0); Set(fx = n + 1, 0); Set(t1 = n + 2, 1); Set(t2 = n + 3, 1); w[0] = 1; w[1] = power_pow(3, (MOD - 1) / N); REP(i, 2, N - 1) w[i] = 1ll * w[i-1] * w[1] % MOD;}inline void Set_Zero(int x) {Minus(x, x, x);}inline void Copy(int i,int j){ Set_Zero(i); Plus(i, i, j);//i = i + j = 0 + j = j}inline void Power_pow(int base, int b){ bool first = 1; while (b) { if (b &amp; 1) if (first) { first = 0; Copy(t1, base); } else Multiply(t1, t1, base); Multiply(base, base, base); b &gt;&gt;= 1; } Copy(base, t1);}inline void Set_One(int x) {Power_pow(x, MOD - 1);/*a ^ (P-1) = 1 (MOD P)*/;}inline void Get(int x){ Set_One(t2); Set_Zero(t1); while (x) { if (x &amp; 1) Plus(t1, t1, t2); Plus(t2, t2, t2); x &gt;&gt;= 1; }}void Solve(){ REP(i, 0, N - 1) { Set_One(t2); Copy(fx, t2); Get(w[i]); REP(j, 1, n) { Plus(t1, t1, j); Multiply(fx, fx, t1); Minus(t1, t1, j); } Get(w[((-i * m % N) + N) % N]); Multiply(fx, fx, t1); Plus(ans, ans, fx); } Get(power_pow(N, MOD-2)); Multiply(ans, ans, t1); Answer(ans);}","link":"/2019/07/28/胡闹-交互程序/"},{"title":"胡闹 统计三角形","text":"题目大意给你平面上$n\\le3000$个点，每个点有一个颜色$c_i\\in[0,2]$。 定义一个三角形是好的，当且仅当这个三角形的三个定点颜色不同。 定义一对三角形是好的，当且仅当这两个三角形是好的其这两个三角形没有交集。 为了避免歧义，保证点的坐标互不相同。 统计好的三角形对有多少。 解析首先，两个三角形没有交集的的充要条件是这两个三角形之间存在两条内公切线。 那么我们就可以枚举内公切线。 这条直线会把平面分成两个部分，然后有贡献的点对一定一个在这条直线左边，一个在这条直线右边。 那我们可以先枚举一个点，然后把其他的点做极角排序。极角排序用向量比较麻烦，那就直接三角函数吧。 按照这样的顺序枚举两个点来枚举内公切线，就可以保证每次都只会把一个点从一边丢到另一边去。 统计的时候大力讨论一下颜色就可以了。 Notice值得注意的是，如果管坐标大小直接随便搞，答案会是真正的答案的$4$倍，要记得把这个东西搞掉。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#define REP(i, s, e) for (int i = s; i &lt;= e; i++)#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;using namespace std;const int maxn = 3000 + 10;const double pi = acos(-1), inf = 1e20;int n;long long ans;int cnt[2][3];//cnt[0/1][x] 分割线左右的cntbool app[maxn];//被搞过去几次struct point{ int x, y, c, id; double k; bool operator &lt; (point B) const {return k &lt; B.k;}//极角排序}P[maxn], p[maxn], O;int main(){#ifndef ONLINE_JUDGE freopen(\"B.in\", \"r\", stdin); freopen(\"B.out\", \"w\", stdout);#endif cin &gt;&gt; n; REP(i, 1, n) scanf(\"%d%d%d\", &amp;P[i].x, &amp;P[i].y, &amp;P[i].c), P[i].id = i; long long tmp; REP(i, 1, n) { O = P[i]; int k = O.c; copy(P + 1, P + 1 + n, p + 1); int cur(0); REP(j, 1, n) if (i ^ p[j].id) { p[++cur]=p[j]; p[cur].k = atan2(p[cur].y - O.y, p[cur].x - O.x); if (p[cur].k &lt;= 0) p[cur].k += pi; } sort(p + 1, p + n); memset(cnt, 0, sizeof(cnt)); memset(app, 0, sizeof(app)); REP(j, 1, cur) if (p[j].y &lt; O.y || p[j].y == O.y &amp;&amp; p[j].x &gt; O.x) ++cnt[0][p[j].c];//一开始下面 else ++cnt[1][p[j].c], app[j] = 1; REP(j, 1, cur) { --cnt[app[j]][p[j].c]; tmp = 1ll * (k ? cnt[0][0] : 1) * (p[j].c ? cnt[1][0] : 1) * ((k ^ 1) ? cnt[0][1] : 1) * ((p[j].c ^ 1) ? cnt[1][1] : 1) * ((k ^ 2) ? cnt[0][2] : 1) * ((p[j].c ^ 2) ? cnt[1][2] : 1);//大力统计颜色 ans += tmp; tmp = 1ll * (k ? cnt[1][0] : 1) * (p[j].c ? cnt[0][0] : 1) * ((k ^ 1) ? cnt[1][1] : 1) * ((p[j].c ^ 1) ? cnt[0][1] : 1) * ((k ^ 2) ? cnt[1][2] : 1) * ((p[j].c ^ 2) ? cnt[0][2] : 1); ans += tmp; ++cnt[app[j] ^= 1][p[j].c]; } } cout &lt;&lt; ans / 4 &lt;&lt; endl; return 0;}","link":"/2019/07/28/胡闹-统计三角形/"},{"title":"口胡 最小K覆盖圆","text":"这个什么“最小$K$覆盖圆”其实是我瞎整的一个定义。 题目大意给定平面上$n\\le500$个点$(x_i,y_i)$，求出最小的一个半径$r$使得有至少$k$个点被某个以$r$为半径的圆覆盖（包含边界）。 精确到$10^{-8}$。 解析这是一个悲伤的故事。如果不那么精确，比如说精确到$10^5$，那什么随机算法爬山啊、退火啊、粒子群啊都能过 这是一个更悲伤的故事UOJ的clock()好像是假的，这样就造成了薛定谔的TLE。 我们考虑二分答案。 显然可以先枚举一个固定点，然后确保这个固定点在圆的边界上。 注意到枚举固定点的时候，包含一个点的圆是一段区间。 那么我们的问题就变成了了给出若干段区间，问有没有一个位子被$k−1$个区间包含。 暴力二分答案的复杂度是$\\mathcal{O}(n^2log\\ n\\ log\\ ans)$的，不太行。 考虑稍微剪一下枝。如果我们当前点对于最优解不合法（搞不定那么多个区间），就直接不管了。 然后random_shuffle一下，复杂度就变成了期望$\\mathcal{O}(nlog^2\\ nlog\\ ans)$了。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586//modify to learn#define REP(i, s, e) for (int i = s; i &lt;= e; i++)#define dis(x1, y1, x2, y2) sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2))#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#define double long double#define point pair&lt;double, double&gt;#define x first#define y secondusing namespace std;const int maxn = 500 + 5;const double eps = 1e-9, inf = 1e20;int n, k;point a[maxn], b[maxn &lt;&lt; 1];double ans;inline double dist(point A, point B) {return dis(A.x, A.y, B.x, B.y);}inline int dcmp(double x) {return (x &gt; eps) - (x &lt; -eps);}bool same(double x, double y) {return fabs(x-y) &lt; eps;}inline bool cmp(point A, point B) {return A.x &lt; B.x || A.x == B.x &amp;&amp; A.y &lt; B.y;}point operator + (point A, point B) {return make_pair(A.x + B.x, A.y + B.y);}point operator - (point A, point B) {return make_pair(A.x - B.x, A.y - B.y);}point operator / (point A, double u) {return make_pair(A.x / u, A.y / u);}point operator * (point A, double u) {return make_pair(A.x * u, A.y * u);}inline void calc(point o1, point o2, double r, point&amp; x, point&amp; y){ double Dis = dist(o1, o2) / 2; point mid = (o1 + o2) / 2, p = (o2 - o1) / 2; p = make_pair(p.y, -p.x) / Dis * sqrt(r * r - Dis * Dis); x = mid + p, y = mid - p;}inline bool check(point o, double r){ int m = k - 1, p = 0; REP(i, 1, n) if (dcmp(dist(o, a[i])) &amp;&amp; dcmp(dist(o, a[i]) - 2 * r) &lt;= 0) { point x,y; calc(o, a[i], r, x, y); double ax = atan2(x.y - o.y, x.x - o.x), ay = atan2(y.y - o.y, y.x - o.x); b[++p] = make_pair(ax, -1); b[++p] = make_pair(ay, 1); if (ax &gt; ay) m--; } if (m &lt;= 0) return 1; sort(b + 1, b + p + 1, cmp); REP(i, 1, p) if ((m += b[i].y) &lt;= 0) return 1; return 0;}int main(){#ifndef ONLINE_JUDGE freopen(\"A.in\", \"r\", stdin); freopen(\"A.out\", \"w\", stdout);#endif srand(233); cin &gt;&gt; n &gt;&gt; k; REP(i, 1, n) scanf(\"%LF%LF\", &amp;a[i].x, &amp;a[i].y); random_shuffle(a + 1, a + n + 1); double L, R = inf; REP(i, 1, n) if (check(a[i], R)) { L = 0; while (R - L &gt; eps) { double MID = (L + R) / 2; if (check(a[i], MID)) R = MID; else L = MID; } } printf(\"%.8LF\\n\", R); return 0;}","link":"/2019/07/27/口胡-最小K覆盖圆/"},{"title":"口胡 字符串最小等价串","text":"这种东西见过一两次了，稍微口胡一下吧。 定义什么是最小等价串？ 可以理解为把一个字符串中的字符按顺序重新“编号”。 比如说一个字符串S=BBCBA，那么它的最小表示就是T=AABAC。 问题快速判断两个串是否等价（即最小等价串相同） 解析我们发现问题就在于这个字符可以随便搞，这样随便怎样都会挂。 怎么办呢？能不能反过来利用这个东西？ 注意到我们不关心每一种字符具体是什么，只关心它们在哪里出现了。 那么我们可以考虑记last[i]表示字符i上一次出现的位置，第$1$次出现则记为$0$。 不难发现，只要两个字符串对应的i-last[i]相同，它们就是等价的。 比如说字符串S=BBCBA： Source String B B C B A LAST 0 1 0 2 0 i-LAST 1 1 3 2 5 字符串T=AABAC： Source String A A B A C LAST 0 1 0 2 0 i-LAST 1 1 3 2 5 说明S和T是等价的。 而对于SS=AAABC来说： source String A A A B C LAST 0 1 2 0 0 i-LAST 1 1 1 4 5 说明SS与S,T是不等价的。 对不对？WO YE BU HUI。","link":"/2019/07/26/口胡-字符串最小等价串/"},{"title":"胡闹 回文","text":"题目大意求$[0,n]$中有几个$n\\le10^6$位数（考虑前导$0$）满足如下情况： 这个数是一个回文数。 这个数奇数位上的和等于偶数位上的和。 解析假设$n$是一个偶数，那么答案显然是$10^\\frac{n}{2}$对吧。 然后假设$n$是一个奇数。 $\\mathcal{O(n^2)}$ 的$dp$做法我们可以设dp[i][j]​为长度为i（不考虑前导$0$），奇数位与偶数位的差为j的数的总数。 这个随便转移一下就好了。 但是这可能出现负数下标，这很难受，有两个解决方案： #define Dp(i, j) dp[i][j+Min_Value] __gnu_pbds::gp_hash_table&lt;int, int&gt; 但是如果你傻逼如我（不可能）用了这种东西：map&lt;int, int&gt; 那么恭喜你，获得一个$log$的$debuff​$并且挂成暴力。 正确的复杂度这看上去是一个容斥。 然后我们考虑怎么个容斥法。 对于形如$n=4k+1​$的数的话，我们推一推式子：$$\\begin{align}2\\times(x_1 + x_3 + · · · + x_{2k−1}) + x_{2k+1} &amp;= 2 \\times (x_2 + x_4 + · · · + x_{2k})\\\\x_2+x_4+· · ·+x_{2k}+(9−x_1)+(9−x_2)+· · ·+(9−x_{2k−1})&amp;=9k+\\frac{x_{2k+1}}{2}\\end{align}$$那么我们考虑枚举一下$\\frac{x_{2k+1}}{2}​$，这就变成了一个容斥然后隔板法（别问我为什么，WO YE BU HUI）。 对于形如$n=4k+3$的样子，多考虑一个数就可以了（WO YE BU HUI） Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#define REP(i, s, e) for (register int i = s; i &lt;= e; i++)#define DREP(i, s, e) for (register int i = s; i &gt;= e; i--)#include &lt;bits/extc++.h&gt;#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int maxn = 1e7 + 10, MOD = 1e9 + 7;inline int power_pow(int a, int b){ int ans(1), base(a); while (b) { if (b &amp; 1) ans = ans * base % MOD; base = base * base % MOD; b &gt;&gt;= 1; } return (ans + MOD) % MOD;}#define inv(x) power_pow(x, MOD - 2)int n;int fac[maxn], Inv[maxn];inline int C(int n, int m) {return n &lt; m || m &lt; 0 ? 0 : fac[n] * Inv[n-m] % MOD * Inv[m] % MOD;}inline int solve(int S, int n){ int res(0), cur(-1); REP(i, 0, n) res += (cur *= -1) * C(n, i) * C(S - i * 10 + n - 1, n - 1) % MOD, res %= MOD; return (res + MOD) % MOD;}__gnu_pbds::gp_hash_table &lt;int,int&gt; cnt;__gnu_pbds::gp_hash_table &lt;int,int&gt; :: iterator it;signed main(){#ifndef ONLINE_JUDGE freopen(\"B.in\", \"r\", stdin); freopen(\"B.out\", \"w\", stdout);#endif Inv[0] = fac[0] = 1; REP(i, 1, 10000000) fac[i] = fac[i-1] * i % MOD; Inv[10000000] = inv(fac[10000000]); DREP(i, 9999999, 1) Inv[i] = Inv[i+1] * (i+1) % MOD; int T;cin &gt;&gt; T; while (T--) { scanf(\"%lld\", &amp;n); int ans = 0; if (n % 2 == 0) ans = power_pow(10, n &gt;&gt; 1); else if (n == 1) ans = 1; else if (n == 3) ans = 5; else if (n % 4 == 1) REP(i, 0, 4) ans += solve(i + 9 * (n &gt;&gt; 2), n &gt;&gt; 1) % MOD, ans %= MOD; else { cnt.clear(); REP(i, 0, 4) REP(j, 0, 9) cnt[i-j]++; for (it = cnt.begin(); it != cnt.end(); it++) ans += solve(it -&gt; first + 9 * (n &gt;&gt; 2), (n &gt;&gt; 1) - 1) * it -&gt; second % MOD, ans %= MOD; } printf(\"%lld\\n\", ans); } return 0;}","link":"/2019/07/25/胡闹-回文/"},{"title":"胡闹 填数","text":"这种题能做？ 我也就靠着重构$std$过活了。 题目大意给你一个$n\\times m$的矩阵要你填数。填的数范围为$[1,k]$。 问你本质不同的方案有多少。本质不同定义为任意交换行列后无法全同。 Notice时限$4s$ $1\\le n,m\\le45,1\\le k\\le10^9$ 解析一看就是我不会的题。 考虑一下$Brunside$引理（其实大概是$polya$?)。直接随便整数划分枚举行列置换的循环长度，这个复杂度大概是$\\mathcal{O(B_nB_m\\times n\\times m)}$的。 这个复杂度不太行，大概只能卡过$n,m\\le20$的数据。 怎么优化呢？ 我们发现如果我们枚举了行的整数划分，我们其实不用管列的具体情况，只要管一管它的贡献和。 具体来说可以把每个循环长度的贡献全部搞起来$dp$，发现这是一个背包的形式，卡卡常就能低空飞过了。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495//modify#define REP(i, s, e) for (register int i = s; i &lt;= e; i++)#define DREP(i, s, e) for (register int i = s; i &gt;= e; i--)#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;ctime&gt;using namespace std;const long long N = 150, maxn = N + 10, MOD = 1e9 + 7;inline long long power_pow(long long a, long long b){ long long ans = 1, base = a; while (b) { if (b &amp; 1) ans = ans * base % MOD; base = base * base % MOD; b &gt;&gt;= 1; } return ans;}#define inv(x) power_pow(x, MOD-2)int n, m, k;int fac[maxn], Inv[maxn], single[maxn], bin[maxn], dp[maxn];int v[maxn], p;int calc(){ int n = p; REP(i, 1, m) dp[i] = 0; dp[0] = 1; REP(i, 1, m) { long long coef = single[i]; REP(j, 1, n) coef = coef * bin[__gcd(v[j], i)] % MOD; DREP(j, m, 0) { long long cur = coef; for (int k = 1; j + i * k &lt;= m; k++) { dp[j + i * k] = (dp[j + i * k] + dp[j] * cur % MOD * Inv[k]) % MOD; cur = cur * coef % MOD; } } } int ans = dp[m], cnt = 0; REP(i, 1, n) { ans = ans * 1ll * single[v[i]] % MOD; if (i &gt; 1 &amp;&amp; v[i] ^ v[i - 1]) { ans = ans * 1ll * Inv[cnt] % MOD; cnt = 0; } cnt++; } return ans * 1ll * Inv[cnt] % MOD;}int dfs(int less, int last){ if (!less) return calc(); int res = 0; DREP(i, min(less, last), 1) { res = (0ll + res + dfs(less - i, v[++p] = i)) % MOD; --p; } return res;}signed main(){#ifndef ONLINE_JUDGE freopen(\"A.in\", \"r\", stdin); freopen(\"A.out\", \"w\", stdout);#endif cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; fac[0] = Inv[0] = bin[0] = 1; REP(i, 1, N) { fac[i] = 1ll * fac[i - 1] * i % MOD; single[i] = power_pow(i, MOD - 2); bin[i] = 1ll * bin[i - 1] * k % MOD; } Inv[N] = inv(fac[N]); DREP(i, N-1, 1) Inv[i] = 1ll * Inv[i+1] * (i+1) % MOD; cout &lt;&lt; dfs(n, n) &lt;&lt; endl;#ifndef ONLINE_JUDGE cerr&lt;&lt;clock()*1./CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;}","link":"/2019/07/25/胡闹-填数/"},{"title":"Luogu 4074 [WC2013 糖果公园]","text":"传送门 正确性什么的先咕咕咕一下吧，我也不太会。 题目大意有一个$n\\le10^5$个节点的树，每个节点有一个颜色。 每次询问：$$\\sum_cval_c\\times\\sum_{i=1}^{cnt}w_i$$$val_c$表示该颜色的价值 $cnt$表示颜色出现的次数 $w_i$表示该颜色出现$i$次后的价值 带修改。 解析可以考虑用括号序列把这棵树拍平。 给出一个例子： 怎么操作呢？ 我们$dfs$的时候，第一次遇到的时候$push\\_back$一次，回溯的时候也$push\\_back$一次，记一下就好了。 然后树上的问题就变成了区间的问题对吧。 注意到如果一个点碰到了它的左括号又碰到了它的右括号，这个点就是莫得贡献的。就记一个$vis$每次翻转一下$flag$就好了。这个就可以跑莫队。 什么带修改？加一维时间就行。 什么莫队怎么分块？玄学调参即可一般情况开一个$\\mathcal{O}(n^\\frac{2}{3})$就行，总复杂度大概就是$\\mathcal{O}(n^\\frac{5}{3})$。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#define REP(i, s, e) for (int i = s; i &lt;= e; i++)#define DREP(i, s, e) for (int i = s; i &gt;= e; i--)#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100000 + 10, maxm = 100000 + 10, maxq = 100000 + 10, maxw = 1e6 + 10;int bg[maxn], ne[maxn &lt;&lt; 1], to[maxn &lt;&lt; 1], e;void add(int x, int y){ e++; to[e] = y; ne[e] = bg[x]; bg[x] = e;}int n, m, q;int v[maxm], w[maxn];int grand[maxn][20], LOG, depth[maxn], dfn[maxn], low[maxn], cur;int g[maxn &lt;&lt; 1];void dfs(int x){ REP(i, 1, LOG) grand[x][i] = grand[grand[x][i-1]][i-1]; g[dfn[x] = ++cur] = x; for (int i = bg[x]; i ; i = ne[i]) if (to[i] ^ grand[x][0]) { grand[to[i]][0] = x; depth[to[i]] = depth[x] + 1; dfs(to[i]); } g[low[x] = ++cur] = x;}int lca(int x, int y){ if (x == y) return x; if (dfn[x] &gt; dfn[y]) swap(x, y); DREP(i, LOG, 0) if (dfn[grand[y][i]] &gt; dfn[x]) y = grand[y][i]; return grand[y][0];}int col[maxn], last[maxn];int belong[maxn &lt;&lt; 1];struct query{ int l, r, t, id; bool operator &lt; (query b) const {return belong[l] &lt; belong[b.l] || belong[l] == belong[b.l] &amp;&amp; belong[r] &lt; belong[b.r] || belong[l] == belong[b.l] &amp;&amp; belong[r] == belong[b.r] &amp;&amp; t &lt; b.t;}}a[maxm], b[maxm];int cnt1, cnt2;bool vis[maxn &lt;&lt; 1];long long nowans, ans[maxm], cnt[maxw];void add(int x){ if (vis[x]) nowans -= 1ll * v[col[x]] * w[cnt[col[x]]--]; else nowans += 1ll * v[col[x]] * w[++cnt[col[x]]]; vis[x] ^= 1;}void modify(int x, int y){ if (vis[x]) { add(x); col[x] = y; add(x); } else col[x] = y;}int main(){#ifndef ONLINE_JUDGE freopen(\"4074.in\", \"r\", stdin); freopen(\"4074.out\", \"w\", stdout);#endif cin &gt;&gt; n &gt;&gt; m &gt;&gt; q; REP(i, 1, m) scanf(\"%d\", v + i); REP(i, 1, n) scanf(\"%d\", w + i); REP(i, 2, n) { int x, y; scanf(\"%d%d\", &amp;x, &amp;y); add(x, y);add(y, x); } LOG = log2(n); depth[1] = 1; dfs(1); REP(i, 1, n) scanf(\"%d\", col + i), last[i] = col[i]; int block_siz = pow(cur, 2. / 3); REP(i, 1, cur) belong[i] = (i-1) / block_siz; while (q--) { int opt, x, y; scanf(\"%d%d%d\", &amp;opt, &amp;x, &amp;y); if (!opt) { b[++cnt2] = (query){x, last[x], y}; last[x] = y; } else { if (dfn[x] &gt; dfn[y]) swap(x, y); a[++cnt1] = (query){lca(x, y) == x ? dfn[x] : low[x], dfn[y], cnt2, cnt1}; } } sort(a + 1, a + 1 + cnt1); int nowl(0), nowr(0), T(1); REP(i, 1, cnt1) { while (T &lt;= a[i].t) { modify(b[T].l, b[T].t); T++; } while (T &gt; a[i].t) { modify(b[T].l, b[T].r); T--; } while (nowl &lt; a[i].l) add(g[nowl++]); while (nowl &gt; a[i].l) add(g[--nowl]); while (nowr &lt; a[i].r) add(g[++nowr]); while (nowr &gt; a[i].r) add(g[nowr--]); int x(g[nowl]), y(g[nowr]), l(lca(x, y)); if (x ^ l &amp;&amp; y ^ l) { add(l); ans[a[i].id] = nowans; add(l); } else ans[a[i].id] = nowans; } REP(i, 1, cnt1) printf(\"%lld\\n\", ans[i]); return 0;}","link":"/2019/07/24/Luogu-4074-WC2013-糖果公园/"},{"title":"胡闹 tree","text":"题目大意给你一棵$n\\le10^5$的树，你分别有白链、黑链$B,W\\le30000$条。 你要把树上的点染成黑白。如果一条白链锁包含的点都被染成了白色，那你会的得到这条白链的奖励，黑链同理。 求最大奖励。 解析我们首先假设所有的链都能选上并且不冲突。 那么我们只要最小化消去冲突的代价就可以了。 是不是很像最小割？ 我们把一条链上所包含的点全部连起来构成一个网络流上的“大点”，然后就是分别处理黑链、白链之间连边，跑最小割就可以了。 但是这样每个点之间都可能会连一条$inf$的边（表示在都在一条链上，即最小割隔不断它），这样边数可能会爆炸。 怎么办呢？考虑优化连边。 一种可行的方法是上线段树 一个简单的方法是倍增，把一个大区间倍增成几个小区间，然后小区间之间连$inf$边来成为大区间，而不是一个点一个点地连。 这样边数就会显著减少，随便搞一搞就行了。 优化时限$10s$卡常？怎么优化？ 优化$lca$：利用$dfn$，只用一次倍增就可以求出$lca$。这个用处不大，因为还有更好的方法求lca 优化$Dinic$ 当前弧优化 分层的时候从$T$开始分到$S$，我也不知道为什么这样会快很多。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213//modify std//still learning#define REP(i, s, e) for (int i = s; i &lt;= e; i++)#define DREP(i, s, e) for (int i = s; i &gt;= e; i--)#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 10, inf = 1&lt;&lt;30;namespace dinic{ const int maxn = 4e6 + 10, maxm = 3e7 + 100; int bg[maxn], ne[maxm], to[maxm], w[maxm], e = 1; int S, T, dis[maxn], q[maxn], head, tail; int cur[maxn]; void add(int x, int y, int z) { e++; to[e] = y; ne[e] = bg[x]; bg[x] = e; w[e] = z; } void link(int a, int b, int c) {add(a, b, c);add(b, a, 0);} bool bfs() { REP(i, S, T) dis[i] = -1; dis[q[head = tail = 1] = T] = 0; while (head &lt;= tail) { int x = q[head++]; for (int i = bg[x]; i ;i = ne[i]) if (w[i ^ 1] &amp;&amp; dis[to[i]] == -1) dis[q[++tail] = to[i]] = dis[x] + 1; } return dis[S] != -1; } int dfs(int x, int y = inf) { if (x == T || !y) return y; int res = 0; for (int &amp;i = cur[x]; i ; i = ne[i]) if (w[i] &amp;&amp; dis[to[i]] == dis[x] - 1) { int temp = dfs(to[i], min(y, w[i])); if (temp &gt; 0) { res += temp; y -= temp; w[i] -= temp; w[i ^ 1] += temp; if (!y) break; } } return res; } void output() { REP(x, S, T) for (int i = bg[x];i;i=ne[i])printf(\"%d %d %d\\n\",x,to[i],w[i]); } int work() { int ans = 0; while (bfs()) { REP(i, S, T) cur[i] = bg[i]; ans += dfs(S); } return ans; }}int n, B, W, ans, LOG;int dfn[maxn], dfs_clock, grand[maxn][20], depth[maxn];namespace tree{ int bg[maxn], ne[maxn &lt;&lt; 1], to[maxn &lt;&lt; 1], e; void add(int x, int y) { e++; to[e] = y; ne[e] = bg[x]; bg[x] = e; } void dfs(int x) { dfn[x] = ++dfs_clock; REP(i, 1, LOG) grand[x][i] = grand[grand[x][i-1]][i-1]; for (int i = bg[x]; i ; i = ne[i]) if (to[i] ^ grand[x][0]) { grand[to[i]][0] = x; depth[to[i]] = depth[x] + 1; dfs(to[i]); } } void init() { LOG = log2(n); depth[1] = 1; dfs(1); } int lca(int x, int y) { if (x == y) return x; if (dfn[x] &gt; dfn[y]) swap(x, y); DREP(i, LOG, 0) if (dfn[grand[y][i]] &gt; dfn[x]) y = grand[y][i]; return grand[y][0]; }}using tree::add;using tree::lca;using dinic::link;int L[maxn][20], R[maxn][20];vector &lt;pair &lt;int, int&gt; &gt; E;int cur;void getl(int k, int t){ if (!L[k][t]) { L[k][t] = ++cur; getl(k, t - 1); getl(grand[k][t-1], t-1); link(L[k][t], L[k][t-1], inf); link(L[k][t], L[grand[k][t-1]][t-1], inf); }}int jump(int k, int d){ REP(i, 0, LOG) if (d &amp; (1 &lt;&lt; i)) k = grand[k][i]; return k;}void getr(int k, int t){ if (!R[k][t]) { R[k][t] = ++cur; getr(k, t - 1); getr(grand[k][t-1], t-1); link(R[k][t-1], R[k][t], inf); link(R[grand[k][t-1]][t-1], R[k][t], inf); }}void linkl(int k,int a,int c){ if (a==c) return; int t; for (t=0;(1&lt;&lt;(t+1))&lt;depth[a]-depth[c];t++); getl(a, t); link(k, L[a][t], inf); a = jump(a, depth[a]-depth[c]-(1&lt;&lt;t)); getl(a, t); link(k, L[a][t], inf);}void linkr(int k,int a,int c){ if (a==c) return; int t; for (t=0;(1&lt;&lt;(t+1))&lt;depth[a]-depth[c];t++); getr(a, t); link(R[a][t], k, inf); a = jump(a, depth[a]-depth[c]-(1&lt;&lt;t)); getr(a, t); link(R[a][t], k, inf);}int main(){#ifndef ONLINE_JUDGE freopen(\"B.in\",\"r\",stdin); freopen(\"B.out\",\"w\",stdout);#endif cin &gt;&gt; n &gt;&gt; B &gt;&gt; W;ans = n; REP(i, 2, n) { int x, y; scanf(\"%d%d\", &amp;x, &amp;y); add(x, y); } tree::init(); REP(i, 1, n) { L[i][0] = R[i][0] = ++cur; link(0, cur, 1); } while (B--) { int x, y, z, v; scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;v);z = lca(x, y); ++cur; ans += v; link(0, cur, v); linkl(cur, x, grand[z][0]); linkl(cur, y, z); } while (W--) { int x, y, z, v; scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;v);z = lca(x, y); ++cur; ans += v; E.push_back(make_pair(cur, v)); linkr(cur, x, grand[z][0]); linkr(cur, y, z); } dinic::T = ++cur; int siz = (int)E.size() - 1; REP(i, 0, siz) link(E[i].first, cur, E[i].second); REP(i, 1, n) link(i, cur, 1); cout &lt;&lt; ans - dinic::work() &lt;&lt; endl; return 0;}","link":"/2019/07/24/胡闹-tree/"},{"title":"胡闹 interval","text":"题目大意有一些形如$[L,R]$的区间，你要选出尽可能多的区间，并满足区间两两交集为空（注意$[X,X]$非空）。 输出字典序最小的最优方案。 解析首先可以想到一个简单的贪心。 把所有的区间按右端点排序，能取就取，这样一定最优。 如何维护字典序最小？ 考虑二分决策点，然后暴力往回跳。 为什么是对的？WO YE BU HUI Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#define REP(i, s, e) for (int i = s; i &lt;= e; i++)#define chkmin(a, b) a = min(a, b)#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;const int maxn = 200000 + 10;#define mid (l + r &gt;&gt; 1)int n, frm[maxn], last[maxn], dp[maxn], pos;struct line{ int l, r, id;}q[maxn];bool cmp(line A, line B) {return A.r &lt; B.r;}void jump(int x){ int a = x, b = last[x-1], mina(q[a].id), minb(q[b].id); while (frm[a] ^ frm[b]) { chkmin(mina, q[a].id), a = frm[a]; chkmin(minb, q[b].id), b = frm[b]; } chkmin(mina, q[a].id); chkmin(minb, q[b].id); if(mina &lt; minb) dp[x] = dp[pos] + 1, last[x] = x, frm[x] = last[pos]; else dp[x] = dp[x-1], last[x] = last[x-1], frm[x] = frm[x-1];}int stack[maxn], top;int main(){#ifndef ONLINE_JUDGE freopen(\"A.in\", \"r\", stdin); freopen(\"A.out\", \"w\", stdout);#endif cin &gt;&gt; n; REP(i, 1, n) scanf(\"%d%d\", &amp;q[i].l, &amp;q[i].r), q[i].id = i; sort(q + 1, q + 1 + n, cmp); REP(i, 1, n) { int l(0), r(i-1); pos = 0; while (l &lt;= r) if (q[mid].r &lt; q[i].l) { pos = mid; l = mid + 1; } else r = mid - 1; dp[i] = dp[pos] + 1; frm[i] = last[pos]; if (dp[i] &gt; dp[i-1]) dp[i] = dp[pos] + 1, last[i] = i; else if (dp[i] &lt; dp[i-1]) dp[i] = dp[i-1], last[i] = last[i-1]; else jump(i); } cout &lt;&lt; dp[n] &lt;&lt; endl; pos = last[n]; while(pos) stack[++top] = q[pos].id, pos = frm[pos]; sort(stack + 1, stack + 1 + top); REP(i, 1, top) printf(\"%d%c\", stack[i], i == top ? '\\n' : ' '); return 0;}","link":"/2019/07/23/胡闹-interval/"},{"title":"Luogu 2597 [ZJOI2012 灾难]","text":"传送门 题目大意一个食物网有$N$个点，代表$N$种生物，如果生物$x$可以吃生物$y$，那么从$y$向$x$连一个有向边。这个图没有环。 图中有一些点没有连出边，这些点代表的生物都是生产者，可以通过光合作用来生存； 而有连出边的点代表的都是消费者，它们必须通过吃其他生物来生存。 如果某个消费者的所有食物都灭绝了，它会跟着灭绝。 我们定义一个生物在食物网中的“灾难值”为，如果它突然灭绝，那么会跟着一起灭绝的生物的种数。 举个例子：在一个草场上，生物之间的关系是： 如 如果羊都死了，那么狼会因为没有食物而灭绝，而小强可以通过吃牛、牛可以通过吃草来生存下去。所以，羊的灾难值是$1$。 但是，如果草突然灭绝，那么整个草原上的$5$种生物都无法幸免，所以，草的灾难值是$4$。 给定一个食物网，你要求出每个生物的灾难值。 解析把所有的边反向，按时拓扑序处理某个点，这样就可以保证处理一个点的时候，这个点能吃的点都会被吃掉。现在我们假设处理一个点之前，其他的点统统都是一棵树的形态。 那么这个点吃的所有，等价于吃吃的所有的lca。 这个随便维护。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#define REP(i, s, e) for (int i = s; i &lt;= e; i++)#define DREP(i, s, e) for (int i = s; i &gt;= e; i--)#define DEBUG fprintf(stderr, \"Passing [%s] in Line %d\\n\", __FUNCTION__, __LINE__)#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cmath&gt;using namespace std;const int maxn = 70000 + 10, maxm = maxn;int bg[maxn], ne[maxn], to[maxn], e;void add(int x, int y){ e++; to[e] = y; ne[e] = bg[x]; bg[x] = e;}int n, k, depth[maxn], grand[maxn][20], LOG;int tcnt;vector &lt;int&gt; G[maxn], eat[maxn];int in[maxn], q[maxn], head, tail;int lca(int x, int y){ if (depth[x] &lt; depth[y]) swap(x, y); DREP(i, LOG, 0) if (depth[grand[x][i]] &gt;= depth[y]) x = grand[x][i]; if (x == y) return x; DREP(i, LOG, 0) if (grand[x][i] ^ grand[y][i]) x = grand[x][i], y = grand[y][i]; return grand[x][0];}int ans[maxn];void dfs(int x){ ans[x] = 1; for (int i = bg[x]; i ;i = ne[i]) { dfs(to[i]); ans[x] += ans[to[i]]; }}int main(){#ifndef ONLINE_JUDGE freopen(\"2597.in\", \"r\", stdin); freopen(\"2597.out\", \"w\", stdout);#endif cin &gt;&gt; n;LOG = log2(n); REP(i, 1, n) while (scanf(\"%d\", &amp;k), k) G[k].push_back(i), in[i]++, eat[i].push_back(k); REP(i, 1, n) if (!in[i]) depth[q[++tail] = i] = 1; while (head &lt;= tail) { int x = q[head++]; int siz = (int)G[x].size()-1; REP(i, 0, siz) if (!(--in[G[x][i]])) q[++tail] = G[x][i]; if (!eat[x].empty()) { siz = (int)eat[x].size() - 1; int l = eat[x][0]; REP(i, 1, siz) l = lca(l, eat[x][i]); grand[x][0] = l; depth[x] = depth[l] + 1; REP(j, 1, LOG) grand[x][j] = grand[grand[x][j-1]][j-1]; add(l, x); } } REP(i, 1, n) if(!ans[i])dfs(i); REP(i, 1, n) printf(\"%d\\n\", ans[i] - 1); return 0;}","link":"/2019/07/23/Luogu-2597-ZJOI2012-灾难/"},{"title":"胡闹 reform","text":"题目大意给你两个长度分别为$n,m\\le10^6$的串$S,T$。 询问$S$中有多少子串可以经过变换全等于$T$。 变换的定义是交换某个元素，即把元素$x$与元素$y$交换。 如$S=12321$， 交换$1$和$2$变成$S=21312$ 交换$1$和$4$变成$S=42324$ 解析UPD：加了一片口胡，可以search一下（懒得放link)了不用管具体元素的值，只需要关心一下离它最近的之前出现的它和之后出现的它离它的距离，把这个距离$Hash$一下就可以了。 然后注意搞到答案的时候要废掉后面的一些东西（因为移动字串相当于删掉了串首，加入了一个新元素。对于串首后面的”之前出现的”自然要更新，也就是要更新最早出现的之后的它） 语文太菜，看Code吧 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#define REP(i, s, e) for (int i = s; i &lt;= e ; i++)#define DREP(i, s, e) for (int i = s; i &gt;= e ; i--)#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;const int maxn = 1000000 + 10, maxm = 1000000 + 10;template &lt;typename T&gt; T read(){ T ans(0); char c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) { ans = ans * 10 + c - 48; c = getchar(); } return ans;}int n, m, a[maxn], b[maxm], c[maxn], s[maxn], t[maxm], temp[maxn + maxm &gt;&gt; 1];unsigned long long P = 131, bin[maxn], h, H;int ans, pos[maxn];int main(){#ifndef ONLINE_JUDGE freopen(\"A.in\", \"r\", stdin); freopen(\"A.out\", \"w\", stdout);#endif bin[0] = 1; REP(i, 1, 1e6) bin[i] = bin[i-1] * P; int Case(read&lt;int&gt;()), C(read&lt;int&gt;()); while (Case--) { n = read&lt;int&gt;();m = read&lt;int&gt;(); REP(i, 1, n) temp[i] = 0; REP(i, 1, n) s[i] = read&lt;int&gt;(), (a[i] = temp[s[i]] ? i - temp[s[i]] : m), temp[s[i]] = i; REP(i, 1, m) temp[i] = 0; REP(i, 1, m) t[i] = read&lt;int&gt;(), (b[i] = temp[t[i]] ? i - temp[t[i]] : m), temp[t[i]] = i; REP(i, 1, n) temp[i] = 0; DREP(i, n, 1) c[i] = temp[s[i]], temp[s[i]] = i; h = H = 0; REP(i, 1, m) H = H * P + b[i]; REP(i, 1, m) h = h * P + a[i]; ans = 0; if (h == H) pos[++ans] = 1; REP(i, 1, n - m) { h -= bin[m-1] * a[i]; if (c[i] &amp;&amp; c[i] &lt; i + m) h += bin[i-c[i]-1+m] * (m-a[c[i]]); a[c[i]] = m; h = h * P + a[i+m]; if (h == H) pos[++ans] = i + 1; } printf(\"%d\\n\", ans); REP(i, 1, ans) printf(\"%d%c\", pos[i], i == ans ? '\\n' : ' '); } return 0;}","link":"/2019/07/22/胡闹-reform/"},{"title":"胡闹 老园丁与小司机","text":"题目大意你是一个资本家，你的花园结构是一棵$n\\le3\\times10^5$个节点的树，有$m\\le 3\\times10^5$个无产阶级可以帮你标记路径，但只能是从一个节点到它的某一个祖先。 雇佣某个无产阶级需要工资。你想知道让你的花园里面所有的边都被标记所需要支付的最小工资。 如果全部雇佣也不够，你就会放 弃 思 考，认为需要$-1$的工资。 解析我 放 弃 了 思 考。 考虑树形$dp$，用左偏树维护决策。 发现可以维护无产阶级深度最高点为关键字的左偏树来维护决策，无脑上代码即可。 注意打标记。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#define REP(i, s, e) for (int i = s; i &lt;= e ; i++)#define DEBUG fprintf(stderr, \"Passing [%s] in Line %d\\n\", __FUNCTION__, __LINE__)#include &lt;iostream&gt;#include &lt;cstdio&gt;#define int long longusing namespace std;const int maxn = 300000 + 10, maxm = maxn, inf = 1ll &lt;&lt; 40;int bg[maxn], ne[maxm &lt;&lt; 1], to[maxm &lt;&lt; 1], e;void add(int x, int y){ e++; to[e] = y; ne[e] = bg[x]; bg[x] = e;}int depth[maxn];void dfs(int x, int fa = -1){ for (int i = bg[x]; i ; i = ne[i]) if (to[i] ^ fa) { depth[to[i]] = depth[x] + 1; dfs(to[i], x); }}struct worker{ int up, w, ne;}p[maxm &lt;&lt; 1];int cur = 300000;void insert(int x, int up, int w){ p[++cur] = (worker){up, w, p[x].ne}; p[x].ne = cur;}struct heap *null;heap* merge(heap *x, heap *y){};struct heap{ int up, f, Min, tag, dis; heap *l, *r; void pushdown() { if (tag) { f += tag; Min += tag; l -&gt; tag += tag; r -&gt; tag += tag; tag = 0; } } void pushup() { Min = min(f, min(l -&gt; Min + l -&gt; tag, r -&gt; Min + r -&gt; tag)); if (l -&gt; dis &lt; r -&gt; dis) swap(l, r); dis = r -&gt; dis + 1; } void pop() {*this = merge(l, r);}}pool[maxn], *now = pool, *root[maxn];heap* merge(heap *x, heap *y){ if (x == null) return y; if (y == null) return x; x -&gt; pushdown();y -&gt; pushdown(); if (x -&gt; up &lt;= y -&gt; up) swap(x, y); x -&gt; r = merge(x -&gt; r, y); x -&gt; pushup(); return x;}void solve(int x, int fa = -1){ int sum = 0; for (int i = bg[x]; i ; i = ne[i]) if (to[i] ^ fa) { solve(to[i], x); while (root[to[i]] -&gt; up &gt;= depth[to[i]]) root[to[i]].pop(); if (root[to[i]] == null) { cout &lt;&lt; -1 &lt;&lt; endl; exit(0); } sum += root[to[i]] -&gt; Min; } for (int i = p[x].ne; i ; i = p[i].ne) { *now = (heap) {p[i].up, sum + p[i].w, sum + p[i].w, 0, 1, null, null}; root[x] = merge(root[x], now++); } for (int i = bg[x]; i ; i = ne[i]) if (to[i] ^ fa) { int Min = root[to[i]] -&gt; Min; root[to[i]] -&gt; tag += sum - Min; root[x] = merge(root[x], root[to[i]]); } if (root[x] == null) { cout &lt;&lt; -1 &lt;&lt; endl; exit(0); }}int m, n, k;signed main(){#ifndef ONLINE_JUDGE freopen(\"A.in\", \"r\", stdin); freopen(\"A.out\", \"w\", stdout);#endif cin &gt;&gt; n &gt;&gt; m; REP(i, 2, n) { int x, y; scanf(\"%lld%lld\", &amp;x, &amp;y); add(x, y);add(y, x); } depth[1] = 1; dfs(1); REP(i, 1, m) { int u, v, w; scanf(\"%lld%lld%lld\", &amp;u, &amp;v, &amp;w); insert(u, depth[v], w); } null = new heap; null -&gt; l = null -&gt; r = null; null -&gt; Min = inf; REP(i, 1, n) root[i] = null; solve(1); printf(\"%lld\\n\", root[1] -&gt; Min + root[1] -&gt; tag); return 0;}","link":"/2019/07/21/胡闹-老园丁与小司机/"},{"title":"胡闹 string","text":"题目大意定义两个字符串匹配为它们的最小循环表示法相同。给定一个模式串和$n$个主串，求模式串对每一个主串的模式匹配次数。 最小循环表示法：对一个长度为$n$的字符串做$n$次操作，每次把第一个字符放到最后。这$n$个串中字典序最小的称为最小循环表示法 解析循环主串不好搞，我们就循环模式串。 然后如果循环后的模式串匹配上了，那说明这个匹配的地方的最小表示法和模式串一定是可以匹配上的。 直接一个$Hash$走人。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546#define REP(i, s, e) for (int i = s; i &lt;= e ; i++)#include &lt;bits/stdc++.h&gt;#define int unsigned long longusing namespace std;const int maxn = 100 + 5, maxlen = 1e6 + 10, P = 1e9 + 7;unordered_map &lt;int, bool&gt; cnt;int n, Hash[maxlen];char s[maxlen];int power_pow(int a, int b){ int ans = 1, base = a; while (b) { if (b &amp; 1) ans *= base; base *= base; b &gt;&gt;= 1; } return ans;}signed main(){#ifndef ONLINE_JUDGE freopen(\"B.in\", \"r\", stdin); freopen(\"B.out\", \"w\", stdout);#endif scanf(\"%s\", s + 1); int len = strlen(s + 1); REP(i, len + 1, len + len) s[i] = s[i-len]; REP(i, 1, len + len) Hash[i] = Hash[i-1] * P + s[i]; int PP = power_pow(P, len); REP(i, 1, len) cnt[Hash[i + len - 1] - Hash[i-1] * PP] = 1; cin &gt;&gt; n; while (n--) { scanf(\"%s\", s + 1); int Len = strlen(s + 1), ans(0); REP(i, 1, Len) Hash[i] = Hash[i-1] * P + s[i]; if (Len &gt;= len) REP(i, 1, Len - len + 1) ans += cnt[Hash[i + len - 1] - Hash[i-1] * PP]; printf(\"%llu\\n\", ans); } return 0;}","link":"/2019/07/21/胡闹-string/"},{"title":"胡闹 序列","text":"题目大意给定一个长度为$n\\le10^6$的序列$x$。 你需要从序列中选出一些位置。对于第$i$个位置，如果它被选中，你会获得$x_i$的收益；如果它没被选中，找到最小的$j$使得第$j$个位置到第$i$个位置都没有被选中，你需要付出$i−j+1$的代价。 此外，你选出的位置必须满足$x_i$是单调不下降的。 最大化收益减去代价的结果。 解析可以先考虑一下$x_i$单调不降的情况。 设$dp_i$表示最后一个选的数是第$i$个的最佳答案，则：$$dp_i=x_i+max{dp_j+\\frac{(i-j)\\times(i-j-1)}{2}}$$这个东西是一个非常板子的斜率优化对吧。 然后怎么考虑$x_i$无序的情况呢？ 我们发现，我们采用的顺序是可以换的。 那么我们对$x_i$进行分治，就是把$x_i$分成$(l,r)$的区间分别计算答案，然后归并一下就好了。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586//for test ? why#define REP(i, s, e) for (int i = s; i &lt;= e ; i++)#include &lt;stdio.h&gt;#include &lt;algorithm&gt;typedef long long ll;namespace io { const int SIZE = (1 &lt;&lt; 21) + 1; char ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr; // getchar#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++) // print the remaining part inline void flush () { fwrite (obuf, 1, oS - obuf, stdout); oS = obuf; } // putchar inline void putc (char x) { *oS ++ = x; if (oS == oT) flush (); } // input a signed integer template &lt;class I&gt; inline void gi (I &amp;x) { for (f = 1, c = gc(); c &lt; '0' || c &gt; '9'; c = gc()) if (c == '-') f = -1; for (x = 0; c &lt;= '9' &amp;&amp; c &gt;= '0'; c = gc()) x = x * 10 + (c &amp; 15); x *= f; } // print a signed integer template &lt;class I&gt; inline void print (I &amp;x) { if (!x) putc ('0'); if (x &lt; 0) putc ('-'), x = -x; while (x) qu[++ qr] = x % 10 + '0', x /= 10; while (qr) putc (qu[qr --]); }}using io :: gi;using io :: putc;using io :: print;const int N = 1000005, G = 21;int n, a[N], id[N], rid[N], qu[N], ql, qr, pos[G][N], m; ll dp[N], ret;bool check (int x, int y, int z) { return (dp[z] - dp[y]) * (y - x) &gt;= (dp[y] - dp[x]) * (z - y); }void mergesort (int l, int r, int d) { if (l == r) return (void)(pos[d][l] = id[l]); int mi = (l + r) &gt;&gt; 1, i = l, j = mi + 1; mergesort (l, mi, d + 1); mergesort (mi + 1, r, d + 1); int *x = pos[d], *y = pos[d + 1], p = l; while (p &lt;= r) if (i &lt;= mi &amp;&amp; (y[i] &lt; y[j] || j &gt; r)) x[p ++] = y[i ++]; else x[p ++] = y[j ++];}void solve (int l, int r, int d) { if (l == r) { int u = id[l]; dp[u] += a[u] - (ll)u * u; return ; } int mi = (l + r) &gt;&gt; 1, i; solve (l, mi, d + 1); for (ql = 1, qr = 0, i = l; i &lt;= r; i ++) { int u = pos[d][i]; if (rid[u] &lt;= mi) { while (ql &lt; qr &amp;&amp; check (qu[qr - 1], qu[qr], u)) qr --; qu[++ qr] = u; } else { while (ql &lt; qr &amp;&amp; dp[qu[ql]] + (ll)u * qu[ql] &lt;= dp[qu[ql + 1]] + (ll)u * qu[ql + 1]) ql ++; if (ql &lt;= qr) dp[u] = std :: max (dp[u], dp[qu[ql]] + (ll)u * qu[ql]); } } solve (mi + 1, r, d + 1);}int main () { int i; for (gi (n), i = 1; i &lt;= n; i ++) gi (a[i]), id[i] = i, dp[i] = 0; std :: sort (id + 1, id + n + 1, [&amp;] (const int &amp;x, const int &amp;y) { return a[x] == a[y] ? x &lt; y : a[x] &lt; a[y]; }); for (i = 1; i &lt;= n; i ++) rid[id[i]] = i; ;mergesort (1, n, 0); solve (1, n, 0); for (ret = -(ll)n * (n + 1) / 2, i = 1; i &lt;= n; i ++) ret = std :: max (ret, dp[i] + (ll)i * (i + 1) / 2 - (ll)(n - i) * (n - i + 1) / 2); printf (\"%lld\\n\", ret); return 0;}","link":"/2019/07/20/胡闹-序列/"},{"title":"胡闹 一路畅通","text":"题目大意给你一个$n\\le10^5$个点，$m\\le2\\times10^5$的无向图，每条边有一个权值$a_i&lt;2^{31}$。 求一条从$S$点走到$T$的路径，这条路径上的边权最大值除以边权最小值应该全局最小，输出这个值。 解析考虑先枚举一个上界，然后我们要让联通的下界尽量大。 怎么枚举上界呢？可以考虑把所有的边都按边权从大到小排序，然后类似$Kruskal$的方法来做。 如果新加入一条边，这条边两边是不联通的，那它显然是要保留的。 然后如果这条边两边是联通的，那么我们就应该把这个联通块中边权最小的边删掉，换成着一条边。 可以发现，这个联通块一定是一棵树。 现在我们要做的事情变成了： 维护一个森林 加边 删边 查询最小值 这个用一个$LCT$就可以维护好了。 答案怎么计算？非常简单，处理每一条边的时候都康康看看$S,T$是否联通，联通的话就就查询一下最小值就行了，这个直接用$Kruskal$里面的并查集就可以维护了。 注意一点，边权非常大，$inf$不能开太大！ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#define REP(i, s, e) for (int i = s; i &lt;= e; i++)#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;const int maxn = 100000 + 10, maxm = 200000 + 10, maxN = maxn + maxm;struct Edge{ int x, y, z;}E[maxN];bool cmp(Edge A, Edge B) {return A.z &gt; B.z;}int n, m, S, T;int f[maxN];int find(int x) {return f[x] == x ? f[x] : f[x] = find(f[x]);}void uni(int x, int y) {f[find(x)] = find(y);}int fa[maxN], ch[maxN][2], s[maxN];bool tag[maxN];#define ls(p) ch[p][0]#define rs(p) ch[p][1]#define get(x) (rs(fa[x]) == x)#define notroot(x) (ls(fa[x]) == x || rs(fa[x]) == x)void pushup(int x){ s[x] = x;s[0] = 0; if (E[s[x]].z &lt; E[s[ls(x)]].z) s[x] = s[ls(x)]; if (E[s[x]].z &lt; E[s[rs(x)]].z) s[x] = s[rs(x)];}void rotate(int x){ int y = fa[x], z = fa[y]; bool k = get(x); if (ch[x][k ^ 1]) fa[ch[x][k ^ 1]] = y; ch[y][k] = ch[x][k ^ 1]; if (notroot(y)) ch[z][get(y)] = x; fa[fa[y] = x] = z; ch[x][k ^ 1] = y; pushup(y);pushup(x);}void pushdown(int x){ if (!tag[x]) return; swap(ls(x), rs(x)); tag[ls(x)] ^= 1;tag[rs(x)] ^= 1; tag[x] = 0;}void pushall(int x){ if (notroot(x)) pushall(fa[x]); pushdown(x);}void splay(int x){ pushall(x); while (notroot(x)) { int y = fa[x]; if (notroot(y)) rotate(get(x) == get(y) ? y : x); rotate(x); }}void access(int x){ for (int t = 0; x; x = fa[t = x]) { splay(x); rs(x) = t; pushup(x); }}void makeroot(int x){ access(x); splay(x); tag[x] ^= 1;}void link(int x, int y){ makeroot(x); fa[x] = y;}void cut(int x, int y){ makeroot(x); access(y); splay(y); fa[x] = ls(y) = 0;}int query(int u, int v){ makeroot(u); access(v); splay(v); return s[v];}long long ansu = 1 &lt;&lt; 30, ansv = 1;int main(){#ifndef ONLINE_JUDGE freopen(\"B.in\", \"r\", stdin); freopen(\"B.out\", \"w\", stdout);#endif cin &gt;&gt; n &gt;&gt; m; REP(i, n + 1, n + m) scanf(\"%d%d%d\", &amp;E[i].x, &amp;E[i].y, &amp;E[i].z); cin &gt;&gt; S &gt;&gt; T; sort(E + n + 1, E + 1 + n + m, cmp); REP(i, 1, n) f[i] = i; REP(i, n + 1, n + m) { if (find(E[i].x) ^ find(E[i].y)) { uni(E[i].x, E[i].y); link(E[i].x, i); link(E[i].y, i); } else { int pos = query(E[i].x, E[i].y); if (E[pos].z &lt;= E[i].z) continue; cut(E[pos].x, pos); cut(E[pos].y, pos); link(E[i].x, i); link(E[i].y, i); } if (find(S) == find(T)) { int v = E[query(S, T)].z; if (ansu * E[i].z &gt;= ansv * v) ansu = v, ansv = E[i].z; } } if (ansu % ansv == 0) printf(\"%lld\\n\", ansu / ansv); else printf(\"%lld/%lld\\n\", ansu / __gcd(ansu, ansv), ansv / __gcd(ansu, ansv)); return 0;}","link":"/2019/07/19/胡闹-一路畅通/"},{"title":"胡闹 卷积练习题","text":"题目大意给定两个长度为$n$的非负整数数组$a,b$，求$$\\sum_{i=1}^n\\sum_{j=1}^n\\lfloor\\sqrt{|a_i-b_j|}\\rfloor$$ Notes$1\\le n\\le 10^6$，$0\\le a_i,b_i\\le 3\\times 10^6$，$\\sum a_i,\\sum b_i\\le 10^7$ 解析这个题目啊，interesting。 本来题目名字叫做“卷积练习题”，但是正解和卷积一点关系都没有。 一个套路，我们注意到$0\\le a_i$并且$\\sum a_i\\le10^7$，那么我们知道$a_i$的取值一定是$O(\\sqrt{10^7})$的？ 为什么呢？考虑抽屉原理。从$0$开始，放$1,2,3,4…$，那么放了$n$个的时候，必然有$\\sum a_i\\ge\\frac{n\\times(n-1)}{2}$。 所以$a_i$取值一定是$O(\\sqrt{10^7})$的。 我们又注意到，$\\lfloor\\sqrt{|a_i-b_j|}\\rfloor\\le \\sqrt{10^7}​$。 那么就很简单了，枚举$a$中每一个出现的数，然后枚举$\\lfloor\\sqrt{|a_i-b_j|}\\rfloor$，$b$中合法的数一定是在两个区间内，统计的话直接及一个前缀和就好了。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#define REP(i, s, e) for (int i = s; i &lt;= e ;i++)#define chkmax(a, b) a = max(a, b)#define chkmin(a, b) a = min(a, b)#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#define double long double#define int long longusing namespace std;const int maxn = 1e6 + 10, maxL = 4200000;int n, ans, a[maxn], b[maxn], cnt[3000005];int s[3000005];signed main(){#ifndef ONLINE_JUDGE freopen(\"A.in\", \"r\", stdin); freopen(\"A.out\", \"w\", stdout);#endif cin &gt;&gt; n; REP(i, 1, n) scanf(\"%lld\", a + i), a[i]++; REP(i, 1, n) scanf(\"%lld\", b + i), b[i]++; if (n &lt;= 2000) { REP(i, 1, n) REP(j, 1, n) ans += floor(sqrt(abs(a[i] - b[j]))); } else { REP(i, 1, n) cnt[a[i]]++; REP(i, 1, n) s[b[i]]++; REP(i,1,3000001)s[i]+=s[i-1]; REP(A, 1, 3000001) if (cnt[A]) REP(C, 1, 1732) { int l, r; l = A - C * C - C * 2, r = A - C * C; if (max(l, 1ll) &lt;= min(r, 3000001ll)) { chkmax(l, 1ll);chkmin(l, 3000001ll); chkmax(r, 1ll);chkmin(r, 3000001ll); ans += C * cnt[A] * (s[r] - s[l-1]); } l = A + C * C, r = A + C * C + C * 2; if (max(l, 1ll) &lt;= min(r, 3000001ll)) { chkmax(l, 1ll);chkmin(l, 3000001ll); chkmax(r, 1ll);chkmin(r, 3000001ll); ans += C * cnt[A] * (s[r] - s[l-1]); } } } cout &lt;&lt; ans &lt;&lt; endl; return 0;}","link":"/2019/07/19/胡闹-卷积练习题/"},{"title":"胡闹 斐波那契","text":"题目大意求$$\\sum_{i=1}^n\\sum_{j=1}^mgcd(Fib_i,Fib_j)$$ 有人提出了神奇的解法。 注意到一个式子：$$Fib_a\\times Fib_b+Fib_{a+1}\\times Fib_{b+1}=Fib_{a+b+1}$$那么我们就有一个非常interesting的结论了：$$\\begin{align*}gcd(Fib_i,Fib_j)&amp;=gcd(Fib_j\\times Fib_{i-j+1}+Fib_{j-1}\\times Fib_{i-j},Fib_j)\\\\&amp;=gcd(Fib_{i-1}\\times Fib_{j-1},Fib_j)\\\\&amp;=Fib_{gcd(i,j)}\\end{align*}$$ 然后怎么利用莫比乌斯反演呢？ 记$f(k)​$为$gcd(i,j)=k​$的$(i,j)​$的对数，$g(k)​$表示$k|gcd(i,j)​$的$i,j​$对数。 然后推式子：$$\\begin{align*}Ans&amp;=\\sum_{k=1}^n f(k)\\times Fib_k\\\\&amp;=\\sum_{k=1}^n Fib_k\\times \\sum_{k’|d}\\mu(\\frac{d}{k’})\\times g(d)\\\\&amp;=\\sum_{k=1}^n Fib_k\\times \\sum_{k’|d}\\mu(\\frac{d}{k’})\\times \\lfloor\\frac{n}{d}\\rfloor\\lfloor\\frac{m}{d}\\rfloor\\end{align*}$$然后上板子吧。 latex挂了大家自求多福吧 Code1234567891011121314151617181920212223242526272829303132333435363738394041#define REP(i, s, e) for (register int i = s; i &lt;= e ;i++)#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2e6 + 10, MOD = 1e9 + 7;int m, n, k;bitset &lt;maxn&gt; notprime;int p[maxn], x[maxn], p_cnt;int fib[maxn], u[maxn], ans;inline int mod(int x) {return x &gt;= MOD ? x - MOD : x;}int main(){#ifndef ONLINE_JUDGE freopen(\"B.in\", \"r\", stdin); freopen(\"B.out\", \"w\", stdout);#endif cin &gt;&gt; n &gt;&gt; m; REP(i, 2, n) { if (!notprime[i]) x[p[++p_cnt] = i] = i; REP(j, 1, p_cnt) { if (i * p[j] &gt; n) break; notprime[i * p[j]] = 1; x[i * p[j]] = p[j]; if (i % p[j] == 0) break; } } fib[1] = 1; REP(i, 2, n) fib[i] = mod(fib[i-1] + fib[i-2]); u[1] = 1; REP(i, 2, n) if (x[i] ^ x[i / x[i]]) u[i] = -u[i / x[i]]; REP(i, 1, n) for (register int j = 1; i * j &lt;= n; j++) ans += 1ll * u[j] * (n / i / j) * (m / i / j) % MOD * fib[i] % MOD, ans %= MOD; cout &lt;&lt; (ans + MOD) % MOD &lt;&lt; endl; return 0;}","link":"/2019/07/19/胡闹-斐波那契/"},{"title":"胡闹 最小质因数","text":"题目大意求$[1,n]$中所有合数的最小质因数的$k$次方和，对$2^{64}$取模。 解析学习了学习了，这好像是一个经典套路吧。 就是说我们其实对于每一个素数$p$，只需要管$[1,\\frac{n}{p}]$这个区间。 那我们就可以考虑把所有的质数分成两部分。 小的部分直接暴力容斥（可以记忆化一下，具体用$unordered\\_map$当哈希表）。 大的部分$\\frac{n}{p}$就比较小了，可以直接筛一下。 $pb\\_ds​$的$gp\\_hash\\_table​$好像是假的？ Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#define REP(i, s, e) for (int i = s; i &lt;= e ;i++)#include &lt;bits/stdc++.h&gt;#define ll long long#define ull unsigned llusing namespace std;const ll K = 170;ull power_pow(ull a, int b){ ull ans = 1, base = a; while (b) { if (b &amp; 1) ans *= base; base *= base; b &gt;&gt;= 1; } return ans;}ll p[38000], p_cnt;bitset &lt;450000&gt; notprime;void init(int N){ REP(i, 2, N) { if (!notprime[i]) p[++p_cnt] = i; REP(j, 1, p_cnt) { if (i * p[j] &gt; N) break; notprime[i * p[j]] = 1; if (i % p[j] == 0) break; } }}ll n, k;ull ans;unordered_map &lt;ll, ll&gt; rem;#define not_same_pos(x, y) ((x) * n + y)//make sure no 冲突ll dfs(int pos, ll cur, int flag){ if (rem[not_same_pos(pos, cur)]) return rem[not_same_pos(pos, cur)] * flag; if (!pos) return cur * flag; ll ret = dfs(pos-1, cur, flag); if (p[pos] &lt;= cur) ret += dfs(pos-1, cur / p[pos], -flag); rem[not_same_pos(pos, cur)] = ret * flag; return ret;}ll cnt, N;bitset &lt;200000000&gt; w;signed main(){#ifndef ONLINE_JUDGE freopen(\"A.in\", \"r\", stdin); freopen(\"A.out\", \"w\", stdout);#endif cin &gt;&gt; n &gt;&gt; k; init(sqrt(n) + 1); REP(i, 1, min(p_cnt, K)) ans += (dfs(i - 1, n / p[i], 1)-1) * power_pow(p[i], k); if (p_cnt &gt; K) { cnt = N = n / p[K+1]; REP(i, 1, K) for (int j = 1; p[i] * j &lt;= N; j++) if (!w[p[i] * j]) { w[p[i] * j] = 1; cnt--; } REP(i, K + 1, p_cnt) { ans += (cnt-1) * power_pow(p[i], k); if (i &lt; p_cnt) { N = n / p[i+1]; for (int j = n / p[i]; j &gt; N; j--) cnt -= !w[j]; for (int j = 1; p[i] * j &lt;= N; j++) if (!w[p[i] * j]) { w[p[i] * j] = 1; cnt--; } } } } cout &lt;&lt; ans &lt;&lt; endl; return 0;}","link":"/2019/07/18/胡闹-最小质因数/"},{"title":"胡闹 文本编辑器","text":"题目大意你要支持以下几种操作： $I$ $x$ $a$ : 在第$x$个字符后面插入字符$a$ $D$ $x$ $y$：删除从$x$到$y$的这一段 $C$ $x$ $y$ $z$ ：复制从$x$到$y$这一段，粘贴到第$z$个字符后面 $P$ $x$ $y$ $z$ ：打印$x$次修改操作之前，从$y$到$z$这一段。其中，$x$不超过一个给定的数$M$。 保证输入的所有数在$int$范围内。 数据规模与约定对于$40%$的数据，总操作数和任意时刻字符串的长度在$1000$以内。 对于$100%$的数据，字符串的内容仅包含大小写字母和数字，初始字符串的长度和操作数不超过$100000$ ，$M\\le 1000$ 。 解析就是说用一个$fhq​$来维护 然后可持久化一下，就是$split​$的时候新建结点。 有以下卡常技巧： 按秩合并（玄学） $inline，register​$ 输出的时候不中序遍历，一个一个往下找（玄学） 少传址 用返回$int$的$merge$而不用传址的$merge$ srand(咕咕咕) Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#define REP(i, s, e) for (int i = s; i &lt;= e ;i++)#include &lt;bits/stdc++.h&gt;using namespace std;const int maxnode = 8e7 + 10;struct node{ int l, r, s; char c;}t[maxnode];int cur;inline int newnode(char c){ ++cur; t[cur].l = t[cur].r = 0; t[cur].c = c;t[cur].s = 1; return cur;}inline int copy(int x){ t[++cur] = t[x]; return cur;}inline void pushup(int x) {t[x].s = t[t[x].l].s + t[t[x].r].s + 1;}inline void split(int x, int &amp;a, int &amp;b, int siz){ if (!x) a = b = 0; else if (t[t[x].l].s &gt;= siz) { b = copy(x); split(t[b].l, a, t[b].l, siz); pushup(b); } else { a = copy(x); split(t[a].r, t[a].r, b, siz - t[t[x].l].s - 1); pushup(a); }}inline int merge(int a, int b){ if (!a || !b) return a ^ b; register int z; if (t[a].s &lt; t[b].s) z = b, t[z].l = merge(a, t[z].l); else z = a, t[z].r = merge(t[z].r, b); pushup(z); return z;}int rt[100000 + 10], now;int n, m;char c;inline int read(){ c = getchar(); while (!isdigit(c)) c = getchar(); int ans(0); while (isdigit(c)) ans = (ans &lt;&lt; 1) + (ans &lt;&lt; 3) + (c &amp; 15), c = getchar(); return ans;}inline void output(int _){ if (!_) return; output(t[_].l); putchar(t[_].c); output(t[_].r);}char ssr[10], s[100000 + 10];inline int build(int l, int r){ if (l &gt; r) return 0; int mid = l + r &gt;&gt; 1; int p = newnode(s[mid]); t[p].l = build(l, mid - 1); t[p].r = build(mid + 1, r); pushup(p); return p;}inline char query(int p, int k){ while (1) { if (t[t[p].l].s + 1 == k) return t[p].c; if (t[t[p].l].s + 1 &lt; k) k -= t[t[p].l].s + 1, p = t[p].r; else p = t[p].l; }}int pos, l, r, ccc, x, y, z;int main(){#ifndef ONLINE_JUDGE freopen(\"B.in\", \"r\", stdin); freopen(\"B.out\", \"w\", stdout);#endif t[0] = (node){0,0,0,'\\0'}; read(); scanf(\"%s\", s + 1); rt[0] = build(1, strlen(s + 1)); while (scanf(\"%s\", ssr) != EOF) if (ssr[0] == 'I') { pos = read(); scanf(\"%s\", ssr); ++now; x = y = 0; split(rt[now-1], x, y, pos); rt[now] = merge(merge(x, newnode(ssr[0])), y); } else if (ssr[0] == 'D') { l = read(), r = read(); ++now; x = y = z = 0; split(rt[now-1], x, y, l - 1); split(y, y, z, r - l + 1); rt[now] = merge(x, z); } else if (ssr[0] == 'C') { l = read(), r = read(), pos = read(); ++now; x = y = z = 0; split(rt[now-1], x, y, l - 1); split(y, y, z, r - l + 1); split(rt[now-1], x, z, pos); rt[now] = merge(merge(x, y), z); } else { ccc = read(), l = read(), r = read(); REP(i, l, r) putchar(query(rt[now-ccc], i)); putchar(10); } return 0;}","link":"/2019/07/17/胡闹-文本编辑器/"},{"title":"胡闹 多重集合问题","text":"题目大意维护一颗树，兹磁以下操作： 向以$v$为根的子树的所有节点各插入$k$个数$z$（相当于每个节点存了一些数） 询问某个节点$v$中有多少个数$x\\ xor\\ y\\le z$，其中$y,z$是给出的 把整棵树的根换成某一个节点$v$ $n,m\\le 140000$ 解析首先考虑查询假设我们现在有一些数，然后查询有多少个异或上$y$不大于$z$ 我们考虑把这些数建一个二进制的$Trie$。 考虑$z$的最高位，如果是$1$，那么就可以把$0$的$cnt$全部加进贡献。 如果是$0$，只能走到$0$。 这样每一位算一下就行。 接着考虑插入对于一个子树的话，就用树链剖分的方法存$dfn$，然后映射出来就是一段区间。 这样的话直接$Trie$和线段树套一下就可以了。 最后考虑换根换根的话，影响的只是子树的区间。 判一下根在不在区间内就可以了。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191#define REP(i, s, e) for (int i = s ; i &lt;= e; i++)#define DREP(i, s, e) for (int i = s ; i &gt;= e; i--)#define DEBUG fprintf(stderr, \"Passing [%s] in Line %d\\n\", __FUNCTION__, __LINE__)#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int maxn = 140000 + 10, maxm = 140000 + 10;int now = 1, root;int bg[maxn], ne[maxn &lt;&lt; 1], to[maxn &lt;&lt; 1], e = 1;void add(int x, int y){ e++; to[e] = y; ne[e] = bg[x]; bg[x] = e;}int fa[maxn], top[maxn], siz[maxn], depth[maxn], hvy[maxn];int dfn[maxn], bac[maxn], dfs_clock;void dfs1(int x){ siz[x] = 1; for (int i = bg[x]; i ; i = ne[i]) if (to[i] ^ fa[x]) { fa[to[i]] = x; depth[to[i]] = depth[x] + 1; dfs1(to[i]); siz[x] += siz[to[i]]; if (siz[to[i]] &gt; siz[hvy[x]]) hvy[x] = to[i]; }}void dfs2(int x, int y){ top[x] = y; dfn[x] = ++dfs_clock; if (hvy[x]) dfs2(hvy[x], y); for (int i = bg[x]; i ; i = ne[i]) if (to[i] ^ hvy[x] &amp;&amp; to[i] ^ fa[x]) dfs2(to[i], to[i]); bac[x] = dfs_clock;}int find(int x, int y){ while (1) { if (top[x] == top[y]) return hvy[y]; if (fa[top[x]] == y) return top[x]; x = fa[top[x]]; }}struct node{ int cnt; node *ls, *rs;}pool[55555555], *null, *node_cur = pool;node* newnode(){ node_cur -&gt; ls = node_cur -&gt; rs = null; return node_cur++;}#define mid (l + r &gt;&gt; 1)#define lson p -&gt; ls, l, mid#define rson p -&gt; rs, mid + 1, rvoid update(node *&amp;p, int l, int r, int pos, int val){ if (p == null) p = newnode(); p -&gt; cnt += val; if (l == r) return; if (pos &lt;= mid) update(lson, pos, val); else update(rson, pos, val);}int query(node *p, int l, int r, int pos){ if (p == null) return 0; if (l == r) return p -&gt; cnt; if (pos &gt; mid) return p -&gt; ls -&gt; cnt + query(rson, pos); else return query(lson, pos);}struct Trie{ node *t; Trie *ch[2];}t[4444444], *pt = t + 1;int ans[maxm];struct Query{ int id, y, z, ne; Query(){} Query(int _id, int _y, int _z, int _ne) : id(_id), y(_y), z(_z), ne(_ne) {} void query() { Trie* p = t; DREP(i, 29, 0) { if (z &gt;&gt; i &amp; 1) if (p -&gt; ch[((z^y)&gt;&gt;i&amp;1) ^ 1]) ans[id] += ::query(p -&gt; ch[((z^y)&gt;&gt;i&amp;1) ^ 1] -&gt; t, 1, now, id); p = p -&gt; ch[(z^y)&gt;&gt;i&amp;1]; if (!p) return; } ans[id] += ::query(p -&gt; t, 1, now, id); }}q[288888];int pq = 144444;void insert(int v, int id, int y, int z){ q[pq] = Query(id, y, z, q[v].ne); q[v].ne = pq++;}struct opt{ int t, k, x, v; opt(){} opt(int _t, int _k, int _x, int _v) : t(_t), k(_k), x(_x), v(_v) {} void modify() { Trie* p = ::t; DREP(l, 29, 0) { if (!p -&gt; ch[x &gt;&gt; l &amp; 1]) pt -&gt; t = newnode(), p -&gt; ch[x &gt;&gt; l &amp; 1] = pt++; p = p -&gt; ch[x &gt;&gt; l &amp; 1]; update(p -&gt; t, 1, now, t, k); } } bool operator &lt; (opt B) const {return v &lt; B.v;}}op[433333];int qcnt, Cur = 1;int m, n;signed main(){#ifndef ONLINE_JUDGE freopen(\"B.in\", \"r\", stdin); freopen(\"B.out\", \"w\", stdout);#endif cin &gt;&gt; n; REP(i, 2, n) { int x, y; scanf(\"%lld%lld\", &amp;x, &amp;y); add(x, y);add(y, x); } dfs1(1); dfs2(1, 1); null = pool + 55555500; t -&gt; t = newnode(); cin &gt;&gt; m; REP(i, 1, m) { int Opt;scanf(\"%lld\", &amp;Opt); if (Opt == 1) { int v, x, k; scanf(\"%lld%lld%lld\", &amp;v, &amp;x, &amp;k); if (dfn[v] &gt;= dfn[root] || dfn[root] &gt; bac[v]) if (v == root) op[++qcnt] = opt(now, k, x, 1); else { op[++qcnt] = opt(now, k, x, dfn[v]); op[++qcnt] = opt(now, -k, x, bac[v] + 1); } else { int temp = find(root, v); op[++qcnt] = opt(now, k, x, 1); op[++qcnt] = opt(now, -k, x, dfn[temp]); op[++qcnt] = opt(now, k, x, bac[temp] + 1); } } else if (Opt == 2) { int v, y, z; scanf(\"%lld%lld%lld\", &amp;v, &amp;y, &amp;z); insert(dfn[v], now++, y, z); } else scanf(\"%lld\", &amp;root); } sort(op + 1, op + qcnt + 1); REP(i, 1, n) { while (op[Cur].v == i) op[Cur++].modify(); for (int p = q[i].ne; p ; p = q[p].ne) q[p].query(); } REP(i, 1, now - 1) printf(\"%lld\\n\", ans[i]); return 0;}","link":"/2019/07/16/胡闹-多重集合问题/"},{"title":"模板 三维偏序","text":"传送门 题目大意空间内有$n$个点$(x_i,y_i,z_i)$。定义$f(i)=\\sum_{j=1}^n [x_j\\le x_i, y_j\\le x_j, z_j\\le z_i, i \\not=j]$。求$f(i),i\\in[0,n)$。 解法首先可以把所有的点按第一维排序。然后对于第二维，对与所有第二维大于等于这个点的位置记录存在一个这个点的第三维。然后就可以简单地用平衡树统计第三维得出答案了。第二维的话就可以简单的用一下树状数组搞一搞。 由于题目中可以大于等于，那么我们把所有第一维相同的全部记录完再算它们的答案。具体看代码喽。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#define DREP(i, s, e) for(int i = s; i &gt;= e ;i--)#define REP(i, s, e) for(int i = s; i &lt;= e ;i++)#define DEBUG fprintf(stderr, \"Passing [%s] in Line %d\\n\", __FUNCTION__, __LINE__)#define chkmax(a, b) a = max(a, b)#define chkmin(a, b) a = min(a, b)#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1000000 + 10, maxk = 2000000;template &lt;typename T&gt; inline T read(){ T ans(0), p(1); char c = getchar(); while (!isdigit(c)) { if (c == '-') p = -1; c = getchar(); } while (isdigit(c)) { ans = ans * 10 + c - 48; c = getchar(); } return ans * p;}int n, k;struct flower{ int s, c, m, id; flower(){} flower(int _s, int _c, int _m, int _id) : s(_s), c(_c), m(_m), id(_id){}}f[maxn];bool cmp(flower A, flower B) {return A.s &lt; B.s;}vector &lt;int&gt; s[maxn];void update(int c, int m){ while (c &lt;= k) { s[c].insert(lower_bound(s[c].begin(), s[c].end(), m), m); c += c &amp; -c; } // REP(i, c, cmax)s[i].insert(lower_bound(s[i].begin(), s[i].end(), m), m);}int ans[maxn];int query(int c, int m){ int res = 0; while (c &gt; 0) { res += lower_bound(s[c].begin(), s[c].end(), m+1) - s[c].begin(); c -= c &amp; -c; } return res-1;}int cnt[maxn];int main(){#ifdef CraZYali freopen(\"B.in\", \"r\", stdin); freopen(\"B.out\", \"w\", stdout); freopen(\"B.err\", \"w\", stderr);#endif cin &gt;&gt; n &gt;&gt; k; REP(i, 1, n) { int s(read&lt;int&gt;()), c(read&lt;int&gt;()), m(read&lt;int&gt;()); f[i] = flower(s, c, m, i); } sort(f + 1, f + 1 + n, cmp); // REP(i, 1, n) printf(\"%d %d %d %d\\n\", f[i].s, f[i].c, f[i].m, f[i].id); int last = 1; REP(i, 1, n) { if (i &gt; 1 &amp;&amp; f[i].s ^ f[i-1].s) { REP(j, last, i-1) cnt[ans[f[j].id] = query(f[j].c, f[j].m)]++;//, puts(\"----\"), cerr &lt;&lt; f[i].id &lt;&lt; ' ' &lt;&lt; ans[f[i].id] &lt;&lt; endl; last = i; } update(f[i].c, f[i].m); } REP(i, last, n) cnt[ans[f[i].id] = query(f[i].c, f[i].m)]++;//, puts(\"----\"), cerr &lt;&lt; f[i].id &lt;&lt; ' ' &lt;&lt; ans[f[i].id] &lt;&lt; endl; REP(i, 0, n-1) printf(\"%d\\n\", cnt[i]); // REP(i, 1, n) fprintf(stderr, \"%d\\n\", ans[i]); return 0;}","link":"/2019/07/07/模板-三维偏序/"},{"title":"Luogu 2042 [NOI2005 维护数列]","text":"传送门工业题，爽歪歪。 题目大意 解法维护一下区间和$sum$，从左端点开始的最大子段和$lmax$，以右端点结束的最大子段和$rmax$。$pushup$可能挺简单的。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240#define REP(i, s, e) for (int i = s; i &lt;= e; i++)#define DREP(i, s, e) for (int i = s; i &gt;= e; i--)#define DEBUG fprintf(stderr, \"Passing [%s] in Line %lld\\n\", __FUNCTION__, __LINE__)#define chkmax(a, b) a = max(a, (b))#define chkmin(a, b) a = min(a, (b))#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int maxn = 500000 + 10, inf = 1ll&lt;&lt;40;template &lt;typename T&gt; T read(){ T ans(0), flag(1); char c(getchar()); while (!isdigit(c)) { if (c == '-') flag = -1; c = getchar(); } while (isdigit(c)) { ans = ans * 10 + c - 48; c = getchar(); } return ans * flag;}void file(string s){ freopen((s + \".in\").c_str(), \"r\", stdin); freopen((s + \".out\").c_str(), \"w\", stdout); freopen((s + \".err\").c_str(), \"w\", stderr);}struct node{ int l, r, s, order, val, sum, lmax, rmax, max_sum, tag_reverse, tag_same; bool need; node() : l(0), r(0), s(0), order(0), val(0), sum(0), lmax(0), rmax(0), max_sum(0), tag_reverse(0), tag_same(0), need(0) {} node(int _val) : l(0), r(0), s(1), order(rand()), val(_val), sum(_val), lmax(_val), rmax(_val), max_sum(_val), tag_reverse(0), need(0){};}t[maxn];int s[maxn], top, root;int create(int val){ int id = s[top--]; t[id] = node(val); return id;}void recycle(int x) {s[++top] = x;}#define max3(x, y, z) max(max(x, y), z)void same(int x, int v){ if (!x) return; t[x].tag_same = v; t[x].need = 1; t[x].val = v; t[x].sum = v * t[x].s; if (v &gt;= 0) t[x].lmax = t[x].rmax = t[x].max_sum = t[x].sum; else t[x].lmax = t[x].rmax = t[x].max_sum = v;}void pushdown(int x){ if (!x) return; t[0].lmax=t[0].rmax=t[0].max_sum=-1e9; int &amp;l(t[x].l), &amp;r(t[x].r); if (t[x].tag_reverse) { t[x].tag_reverse = 0; t[l].tag_reverse ^= 1; t[r].tag_reverse ^= 1; swap(l, r); swap(t[x].lmax, t[x].rmax); } if (t[x].need) { if (l) same(l, t[x].tag_same); if (r) same(r, t[x].tag_same); t[x].need = 0; }}void pushup(int x){ if (!x) return; int l = t[x].l, r = t[x].r; if(l) pushdown(l); if(r) pushdown(r); t[x].s = t[l].s + t[r].s + 1; t[x].sum = t[l].sum + t[r].sum + t[x].val; t[x].lmax = max(t[l].lmax, t[l].sum + max(t[r].lmax, 0ll) + t[x].val); t[x].rmax = max(t[r].rmax, t[r].sum + max(t[l].rmax, 0ll) + t[x].val); t[x].max_sum = max3( t[l].max_sum, t[r].max_sum, max(t[l].rmax, 0ll) + t[x].val + max(t[r].lmax, 0ll));}void merge(int &amp;x, int a, int b){ if (!a || !b) x = a + b; else { if (t[a].order &gt; t[b].order) { pushdown(b); merge(t[x = b].l, a, t[b].l); } else { pushdown(a); merge(t[x = a].r, t[a].r, b); } pushup(x); }}void split(int x, int &amp;a, int &amp;b, int siz){ if (!x) a = b = 0; else { pushdown(x); if (t[t[x].l].s &gt;= siz) split(t[b = x].l, a, t[x].l, siz); else split(t[a = x].r, t[x].r, b, siz - t[t[x].l].s - 1); pushup(x); }}int GET(int pos){ int x(0), y(0), z(0); split(root, x, y, pos - 1); split(y, y, z, 1); int ans = t[y].val; merge(y, y, z); merge(root, x, y); return ans;}void INSERT(int pos, int a[], int len){ int x(0), y(0); split(root, x, y, pos); REP(i, 1, len) merge(x, x, create(a[i])); merge(root, x, y);}void del(int y){ if (!y) return; del(t[y].l); del(t[y].r); recycle(y);}void DELETE(int pos, int tot){ int x(0), y(0), z(0); split(root, x, y, pos - 1); split(y, y, z, tot); merge(root, x, z); del(y);}void MAKE_SAME(int pos, int tot, int c){ int x(0), y(0), z(0); split(root, x, y, pos - 1); split(y, y, z, tot); same(y, c); merge(y, y, z); merge(root, x, y);}void REVERSE(int pos, int tot){ int x(0), y(0), z(0); split(root, x, y, pos - 1); split(y, y, z, tot); t[y].tag_reverse ^= 1; merge(y, y, z); merge(root, x, y);}int GET_SUM(int pos, int tot){ int x(0), y(0), z(0); split(root, x, y, pos - 1); split(y, y, z, tot); int ans = t[y].sum; merge(y, y, z); merge(root, x, y); return ans;}void PUSH_BACK(int val){ int z(create(val)); merge(root, root, z);}int m, n, a[maxn];char ss[20];signed main(){#ifdef CraZYali file(\"2042\");#endif srand((unsigned long long)new char); top = 500000; REP(i, 1, top) s[i] = i; cin &gt;&gt; n &gt;&gt; m; REP(i, 1, n) PUSH_BACK(read&lt;int&gt;()); while (m--) { scanf(\"%s\", ss + 1); if (ss[1] == 'I') { int pos(read&lt;int&gt;()), tot(read&lt;int&gt;()); REP(i, 1, tot) a[i] = read&lt;int&gt;(); INSERT(pos, a, tot); n += tot; } else if (ss[1] == 'D') { int pos(read&lt;int&gt;()), tot(read&lt;int&gt;()); DELETE(pos, tot); n -= tot; } else if (ss[1] == 'M' &amp;&amp; ss[3] == 'K') { int pos(read&lt;int&gt;()), tot(read&lt;int&gt;()); MAKE_SAME(pos, tot, read&lt;int&gt;()); } else if (ss[1] == 'R') { int pos(read&lt;int&gt;()), tot(read&lt;int&gt;()); REVERSE(pos, tot); } else if (ss[1] == 'G') { int pos(read&lt;int&gt;()), tot(read&lt;int&gt;()); printf(\"%lld\\n\", GET_SUM(pos, tot)); } else printf(\"%lld\\n\", t[root].max_sum); // REP(i, 1, n) GET(i); } return 0;}","link":"/2019/07/07/Luogu-2042-NOI2005-维护数列/"},{"title":"Luogu 4197 [ONTAK2010 Peaks]","text":"传送门垃圾BZOJ，又过不了我的大常数。 题目大意给你一个$N\\le 10^5$个点$M\\le 5\\times 10^5$条边的无向图，每条边有边权，每个点有点权。每次给你一组$v,x,k$，询问从$v$开始经过不超过$x$的路可以走到的所有点中的第$k$大。无解输出$-1$。 解析显然这个东西是在最小生成树上跑。这个不超过$x$的东西有一类方法。这个东西叫做Kruskal重构树。 Kruskal重构树我们考虑把边改成点。还是Kruskal求最小生成树的过程，但是我们“不加边”。方便表达，下面说的都是代表了联通块的节点。具体来说，假设我们现在要吧$u,v$之间权值为$w$的边弄到最小生成树中去。那么我们就new一个$fa$，让这个$fa$的权值为$w$，然后这个$fa$向$u,v$连边。容易发现，这样我们就会new出一颗新树来，这棵树就是Kruskal重构树。 那么这棵树有两个非常好的性质： 原生成树的节点都是叶子节点（显然） 非叶子节点的权值一定不超过其父亲的权值（按Kruskal的顺序加边，自然后来的边权值不小于先来的边）所以说，从一个点出发，只要找到它的权值不超过$x$最老祖先，然后以它为根的子树的所有叶子节点就都可以到了。 这题要求$kth$，套一个主席树就可以啦。细节稍微注意一下。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169#define REP(i, s, e) for (int i = s; i &lt;= e; i++)#define DREP(i, s, e) for (int i = s; i &gt;= e; i--)#define DEBUG fprintf(stderr, \"Passing [%s] in Line %d\\n\", __FUNCTION__, __LINE__)#define chkmax(a, b) a = max(a, (b))#define chkmin(a, b) a = min(a, (b))#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;queue&gt;using namespace std;const int maxn = 1e5 + 10, maxm = 5e5 + 10, n_log_n = 3600000;int bg[maxn &lt;&lt; 1], to[maxm], ne[maxm], e;inline void add(int x, int y){ e++; to[e] = y; ne[e] = bg[x]; bg[x] = e;}int fa[maxn &lt;&lt; 1];int find(int x) {return fa[x] == x ? fa[x] : fa[x] = find(fa[x]);}void file(string s){ freopen((s + \".in\").c_str(), \"r\", stdin); freopen((s + \".out\").c_str(), \"w\", stdout);}int n, m, q, cur, M;int val[maxn &lt;&lt; 1];struct Edge{ int x, y, z; Edge() {} Edge(int _x, int _y, int _z) : x(_x), y(_y), z(_z) {}}E[maxm];bool cmp(Edge A, Edge B) {return A.z &lt; B.z;}int N, grand[maxn &lt;&lt; 1][25], LOG, Left[maxn &lt;&lt; 1], Right[maxn &lt;&lt; 1];int dfn[maxn], dfs_clock, vv[maxn];void prepare(int x){ if (x &lt;= n) vv[Left[x] = Right[x] = dfn[x] = ++dfs_clock] = val[x]; bool flag = 0; for (int i = bg[x]; i ; i = ne[i]) if (to[i] ^ grand[x][0]) { grand[to[i]][0] = x; prepare(to[i]); if (x &gt; n) if (!flag) {Left[x] = Left[to[i]];Right[x] = Right[to[i]];flag = 1;} else { chkmin(Left[x], Left[to[i]]); chkmax(Right[x], Right[to[i]]); } }}void output(int x){ for (int i = bg[x]; i ; i = ne[i]) if (to[i] ^ grand[x][0]) { printf(\"%d %d\\n\", x, to[i] &lt;= n&amp;&amp;0 ? dfn[to[i]] : to[i]); output(to[i]); }}int a[maxn], b[maxn];int rt[n_log_n], ls[n_log_n], rs[n_log_n], sum[n_log_n], nd_cur;#define mid (l + r &gt;&gt; 1)#define lson ls[p], l, mid#define rson rs[p], mid + 1, rvoid build(int pre, int &amp;p, int l, int r, int pos){ p = ++nd_cur; ls[p] = ls[pre]; rs[p] = rs[pre]; sum[p] = sum[pre] + 1; if (l == r) return; if (pos &lt;= mid) build(ls[pre], lson, pos); else build(rs[pre], rson, pos);}int query(int u, int v, int l, int r, int k){ if (l &gt;= r) return l; int x = sum[ls[v]] - sum[ls[u]]; if (x &lt; k) return query(rs[u], rs[v], mid + 1, r, k - x); else return query(ls[u], ls[v], l, mid, k);}int main(){#ifdef CraZYali file(\"4197\");#endif cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;cur = n; REP(i, 1, n) scanf(\"%d\", val + i); REP(i, 1, n * 2) fa[i] = i; REP(i, 1, m) { int x, y, z; scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;z); E[i] = Edge(x, y, z); } sort(E + 1, E + 1 + m, cmp); int cnt = 0; REP(i, 1, m) { int x(find(E[i].x)), y(find(E[i].y)); if (x ^ y) { val[++cur] = E[i].z; add(cur, x); add(cur, y); fa[x] = fa[y] = cur; if (++cnt == n - 1) break; } } N = n + n - 1; prepare(cur); LOG = log2(N); REP(j, 1, LOG) REP(i, 1, N) grand[i][j] = grand[grand[i][j-1]][j-1]; // REP(i, n+1, N) // printf(\"%d %d %d\\n\", i, Left[i], Right[i]);// output(cur); REP(i, 1, n) a[i] = b[i] = vv[i];// al[dfn[i]]; sort(b + 1, b + 1 + n); M = unique(b + 1, b + 1 + n) - b - 1; REP(i, 1, n) build(rt[i-1], rt[i], 1, M, lower_bound(b + 1, b + 1 + M, a[i]) - b);// REP(i, 1, n) printf(\"%d%c\", dfn[i], i == n ? '\\n' : ' ' );// REP(i, 1, n) printf(\"%d%c\", vv[i], i == n ? '\\n' : ' ' );// REP(i, 1, n) printf(\"%d%c\", a[i], i == n ? '\\n' : ' ' );// REP(i, 1, M) printf(\"%d%c\", b[i], i == M ? '\\n' : ' ' );// REP(i, 1, n) printf(\"%d%c\", lower_bound(b+1,b+1+M,a[i])-b, i == n ? '\\n' : ' ' );// REP(i, 1, n)// REP(j, i, n)// REP(k, 1, j - i + 1)// printf(\"%d %d %d %d\\n\", i, j, k, b[query(T[i-1], T[j], 1, M, k)]); while (q--) { int v, x, k; scanf(\"%d%d%d\", &amp;v, &amp;x, &amp;k);// cout &lt;&lt; v &lt;&lt; \" -&gt; \"; DREP(i, LOG, 0) if (!grand[v][i]) continue; else if (val[grand[v][i]] &lt;= x) v = grand[v][i];// cout &lt;&lt; v &lt;&lt; \"\\n\";// cout &lt;&lt; Left[v] &lt;&lt; ' ' &lt;&lt; Right[v] &lt;&lt; endl; int len = Right[v] - Left[v] + 1; printf(\"%d\\n\", k &gt; len ? - 1 : b[query(rt[Left[v]-1], rt[Right[v]], 1, M, len - k + 1)]); } return 0;}","link":"/2019/07/02/Luogu-4197-ONTAK2010-Peaks/"},{"title":"Luogu 2444 [POI2000 病毒]","text":"传送门这题目很好骗分啊。 题目大意有一些由$0,1$构成的病毒代码，询问存不存在一个无限长的$01$代码不包含病毒代码。 解析建一个AC自动机出来。考虑一个普通的文本串匹配的情况，如果匹配不上的话就不会包含病毒代码。但是文本串是无限长的，那匹配不上就只能是指针在AC自动机上面的一个环上循环。所以我们知道存不存在一个不包含危险结点的环就可以啦。危险结点就是可以匹配上的结点，那么显然所有fail指向危险结点的结点和Trie上有结束标记的结点都是危险结点。这里找环很好找，由于fail只会指向比当前节点深度浅的结点，所以直接一遍dfs就可以了。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#define REP(i, s, e) for (int i = s; i &lt;= e; i++)#define DREP(i, s, e) for (int i = s; i &gt;= e; i--)#define DEBUG fprintf(stderr, \"Passing [%s] in Line %d\\n\", __FUNCTION__, __LINE__)#define chkmax(a, b) a = max(a, b)#define chkmin(a, b) a = min(a, b)#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;const int maxn = 2000 + 10, maxlen = 30000 + 10, sumS = maxlen;int ch[sumS][3], fail[sumS], rt, cur;bool End[sumS];void insert(char s[]){ int now = rt; for (int i = 1; s[i]; i++) now = !ch[now][s[i]] ? ch[now][s[i]] = ++cur : ch[now][s[i]]; End[now] = 1;}int q[sumS], head, tail;void build(){ head = 1; REP(i, 1, 2) if (ch[0][i]) q[++tail] = ch[0][i]; while (head &lt;= tail) { int x = q[head++]; if (End[fail[x]]) End[x] = 1; REP(i, 1, 2) if (ch[x][i]) fail[q[++tail] = ch[x][i]] = ch[fail[x]][i]; else ch[x][i] = ch[fail[x]][i]; }}bool vis[sumS], ins[sumS];void dfs(int x = rt){ if (ins[x]) {puts(\"TAK\");exit(0);} if (vis[x] || End[x]) return; vis[x] = ins[x] = 1; REP(i, 1, 2) if (ch[x][i]) dfs(ch[x][i]); ins[x] = 0;}int n;char s[maxlen];int main(){#ifdef CraZYali freopen(\"2444.in\", \"r\", stdin); freopen(\"2444.out\", \"w\", stdout);#endif cin &gt;&gt; n; while (n--) { scanf(\"%s\", s + 1); for (int i = 1; s[i]; i++) s[i] -= '0'-1; insert(s); } build();#ifdef CraZYali REP(i, 1, cur) printf(\"%d%c\", (int)fail[i], i == cur ? '\\n' : ' '); REP(i, 1, cur) printf(\"%d%c\", (int)End[i], i == cur ? '\\n' : ' ');#endif dfs(); puts(\"NIE\"); return 0;}","link":"/2019/04/02/Luogu-2444/"},{"title":"合集 斜率优化","text":"昨天晚上肝了几道斜率优化的题，这里一起把题解写了吧。 BZOJ 1096题目大意有$n\\le 10^6$个工厂，每个工厂的位置在$x_i$，有$p_i$个存货。可以在工厂处建造仓库，在第$i$个工厂建造仓库的花费是$c_i$。每个工厂的存货不能往编号小的仓库运东西。一个单位货物运送一个单位长度需要一个花费。求最小的总费用。 解析考虑dp。设$s1_i=\\sum_{k\\in[1,i]} p_k$，$s2_i=\\sum_{k\\in[1,i]} p_k\\times x_k$，那么我们可以推出这个方程：$$dp_i=min(dp_j + c_i + \\sum_{k\\in[j+1,i]}(x_i-x_j)\\times p_j)=min(dp_j+c_i-(s2_i-s2_j)+x_i\\times(s1_i-s1_j))$$套路一波，假设$k$比$j$优秀（$k&gt;j$），那么：$$dp_k+c_i-(s2_i-s2_k)+x_i\\times(s1_i-s1_k)&lt;dp_j+c_i-(s2_i-s2_j)+x_i\\times(s1_i-s1_j)$$随便推一下式子，应该就可以发现：$$dp_k-dp_j+s2_k-s2_j&lt;x_i\\times(s1_k-s1_j)$$$$\\frac{dp_k-dp_j+s2_k-s2_j}{s1_k-s1_j}&lt;x_i$$那么斜率就出来了，直接上套路板子就可以了。时间复杂度$O(n)$。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#define DREP(i, s, e) for(int i = s; i &gt;= e ;i--)#define REP(i, s, e) for(int i = s; i &lt;= e ;i++)#define DEBUG fprintf(stderr, \"Passing [%s] in Line %d\\n\", __FUNCTION__, __LINE__)#define chkmax(a, b) a = max(a, b)#define chkmin(a, b) a = min(a, b)#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;#define int long longconst int maxn = 1e6 + 10;template &lt;typename T&gt; inline T read(){ T ans(0), p(1); char c = getchar(); while (!isdigit(c)) { if (c == '-') p = -1; c = getchar(); } while (isdigit(c)) { ans = ans * 10 + c - 48; c = getchar(); } return ans * p;}int n, x[maxn], p[maxn], c[maxn], dp[maxn], s1[maxn], s2[maxn];int q[maxn], head, tail;double K(int k, int j) {return (s2[j] - s2[k] + dp[j] - dp[k]) * 1. / (s1[j] - s1[k]);}signed main(){#ifdef CraZYali freopen(\"1096.in\", \"r\", stdin); freopen(\"1096.out\", \"w\", stdout);#endif cin &gt;&gt; n; REP(i, 1, n) x[i] = read&lt;int&gt;(), p[i] = read&lt;int&gt;(), c[i] = read&lt;int&gt;(); REP(i, 1, n) s1[i] = s1[i-1] + p[i], s2[i] = s2[i-1] + x[i] * p[i]; REP(i, 1, n) { while (head &lt; tail &amp;&amp; K(q[head + 1], q[head]) &lt; x[i]) head++; dp[i] = dp[q[head]] + c[i] + x[i] * (s1[i-1] - s1[q[head]]) - (s2[i-1] - s2[q[head]]); while (head &lt; tail &amp;&amp; K(q[tail - 1], i) &lt; K(q[tail], q[tail - 1])) tail--; q[++tail] = i; } cout &lt;&lt; dp[n] &lt;&lt; endl; return 0;} BZOJ 1911题目大意一个部队中有$n\\le 10^6$个人，每个人的战斗力为$x_i$。假设一坨人的战斗力总和为$x$，那么他们最终的战斗力为$ax^2+bx+c$。一坨人的编号要连续，最大化最终的战斗力。 解析设$s_i=\\sum_{k\\in[1,i]} x_k$，则：$$dp_i=max(dp_j+a\\times(s_i-s_j)^2+b\\times(s_i-s_j)+c)$$套路：$$dp_k-dp_j&lt;a\\times(s_k-s_j)\\times(2s_i-s_k-s_j)+b(s_k-s_j)$$$$\\frac{\\frac{dp_k-dp_j}{s_k-s_j}-b}{a}+s_k+s_j&lt;2s_i$$然后上板子 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#define DREP(i, s, e) for(int i = s; i &gt;= e ;i--)#define REP(i, s, e) for(int i = s; i &lt;= e ;i++)#define DEBUG fprintf(stderr, \"Passing [%s] in Line %d\\n\", __FUNCTION__, __LINE__)#define chkmax(a, b) a = max(a, b)#define chkmin(a, b) a = min(a, b)#include &lt;iostream&gt;#include &lt;cstdio&gt;#define int long longusing namespace std;const int maxn = 1e6 + 10;template &lt;typename T&gt; inline T read(){ T ans(0), p(1); char c = getchar(); while (!isdigit(c)) { if (c == '-') p = -1; c = getchar(); } while (isdigit(c)) { ans = ans * 10 + c - 48; c = getchar(); } return ans * p;}int n, a, b, c, s[maxn], dp[maxn];int q[maxn], head, tail;double K(int k, int j) {return ((dp[k] - dp[j]) * 1. / (s[k] - s[j]) - b) / a + s[k] + s[j];}signed main(){#ifdef CraZYali freopen(\"1911.in\", \"r\", stdin); freopen(\"1911.out\", \"w\", stdout);#endif cin &gt;&gt; n &gt;&gt; a &gt;&gt; b &gt;&gt; c; REP(i, 1, n) { s[i] = s[i-1] + read&lt;int&gt;(); while (head &lt; tail &amp;&amp; K(q[head+1], q[head]) &lt; 2 * s[i]) head++; int ret = s[i] - s[q[head]]; dp[i] = dp[q[head]] + a * ret * ret + b * ret + c; while (head &lt; tail &amp;&amp; K(q[tail-1], i) &lt; K(q[tail-1], q[tail])) tail--; q[++tail] = i; } cout &lt;&lt; dp[n] &lt;&lt; endl; return 0;} BZOJ 4518题目大意由$n\\le 3000$条路$L_i$，分成$m$天走，最小化每天走的路程的方差。设方差为$v$，输出$v\\times m^2$。 解析我们设总路程为$sum$，第$i$天走的路程为$l_i$，那么我们推一下方差：要最小化答案，只要最小化$W=\\sum_{i\\in[1,m]}l_i^2$就可以了。设$dp_{i,cur}$表示已经$cur$天走了$i$段路的最小$W$，记$s_i=\\sum_{k\\in[1,m]}L_k$，我们可以写出如下方程：$$dp_{i,cur}=min(dp_{j,cur-1}+(s_i-s_j)^2)$$套路一波，设$a(x)=dp_{x,cur-1}$，然后设$k&gt;j$比$j$优秀，那么：$$a(k)+(s_i-s_k)^2&lt;a(j)+(s_i-s_j)^2$$$$a(k)-a(j)&lt;(2s_i-s_j-s_k)\\times(s_k-s_j)$$$$\\frac{a(k)-a(j)}{s_k-s_j}+s_j+s_k&lt;2s_i$$然后就可以套路上板子了。时间复杂度$O(n\\times m)$。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#define DREP(i, s, e) for(int i = s; i &gt;= e ;i--)#define REP(i, s, e) for(int i = s; i &lt;= e ;i++)#define DEBUG fprintf(stderr, \"Passing [%s] in Line %d\\n\", __FUNCTION__, __LINE__)#define chkmax(a, b) a = max(a, b)#define chkmin(a, b) a = min(a, b)#include &lt;iostream&gt;#include &lt;cstdio&gt;#define int long longusing namespace std;const int maxn = 3000 + 10, inf = 2e9;template &lt;typename T&gt; inline T read(){ T ans(0), p(1); char c = getchar(); while (!isdigit(c)) { if (c == '-') p = -1; c = getchar(); } while (isdigit(c)) { ans = ans * 10 + c - 48; c = getchar(); } return ans * p;}int n, m, l[maxn], s[maxn], a[maxn];int q[maxn], head, tail;int dp[maxn][2];bool cur;int A(int x) {return dp[x][cur ^ 1];}double K(int j, int k) {return (A(j) - A(k)) * 1. / (s[j] - s[k]) + s[j] + s[k];}signed main(){#ifdef CraZYali freopen(\"4518.in\", \"r\", stdin); freopen(\"4518.out\", \"w\", stdout);#endif cin &gt;&gt; n &gt;&gt; m; REP(i, 1, n) s[i] = s[i-1] + (a[i] = read&lt;int&gt;()); REP(i, 1, n) dp[i][cur ^ 1] = s[i] * s[i]; REP(L, 2, m) { q[head = tail = 1] = 0; REP(i, 1, n) { while (head &lt; tail &amp;&amp; K(q[head + 1], q[head]) &lt; 2 * s[i]) head++; dp[i][cur] = dp[q[head]][cur ^ 1] + (s[i] - s[q[head]]) * (s[i] - s[q[head]]); while (head &lt; tail &amp;&amp; K(i, q[tail - 1]) &lt; K(q[tail-1], q[tail])) tail--; q[++tail] = i; } cur ^= 1; } cout &lt;&lt; m * dp[n][cur ^ 1] - s[n] * s[n]; return 0;}","link":"/2019/03/30/合集-斜率优化/"},{"title":"模板 exCRT","text":"传送门Orz 小昊 题目大意求同余方程组的最小非负整数解。$$x\\equiv a_i(mod\\ b_i)$$ 解析这个东西的关键是合并同余方程。考虑两个方程：$$x\\equiv a_1(mod\\ b_1)$$$$x\\equiv a_2(mod\\ b_2)$$则可以设：$$x=k_1b_1+a_1=k_2b_2+a_2$$推导一下：$$b_1k_1+b_2\\times(-k_2)=a_2-a_1$$那么这就成了一个exgcd的形式了，显然有解的充要条件是$a_2-a_1\\mid gcd(b_1,b_2)$。然后我们惊奇的发现，合并之后求出$k_1$，只要$x\\equiv k_1b_1+a_1(mod\\ lcm(b_1, b_2))$，就可以满足上面两个式子了。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#define REP(i, s, e) for (int i = s; i &lt;= e; i++)#define DREP(i, s, e) for (int i = s; i &gt;= e; i--)#define DEBUG fprintf(stderr, \"Passing [%s] in Line %d\\n\", __FUNCTION__, __LINE__)#define chkmax(a, b) a = max(a, b)#define chkmin(a, b) a = min(a, b)#include &lt;iostream&gt;#include &lt;cstdio&gt;#define int __int128using namespace std;template &lt;typename T&gt; T read(){ T ans = 0, p = 1; char c = getchar(); while (!isdigit(c)) { if (c == '-') p = -1; c = getchar(); } while (isdigit(c)) { ans = ans * 10 + c - 48; c = getchar(); } return ans * p;}void write(int x){ if (x &lt; 0) {putchar('-');write(-x);return;} if (x / 10) write(x / 10); putchar(x % 10 + '0');}int n, a1, b1, a2, b2, x;int exgcd(int a, int b, int &amp;x, int &amp;y){ if (!b) { x = 1; y = 0; return a; } int ans = exgcd(b, a % b, y, x); y -= a / b * x; return ans;}signed main(){#ifdef CraZYali freopen(\"4777-new-new.in\", \"r\", stdin); freopen(\"4777-new-new.out\", \"w\", stdout);#endif int n = read&lt;int&gt;(), b1 = read&lt;int&gt;(), a1 = read&lt;int&gt;(), lcm; x = a1; while (--n) { b2 = read&lt;int&gt;();a2 = read&lt;int&gt;(); int k, temp, g(exgcd(b1, b2, k, temp)); k *= (a2 - a1) / g; lcm = b1 * b2 / g; x = a1 = (b1 * k + a1) % lcm; b1 = lcm; } write((x + lcm) % lcm); return 0;}","link":"/2019/03/29/模板-exCRT/"},{"title":"BZOJ 4503 [两个串]","text":"传送门这真的是个黑科技了。以后忘了怎么写KMP就写FFT了。 题目大意给出两个长度不超过$10^5$的由小写英文字符构成的字符串$S,T$，询问$T$在$S$中出现了多少次及每次出现的位置（下标从$0$开始）。$T$中可能存在?通配符，可以匹配任何英文字符。 解析由于存在通配符，普通的KMP什么的是肯定不行了。考虑以下卷积：$$C_k=\\sum_{i+j=k}(S_i-T_j)^2\\times T_j$$如果$C_k=0$，那么只可能是对于每一个$j\\in[1,k-1]$，只有可能是$T_j=0$或者$S_{k-j}=T_k$。所以我们把$T$串翻转过来，并且将?的位置设为$0$，再做一下卷积。这个时候，如果存在一个$k\\ge m$并且$C_k=0$，那么$k-m$就是一个匹配上的位置了。怎么做卷积呢？我们拆一些式子，发现最终$C_k$变成了这个东西：$$C_k=\\sum_{i+j=k}(S_i^2)\\times T_j + \\sum_{i\\in[1,k]}T_j^3 -2\\sum_{i+j=k}S_i\\times(T_j^2)$$前一部分和最后一个部分直接是卷积，中间一个前缀和。时间复杂度$O(n log_2n)$，虽然比KMP慢蛮多，但是适用性更广，个人觉得也挺好理解的。注意FFT精度掉的不少，$eps$开到了$10^{-2}$。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#define DREP(i, s, e) for(int i = s; i &gt;= e ;i--)#define REP(i, s, e) for(int i = s; i &lt;= e ;i++)#define DEBUG fprintf(stderr, \"Passing [%s] in Line %d\\n\", __FUNCTION__, __LINE__)#define chkmax(a, b) a = max(a, b)#define chkmin(a, b) a = min(a, b)#include &lt;iostream&gt;#include &lt;complex&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#define double long doubleusing namespace std;const int maxn = 1e5 + 10, maxN = (1&lt;&lt;18) + 10;const double pi = acos(-1), eps = 1e-2;char s[maxn], t[maxn];int n, m, S[maxn], S2[maxn], T[maxn], T2[maxn], T3[maxn], sum[maxn];struct Complex{ double a, b; Complex(double _a = 0, double _b = 0) : a(_a), b(_b) {} Complex operator + (Complex B) {return Complex(a + B.a, b + B.b);} Complex operator - (Complex B) {return Complex(a - B.a, b - B.b);} Complex operator * (Complex B) {return Complex(a * B.a - b * B.b, a * B.b + b * B.a);} Complex operator *= (Complex B) {return *this = *this * B;}};int L, len, R[maxN];Complex F1[maxN], F2[maxN];void FFT(Complex a[], int flag){ REP(i, 0, len - 1) if (i &lt; R[i]) swap(a[i], a[R[i]]); for (int i = 1; i &lt; len; i &lt;&lt;= 1) { Complex T(cos(pi / i), flag * sin(pi / i)); for (int k = 0; k &lt; len; k += (i &lt;&lt; 1)) { Complex t(1, 0); for (int l = 0; l &lt; i; l++, t *= T) { Complex x(a[k+l]), y(t * a[k+l+i]); a[k + l] = x + y; a[k + l + i] = x - y; } } } if (flag &lt; 0) REP(i, 0, len - 1) a[i].a /= 4*len;}int ans[maxn];signed main(){#ifdef CraZYali freopen(\"4503.in\", \"r\", stdin); freopen(\"4503.out\", \"w\", stdout);#endif scanf(\"%s\\n%s\", s + 1, t + 1); n = strlen(s + 1); m = strlen(t + 1); REP(i, 1, n) { S[i] = s[i] - 'a' + 1; S2[i] = S[i] * S[i]; } REP(i, 1, m) { T[i] = t[m - i + 1] == '?' ? 0 : t[m - i + 1] - 'a' + 1; T2[i] = T[i] * T[i]; T3[i] = T2[i] * T[i]; sum[i] = sum[i-1] + T3[i]; } REP(i, m + 1, n) sum[i] = sum[i-1]; len = 1; while (len &lt;= n + n) len &lt;&lt;= 1; L = log2(len); REP(i, 0, len) R[i] = (R[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; L - 1); REP(i, 1, n) F1[i] = Complex(S2[i] + T[i], S2[i] - T[i]); REP(i, 1, n) F2[i] = Complex(S[i] + T2[i], S[i] - T2[i]); FFT(F1, 1);FFT(F2, 1); REP(i, 0, len-1) F1[i] *= F1[i], F2[i] *= F2[i]; FFT(F1, -1);FFT(F2, -1); REP(k, 1, n) { double c = F1[k+1].a + sum[k] - 2. * F2[k+1].a; if (k-m &gt;= 0 &amp;&amp; fabs(c)&lt;eps) ans[++ans[0]] = k-m; } cout &lt;&lt; ans[0] &lt;&lt; endl; REP(i, 1, ans[0])printf(\"%d\\n\", ans[i]); return 0;}","link":"/2019/03/29/BZOJ-4503/"},{"title":"BZOJ 3527 [ZJOI2014 力]","text":"传送门简直就是万有引力吧。 题目大意给出$n$个数$q_i$，定义： $F_i={j&lt;i}\\frac{q_iq_j}{(i-j)^2}-{j&gt;i}\\frac{q_iq_j}{(i-j)^2}$ $$E_i=\\frac{F_i}{q_i}​$$求$E_i​$ 解析先推一推式子。显然： $$E_i=\\sum_{j&lt;i}\\frac{q_j}{(i-j)^2}-\\sum_{j&gt;i}\\frac{q_j}{(i-j)^2}$$ 设$F[i]=q_i​$，$G[i]=\\frac{1}{i^2}​$，$GG[i]=G[n-i+1]​$，则：$$E_i=\\sum_{j&lt;i}F[j]G[i-j]-\\sum_{j&gt;i}F[j]G[j-i]=\\sum_{j&lt;i}F[j]G[i-j]-\\sum_{j&gt;i}F[j]GG[n-j+i+1]​$$。那这后面就是两个标准的卷积减一下了，FFT即可。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#define REP(i, s, e) for(int i = s; i &lt;= e ;i++)#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#define double long doubleusing namespace std;const int maxn = 100000 + 10;const double pi = acos(-1);struct Complex{ double a, b; Complex(double _a = 0, double _b = 0) : a(_a), b(_b) {} Complex operator + (Complex B) {return Complex(a + B.a, b + B.b);} Complex operator += (Complex B) {return *this = *this + B;} Complex operator - (Complex B) {return Complex(a - B.a, b - B.b);} Complex operator -= (Complex B) {return *this = *this - B;} Complex operator * (Complex B) {return Complex(a * B.a - b * B.b, a * B.b + b * B.a);} Complex operator *= (Complex B) {return *this = *this * B;}}F[maxn &lt;&lt; 2], G[maxn &lt;&lt; 2], GG[maxn &lt;&lt; 2];int n;double q[maxn];int len, L, R[maxn &lt;&lt; 2];void FFT(Complex a[], int flag){ REP(i, 1, len - 1) if (i &lt; R[i]) swap(a[i], a[R[i]]); for (int i = 1; i &lt; len; i &lt;&lt;= 1) { Complex T(cos(pi / i), flag * sin(pi / i)); for (int k = 0; k &lt; len; k += (i &lt;&lt; 1)) { Complex t(1); for (int l = 0; l &lt; i; l++, t *= T) { Complex x(a[k + l]), y(t * a[k + l + i]); a[k + l] = x + y; a[k + l + i] = x - y; } } } if (flag &lt; 0) REP(i, 0, len - 1) a[i].a /= len;}int main(){#ifdef CraZYali freopen(\"3527-new.in\", \"r\", stdin); freopen(\"3527-new.out\", \"w\", stdout);#endif cin &gt;&gt; n; REP(i, 1, n) scanf(\"%LF\", q + i); REP(i, 1, n) { F[i].a = q[i]; G[i].a = GG[n - i + 1].a = 1. / i / i; } len = 1; while (len &lt;= n + n) len &lt;&lt;= 1; L = log2(len); REP(i, 1, len) R[i] = (R[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; L - 1); FFT(F, 1);FFT(G, 1);FFT(GG, 1); REP(i, 0, len-1) G[i] *= F[i]; REP(i, 0, len-1) GG[i] *= F[i]; FFT(G, -1);FFT(GG, -1); REP(i, 1, n) printf(\"%.3LF\\n\", G[i].a - GG[n + i + 1].a); return 0;}","link":"/2019/03/28/BZOJ-3527/"},{"title":"BZOJ 4827 [HNOI2017 礼物]","text":"传送门我一定是脑子烧坏了，FFT都写不对。 题目大意给你两个长度为$n$的序列$a,b$，满足$a_i,b_i\\in [1,m]$，$a,b$中的数组可以循环（即可以把开头放到结尾，结尾放到开头）。 定义$a,b$之间的差异值为$$\\sum_{i\\in[1,n]} (a_i-b_i)^2$$。你可以选择一个常数$c$，使得$a$或$b$中的每个数加上$c$。 求最小差异值。$n\\le 50000,m\\le 100$ 解析显然可以先确定$c\\in[-m,m]$。 然后两个序列一起循环是没有意义的，只要循环一个就可以了。 计差异值为$D$，我们把式子拆一下。 令： 则： 所以，如果我们要让$D$尽量小的话，就要尽量让$k=\\sum_{i\\in[1,n]}a_ib_i$大。 等一下。 把$b$反转一下，$k$就变成$\\sum_{i\\in[1,n]}a_ib_{n-i+1}$，这不就是一个卷积形式吗？ 那把$a$倍长（把链变成环），再和$b$做一下$FFT$，再枚举一下最大值就可以了。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#define REP(i, s, e) for (int i = s; i &lt;= e; i++)#define DREP(i, s, e) for (int i = s; i &gt;= e; i--)#define DEBUG fprintf(stderr, \"Passing [%s] in Line %d\\n\", __FUNCTION__, __LINE__)#define chkmax(a, b) a = max(a, b)#define chkmin(a, b) a = min(a, b)#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#define double long double#define int long longusing namespace std;const int maxn = 50000 + 10 &lt;&lt; 1, inf = 1ll &lt;&lt; 60;const double pi = acos(-1);template &lt;typename T&gt; T read(){ T ans = 0, p = 1; char c = getchar(); while (!isdigit(c)) { if (c == '-') p = -1; c = getchar(); } while (isdigit(c)) { ans = ans * 10 + c - 48; c = getchar(); } return ans * p;}struct Complex{ double x, y; Complex(double _x = 0, double _y = 0) : x(_x), y(_y){} Complex operator + (Complex B) {return Complex(x + B.x, y + B.y);} Complex operator += (Complex B) {return *this = *this + B;} Complex operator - (Complex B) {return Complex(x - B.x, y - B.y);} Complex operator -= (Complex B) {return *this = *this - B;} Complex operator * (Complex B) {return Complex(x * B.x - y * B.y, x * B.y + y * B.x);} Complex operator *= (Complex B) {return *this = *this * B;}}F[3 * maxn], G[3 * maxn];int n, m, a[maxn], b[maxn];int R[maxn * 3], len, L;int static_sum, all_sum, ans = inf;void FFT(Complex *a, int flag){ REP(i, 0, len - 1) if (i &lt; R[i]) swap(a[i], a[R[i]]); for (int i = 1; i &lt; len; i &lt;&lt;= 1) { Complex T(cos(pi / i), flag * sin(pi / i)); for (int k = 0; k &lt; len; k += (i &lt;&lt; 1)) { Complex t(1, 0); for (int l = 0; l &lt; i; l++, t *= T) { Complex x = a[k + l], y = t * a[k + l + i]; a[k + l] = x + y; a[k + l + i] = x - y; } } } if (flag &lt; 0) REP(i, 0, len - 1) a[i].x = (int)(a[i].x / len + 0.5);}signed main(){#ifdef CraZYali freopen(\"4827.in\", \"r\", stdin); freopen(\"4827.out\", \"w\", stdout);#endif cin &gt;&gt; n &gt;&gt; m; REP(i, 1, n) a[i] = read&lt;int&gt;(); REP(i, 1, n) b[i] = read&lt;int&gt;(); REP(i, 1, n) static_sum += a[i] * a[i] + b[i] * b[i], all_sum += a[i] - b[i]; len = 1; while (len &lt;= n + n + n) len &lt;&lt;= 1; L = log2(len); REP(i, 0, len) R[i] = (R[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; L - 1); int l(1), r(n); while (l &lt; r) swap(b[l++], b[r--]); REP(i, 1, n) F[i].x = F[i + n].x = a[i]; REP(i, 1, n) G[i].x = b[i]; FFT(F, 1); FFT(G, 1); REP(i, 0, len) F[i] *= G[i]; FFT(F, -1); REP(i, 1, n) REP(c, -m, m) chkmin(ans, static_sum + n * c * c + 2 * c * all_sum - 2 * (int)F[i+n].x); cout &lt;&lt; ans &lt;&lt; endl; return 0;}","link":"/2019/03/26/BZOJ-4827/"},{"title":"Luogu 3157 [CQOI2011 动态逆序对]","text":"传送门垃圾BZOJ，硬是过不了我的大常数。 题目大意给出一个$1$到$n$的排列$P$，依次删除$m$个数，问每次删除前整个序列的逆序对数。 解析普通不带删除的谁都会写吧，一棵树状数组完事。待删除的？我们又发现，只要维护区间内数字出现的次数就可以了。直接上一棵树状数组套权值线段树，完事。单次操作$O(log_2^2n)$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#define REP(i, s, e) for (int i = s; i &lt;= e; i++)#define DREP(i, s, e) for (int i = s; i &gt;= e; i--)#define DEBUG fprintf(stderr, \"Passing [%s] in Line %d\\n\", __FUNCTION__, __LINE__)#define chkmax(a, b) a = max(a, b)#define chkmin(a, b) a = min(a, b)#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;const int maxn = 100000 + 10;template &lt;typename T&gt; T read(){ T ans = 0, p = 1; char c = getchar(); while (!isdigit(c)) { if (c == '-') p = -1; c = getchar(); } while (isdigit(c)) { ans = ans * 10 + c - 48; c = getchar(); } return ans * p;}struct node *null;const int maxnode = 28000000;int rt[maxnode], ls[maxnode], rs[maxnode], sum[maxnode], cur, LL[30], RR[30];#define mid (l + r &gt;&gt; 1)#define lson ls[p], l, mid#define rson rs[p], mid + 1, rvoid update(int &amp;p, int l, int r, int pos, int num){ if (!p) p = ++cur; sum[p] += num; if (l == r) return; else if (pos &lt;= mid) update(lson, pos, num); else update(rson, pos, num);}int n, m, a[maxn], pos[maxn];long long ans;int query(int l, int r, int val, bool mode){ int lsz(0), rsz(0), s(0); for (int i = l-1; i &gt; 0; i -= i &amp; -i) LL[++lsz] = rt[i]; for (int i = r ; i &gt; 0; i -= i &amp; -i) RR[++rsz] = rt[i]; l = 1, r = n; while (l &lt; r) if (val &gt; mid) { if (mode) { REP(i, 1, lsz) s -= sum[ls[LL[i]]]; REP(i, 1, rsz) s += sum[ls[RR[i]]]; } REP(i, 1, lsz) LL[i] = rs[LL[i]]; REP(i, 1, rsz) RR[i] = rs[RR[i]]; l = mid + 1; } else { if (!mode) { REP(i, 1, lsz) s -= sum[rs[LL[i]]]; REP(i, 1, rsz) s += sum[rs[RR[i]]]; } REP(i, 1, lsz) LL[i] = ls[LL[i]]; REP(i, 1, rsz) RR[i] = ls[RR[i]]; r = mid ; } return s;}int main(){#ifdef CraZYali freopen(\"3157.in\", \"r\", stdin); freopen(\"3157.out\", \"w\", stdout);#endif cin &gt;&gt; n &gt;&gt; m; REP(i, 1, n) { pos[a[i] = read&lt;int&gt;()] = i; ans += 1ll * query(1, i-1, a[i], 0); for (int j = i; j &lt;= n; j += j &amp; -j) update(rt[j], 1, n, a[i], 1); } while (m --&gt; 0) { printf(\"%lld\\n\", ans); int x = read&lt;int&gt;(), p = pos[x]; ans -= query(1, p - 1, x, 0); ans -= query(p + 1, n, x, 1); for (int i = p; i &lt;= n; i += i &amp; -i) update(rt[i], 1, n, x, -1); } return 0;} P.S内存限制128MB是真的坑。之前用指针，直接new结点结果MLE。后来预先分配内存池，MLE。再后来把内存池改小，RE。我可去您的吧，一气之下吧指针改成普通数组，过了？垃圾题目，毁我青春。","link":"/2019/03/23/Luogu-3157/"},{"title":"BZOJ 1901（动态区间第K小）","text":"传送门树套树什么的真的头晕死了。 题目大意给你一个序列$a_{i\\in [1,n]}$，要求单点修改，区间询问第$k$小值。 解析如不没有修改，直接一棵主席树就可以了。有修改也没关系，整体二分就可以了。有修改的话，主席树肯定没办法了，因为它存的是前缀，修改的话时间直接GG。但是我们仍然可以运用主席树的思想。我们要做的，其实就是维护一个区间内的$cnt=[a_{i\\in [l,r]} \\le val]$，就可以查询排名、找到$k$大值了。那如果我们还是建出来$n$棵权值线段树，每次对操作暴力$O(n\\ log_2n)$的更新，就可以维护，但是显然时间GG。但是我们注意到一个事情，我们要做的东西类似下面的操作： 12345678910void update(int l, int r){ for (int i = l ; i &lt;= r; i++) tree_add(i);}int query(int l, int r){ int res = 0; for (int i = l ; i &lt;= r; i++) res += get_sum(i); return res;} 这个东西可以用什么操作？树状数组！如果我们采用类似主席树的方法，只是在权值线段树外面套一层树状数组，那我们单次操作的复杂度就成功成$O(n\\ log_2n)$降低到了可以接受的$O(log_2^2n)$了。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#define DREP(i, s, e) for(int i = s; i &gt;= e ;i--)#define REP(i, s, e) for(int i = s; i &lt;= e ;i++)#define DEBUG fprintf(stderr, \"Passing [%s] in Line %d\\n\", __FUNCTION__, __LINE__)#define chkmax(a, b) a = max(a, b)#define chkmin(a, b) a = min(a, b)#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e4 + 10, maxq = 1e4 + 10;template &lt;typename T&gt; inline T read(){ T ans(0), p(1); char c = getchar(); while (!isdigit(c)) { if (c == '-') p = -1; c = getchar(); } while (isdigit(c)) { ans = ans * 10 + c - 48; c = getchar(); } return ans * p;}int n, m, q, a[maxn], b[maxn + maxq];int to(int val) {return lower_bound(b + 1, b + 1 + m, val) - b;}bool type[maxq];int x[maxq], y[maxq], z[maxq];struct node *null;struct node{ node *ls, *rs; int sum; node() : ls(null), rs(null), sum(0) {}}*c[maxn];#define mid (l + r &gt;&gt; 1)void update(node *pre, node *&amp;p, int l, int r, int pos, int num){ node temp = *pre; p = new node(); p -&gt; ls = temp.ls; p -&gt; rs = temp.rs; p -&gt; sum = temp.sum + num; if (l == r) return; else if (pos &lt;= mid) update(temp.ls, p -&gt; ls, l, mid, pos, num); else update(temp.rs, p -&gt; rs, mid + 1, r, pos, num);}void add(int x, int pos, int num = 1){ while (x &lt;= n) { if (c[x] == NULL) c[x] = new node(); update(c[x], c[x], 1, m, pos, num); x += x &amp; -x; }}void update(int l, int r, int pos, int num = 1) {add(l, pos, num);add(r + 1, pos, num * -1);}int lsz, rsz;node *LLL[maxn], *RRR[maxn];int query(int l, int r, int k){ if (l == r) return l; int x = 0; REP(i, 1, rsz) x += RRR[i] -&gt; ls -&gt; sum; REP(i, 1, lsz) x -= LLL[i] -&gt; ls -&gt; sum; if (x &gt;= k) { REP(i, 1, lsz) LLL[i] = LLL[i] -&gt; ls; REP(i, 1, rsz) RRR[i] = RRR[i] -&gt; ls; return query(l, mid, k); } else { REP(i, 1, lsz) LLL[i] = LLL[i] -&gt; rs; REP(i, 1, rsz) RRR[i] = RRR[i] -&gt; rs; return query(mid + 1, r, k - x); }}int main(){#ifdef CraZYali freopen(\"1901-new.in\", \"r\", stdin); freopen(\"1901-new.out\", \"w\", stdout);#endif null = new node(); null -&gt; ls = null -&gt; rs = null;null -&gt; sum = 0; cin &gt;&gt; n &gt;&gt; q; REP(i, 1, n) a[i] = b[++m] = read&lt;int&gt;(); REP(i, 1, q) { char cc = getchar(); while (cc != 'Q' &amp;&amp; cc != 'C') cc = getchar(); x[i] = read&lt;int&gt;();y[i] = read&lt;int&gt;(); if (cc == 'Q') type[i] = 1, z[i] = read&lt;int&gt;(); else b[++m] = y[i]; } sort(b + 1, b + 1 + m); m = unique(b + 1, b + 1 + m) - b - 1; REP(i, 1, n) add(i, to(a[i])); REP(i, 1, q) if (type[i]) { lsz = rsz = 0; for (int now = x[i]-1; now &gt; 0;now -= (now &amp; -now)) LLL[++lsz] = c[now]; for (int now = y[i]; now &gt; 0;now -= (now &amp; -now)) RRR[++rsz] = c[now]; //提前提取需要查询的树状数组的结点 printf(\"%d\\n\", b[query(1, m, z[i])]); } else { add(x[i], to(a[x[i]]), -1); add(x[i], to(a[x[i]] = y[i])); } return 0;} P.S做题都做得感觉脑子有问题了。对于这种会让人脑子有问题的东西，有的时候不要想太多，直接把一些东西当成工具就好，不然真的头疼。","link":"/2019/03/22/BZOJ-1901（动态区间第K小）/"},{"title":"模板 静态区间第K小（主席树）","text":"传送门啊，推了一晚上，大概搞定了吧。 题目大意给定一个序列$a_{k\\in [1,n]}$，$q$次询问，每次询问$[l,r]$中第$K$小的数。 解析主席树定义有人说这就是可持久化线段树，没怎么懂这种说法。主席树其实就是一堆权值线段树，第$i$棵表示的是序列$a_{k\\in [1,i]}$的权值线段树。那这样不会超空间吗？其实不会，因为第$i$棵和第$i+1$棵权值线段树之间可能有很多公共结点。比如说${3,1,2,4,5}$这个主席树，建出来是这样的。 发现从第$i-1$棵加到第$i$棵时，只要管新加入的数$val$是应该划分到$[l,mid]$还是$[mid+1,r]$这个区间就好了。如果$val\\in [l,mid]$，那么当前结点的右儿子就和前一棵的右儿子完全相同，这时候递归处理它们的左儿子就行了。反之，如果$val\\in [mid+1,r]$，那么左儿子完全相同，递归右儿子就可以了。这样就可以共用结点了，那么动态开点就可以了。 性质由于保存的是区间的权值线段树，主席树上的数值具有区间可加性！这是一个非常好的性质，用两棵权值线段树的$query$值相减就可以方便我们在$O(log_2n)$的时间内查询一个$cnt=\\sum_{i\\in [l,r]} [a_i \\le val]$，方便查询一个数在区间内的排名（可能还要稍微修改一下，问题不大）。这就差不多了。时间复杂度应该是$O(n\\ log_2n)$的，空间复杂度动态开点。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#define DREP(i, s, e) for(int i = s; i &gt;= e ;i--)#define REP(i, s, e) for(int i = s; i &lt;= e ;i++)#define DEBUG fprintf(stderr, \"Passing [%s] in Line %d\\n\", __FUNCTION__, __LINE__)#define chkmax(a, b) a = max(a, b)#define chkmin(a, b) a = min(a, b)#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2e5 + 10;template &lt;typename T&gt; inline T read(){ T ans(0), p(1); char c = getchar(); while (!isdigit(c)) { if (c == '-') p = -1; c = getchar(); } while (isdigit(c)) { ans = ans * 10 + c - 48; c = getchar(); } return ans * p;}int a[maxn], b[maxn], n, m, q;#define mid (l + r &gt;&gt; 1)#define lson p -&gt; ls, l, mid#define rson p -&gt; rs, mid + 1, rstruct node *null;struct node{ node *ls, *rs;int sum; node() : ls(null), rs(null), sum(0){}}*rt[maxn];void build(node *pre, node *&amp;p, int l, int r, int val){ p = new node(); p -&gt; ls = pre -&gt; ls; p -&gt; rs = pre -&gt; rs; p -&gt; sum = pre -&gt; sum + 1; if (l &gt;= r) return; else if (val &lt;= mid) build(pre -&gt; ls, lson, val); else build(pre -&gt; rs, rson, val);}int query(node *u, node *v, int l, int r, int k){ if (l &gt;= r) return l; int x = v -&gt; ls -&gt; sum - u -&gt; ls -&gt; sum; if (x &lt; k) return query(u -&gt; rs, v -&gt; rs, mid + 1, r, k - x); else return query(u -&gt; ls, v -&gt; ls, l, mid, k);}int main(){#ifdef CraZYali freopen(\"3834-new-new.in\", \"r\", stdin); freopen(\"3834-new-new.out\", \"w\", stdout);#endif cin &gt;&gt; n &gt;&gt; q; REP(i, 1, n) b[i] = a[i] = read&lt;int&gt;(); sort(b + 1, b + 1 + n); m = unique(b + 1, b + 1 + n) - b - 1; rt[0] = null = new node(); null -&gt; ls = null;null -&gt; rs = null;null -&gt; sum = 0; REP(i, 1, n) { rt[i] = null; build(rt[i-1], rt[i], 1, m, lower_bound(b + 1, b + 1 + m, a[i]) - b); } while (q --&gt; 0) { int L = read&lt;int&gt;(), R = read&lt;int&gt;(), k = read&lt;int&gt;(); printf(\"%d\\n\", b[query(rt[L-1], rt[R], 1, m, k)]); } return 0;}","link":"/2019/03/21/模板-静态区间第K小（主席树）/"},{"title":"BZOJ 3110 [ZJOI2013 K大数查询]","text":"传送门哎呀这题刚了一上午没刚出来，下午发现少写$5$个字符，浑身难受。 题目大意有$N$个位置，$M$个操作。操作有$2$种： $1\\ a\\ b\\ c$ 在第$a$个位置到第$b$个位置，每个位置加入一个数$c$。 $2\\ a\\ b\\ c$ 询问从第$a$个位置到第$b$个位置，第$c$大的数是多少。 解析整体二分？早就弃坑了。我记得我之前的计划中有一个线段树套线段树来着，这个题就是一个树套树。外层搞一个权值线段树，内层套一个区间。 权值线段树定义 如图，这就是一个权值线段树，它对应的序列为${1,3,3,5,4,2}$。每个结点保存的信息有三个$[l,r],cnt$，意味着在原序列中，$cnt=\\sum_{i=1}^n [a_i \\in [l,r]]$。注意到两点： 权值线段树只保存数字的出现次数，不考虑序列的顺序。 一般来讲，权值线段树保存的序列值需要离散化（空间问题） 所以说，上面那颗线段树不开到$[1,6]$也没有关系，直接离散化（这个序列没必要）后开成$[1,5]$也可以。同样，如果序列是${1,2,5,4,3,3}$，权值线段树开成$[1,6]$，也会长成上图的样子。 找排名为$K$的数直接从根节点开始找，重复以下过程。 $K \\le now -&gt; LeftSon -&gt; cnt$$，说明这个数一定不超过当前区间最大值，那么$$now = now -&gt; LeftSon$$。 $K &gt; now -&gt; LeftSon -&gt; cnt$，说明这个数一定超过当前区间最大值，那么$K = K - now -&gt; LeftSon -&gt; cnt$，同时$now = now -&gt; RightSon$。 找到一个确定的数为止。 像$FHQ\\ TREAP$啊，还有一些数据结构都是这样找的。 权值线段树套区间差不多的东西，只是权值线段树里的东西从数变成了区间而已。内层套的区间，也就是每次加进来的值在那些地方。 标记永久化一个小小的技巧。因为结点都被拆开了，所以下传标记不太好办。怎么搞呢？不下传不就可以了吗，更新的时候一起更新，查询的时候不仅返回$sum$$，而且返回$$tag$$在区间的作用就可以了。没懂就看代码吧。 正题对于每个询问，先查找右边的总数$cnt$，如果右边总数大于等于$c$就在右子树查询第$c$大的，如果不够就在左子树查询第$c-cnt$大的。应该挺好懂的。最后，线段树动态开点。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#define REP(i, s, e) for (int i = s; i &lt;= e; i++)#define DREP(i, s, e) for (int i = s; i &gt;= e; i--)#define DEBUG fprintf(stderr, \"Passing [%s] in Line %d\\n\", __FUNCTION__, __LINE__)#define chkmax(a, b) a = max(a, b)#define chkmin(a, b) a = min(a, b)#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;template &lt;typename T&gt; T read(){ T ans = 0, p = 1; char c = getchar(); while (!isdigit(c)) { if (c == '-') p = -1; c = getchar(); } while (isdigit(c)) { ans = ans * 10 + c - 48; c = getchar(); } return ans * p;}#define mid (l + r &gt;&gt; 1)#define lson p -&gt; ls, l, mid#define rson p -&gt; rs, mid + 1, rint n, m;struct node_inside{ node_inside *ls, *rs; int sum, tag; node_inside() : sum(0), tag(0), ls(NULL), rs(NULL) {}};int query(node_inside *x, bool flag = 1) {return x != NULL ? x -&gt; sum * flag + x -&gt; tag * (flag ^ 1) : 0;}void update(node_inside *&amp;p, int l, int r, int L, int R){ if (p == NULL) p = new node_inside(); if (L == l &amp;&amp; r == R) p -&gt; tag++; else if (L &gt; mid) update(rson, L, R); else if (R &lt;= mid) update(lson, L, R); else { update(lson, L, mid); update(rson, mid + 1, R); } p -&gt; sum += R - L + 1;}int query(node_inside *&amp;p, int l, int r, int L, int R){ if (p == NULL) return 0; if (L == l &amp;&amp; r == R) return query(p); int res = (R - L + 1) * query(p, 0); if (R &lt;= mid) return query(lson, L, R) + res; else if (L &gt; mid) return query(rson, L, R) + res; else return query(lson, L, mid) + query(rson, mid + 1, R) + res;}struct node_outside{ node_inside *rt; node_outside *ls, *rs; node_outside() : ls(NULL), rs(NULL), rt(NULL){}};node_outside *T;void update(node_outside *&amp;p, int l, int r, int L, int R, int pos){ if (p == NULL) p = new node_outside(); update(p -&gt; rt, 1, n, L, R); if (l == r) return; if (pos &lt;= mid) update(lson, L, R, pos); else update(rson, L, R, pos);}int query(node_outside *&amp;p, int l, int r, int L, int R, int pos){ if (l == r) return l; int cnt = p -&gt; rs == NULL ? 0 : query(p -&gt; rs -&gt; rt, 1, n, L, R); if (cnt &gt;= pos) return query(rson, L, R, pos); else return query(lson, L, R, pos - cnt);}int main(){#ifdef CraZYali freopen(\"3110.in\", \"r\", stdin); freopen(\"3110.out\", \"w\", stdout);#endif cin &gt;&gt; n &gt;&gt; m; while (m --&gt; 0) { int opt(read&lt;int&gt;()), a(read&lt;int&gt;()), b(read&lt;int&gt;()), c(read&lt;int&gt;()); if (opt == 1) update(T, 1, n, a, b, c); else printf(\"%d\\n\", query(T, 1, n, a, b, c)); } return 0;}","link":"/2019/03/18/BZOJ-3110/"},{"title":"读入黑科技","text":"这里要Orz一下LK大佬~~ 很久以前，我听说过一个叫fread的东西 然而我并不会用！直到有一天，我打开大佬的博客 太强了！123456789101112131415161718#include&lt;****&gt;const int N=1&lt;&lt;27;//可以修改，表示输入文件不会超过的长度char buf[N],*inf=buf;int read(){//这是一个读不进负数的数字读入 int k=0; while(!isdigit(*inf))++inf; while(isdigit(*inf)){ k=k*10+(*inf-'0'); ++inf; } return k;}int main(){ //freopen(***); //开文件必须在fread前面 fread(buf, 1, N, stdin);//读入整个输入文件 ***** return 0;}","link":"/2017/01/01/读入黑科技/"}],"tags":[{"name":"树套树","slug":"树套树","link":"/tags/树套树/"},{"name":"高级数据结构","slug":"高级数据结构","link":"/tags/高级数据结构/"},{"name":"主席树","slug":"主席树","link":"/tags/主席树/"},{"name":"FFT、NTT","slug":"FFT、NTT","link":"/tags/FFT、NTT/"},{"name":"字符串","slug":"字符串","link":"/tags/字符串/"},{"name":"黑科技","slug":"黑科技","link":"/tags/黑科技/"},{"name":"平衡树","slug":"平衡树","link":"/tags/平衡树/"},{"name":"AC自动机","slug":"AC自动机","link":"/tags/AC自动机/"},{"name":"技巧","slug":"技巧","link":"/tags/技巧/"},{"name":"倍增","slug":"倍增","link":"/tags/倍增/"},{"name":"树上莫队","slug":"树上莫队","link":"/tags/树上莫队/"},{"name":"坑","slug":"坑","link":"/tags/坑/"},{"name":"Kruskal重构树","slug":"Kruskal重构树","link":"/tags/Kruskal重构树/"},{"name":"口胡系列","slug":"口胡系列","link":"/tags/口胡系列/"},{"name":"胡闹系列","slug":"胡闹系列","link":"/tags/胡闹系列/"},{"name":"计算几何","slug":"计算几何","link":"/tags/计算几何/"},{"name":"斜率优化","slug":"斜率优化","link":"/tags/斜率优化/"},{"name":"excrt","slug":"excrt","link":"/tags/excrt/"},{"name":"WO YE BU HUI","slug":"WO-YE-BU-HUI","link":"/tags/WO-YE-BU-HUI/"},{"name":"Hash","slug":"Hash","link":"/tags/Hash/"},{"name":"lct","slug":"lct","link":"/tags/lct/"},{"name":"网络流","slug":"网络流","link":"/tags/网络流/"},{"name":"交互","slug":"交互","link":"/tags/交互/"},{"name":"生成函数","slug":"生成函数","link":"/tags/生成函数/"},{"name":"套路","slug":"套路","link":"/tags/套路/"},{"name":"胡闹","slug":"胡闹","link":"/tags/胡闹/"},{"name":"毒瘤计数","slug":"毒瘤计数","link":"/tags/毒瘤计数/"},{"name":"卡常","slug":"卡常","link":"/tags/卡常/"},{"name":"数论","slug":"数论","link":"/tags/数论/"},{"name":"莫比乌斯反演","slug":"莫比乌斯反演","link":"/tags/莫比乌斯反演/"},{"name":"容斥","slug":"容斥","link":"/tags/容斥/"},{"name":"左偏树","slug":"左偏树","link":"/tags/左偏树/"},{"name":"可并堆","slug":"可并堆","link":"/tags/可并堆/"}],"categories":[{"name":"题解","slug":"题解","link":"/categories/题解/"},{"name":"杂项","slug":"杂项","link":"/categories/杂项/"},{"name":"题解（口胡）","slug":"题解（口胡）","link":"/categories/题解（口胡）/"},{"name":"合集","slug":"题解/合集","link":"/categories/题解/合集/"},{"name":"模板","slug":"模板","link":"/categories/模板/"}]}